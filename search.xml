<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[vSAN] CMMDS (Cluster monitoring, membership, and directory service)</title>
      <link href="/2022/09/15/vsan/ioworkflow_cmmds/"/>
      <url>/2022/09/15/vsan/ioworkflow_cmmds/</url>
      
        <content type="html"><![CDATA[<p>vSAN的四大Component - CMMDS、DOM、CLOM、LSOM，他們四個從最底層與物理硬碟交互到最上層協同各個Cluster裡的Nodes，彼此各司其職，大致上的交互邏輯如下圖所示，本篇將介紹的是vSAN CMMDS</p><p><img src="/images/vsan/vsan_ioworkflow.png" alt=""></p><p>vSAN CMMDS(Cluster monitoring, membership, and directory service)主要運作在ESXi的kernel層。負責在vSAN cluster和vSAN Node之間，進行探索、維護等監控任務，並管理cluster裡的各項資源，例如網路、儲存空間、component數量等等，上述這些cluster metadata會以key-value形式存在directory。</p><p>由於vSAN是一個分散式儲存系統，所以directory上面儲存的資料難免有碰撞和衝突，vSAN CMMDS採取的是master-agent架構，vSAN Cluster會透過Paxos演算法選舉出master node，其他node為agent，當Object訊息發生異動時，Agent會向master node提供更新訊息，由master決定是否要更新。同時，master也會單播(unicast)這些metadata訊息給其他節點。節點彼此間會透過經典的heartbeat傳輸以保證Cluster內的所有node都是健康的</p><p>vSAN CMMDS為最終一致性架構，意思就是如果A對一個Object做寫入或修改，同時B讀Object的metadata時可能會有過期的資訊，一般來說，1ms內可以消除這個資訊不對稱的問題。</p><p>到目前為止，vSAN CMMDS聽起來像是vSAN內部的一個Backend Service，專門搜集cluster的metadata然後存著，那麼vSAN的哪個Component會對CMMDS發出request呢？是DOM，我們會在下一篇提到DOM(Distribute Object Manager)</p><p>最後總結，CMMDS是在ESXi kernel層實現的，CMMDS具有如下特性</p><ul><li>CMMDS負責搜集cluster的metadata，例如網路、儲存空間、component數量等等</li><li>CMMDS存metadata的方式是以key value的形式，各個ESXi host可以去query這些data</li><li>CMMDS是分散式系統架構，每個node代表三種角色 - master, agent和backup三中角色之一，agent向master提供cluster metadata，master決定是否要存進去directory，backup負責作為master的備份，萬一master掛了可以替代為master</li><li>CMMDS為最終一致性架構，不過cluster裡的metadata通常可以保證1ms內達成一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cmmds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]FileService &amp; iSCSI</title>
      <link href="/2022/09/07/vsan/vsan_fileservice_iscsi/"/>
      <url>/2022/09/07/vsan/vsan_fileservice_iscsi/</url>
      
        <content type="html"><![CDATA[<p>我們知道vSAN主要是以Object的形式作為儲存單位，存的是VM Object，而Block和File兩個常用的儲存單位也經常被大企業或是資料中心所用到，vSAN當然也有暴露相關的接口，這裡來聊聊vSAN裡iSCSI存取block storage和Fileservice存取檔案的原理</p><h3 id="iscsi">iSCSI</h3><p>首先，SCSI是SAS/SATA的SSD/HDD用於與作業系統溝通的一種interface protocol，本來是需要透過實體接口才能進行存取，後來又制定了可以透過網路TCP/IP來傳送SCSI指令的技術，叫做iSCSI，使得連接距離可以達到無上限，連結的伺服器數量也是無限</p><p>這也是為何vSAN有提供此接口的原因，vSAN本質上是一塊專用儲存網路，形成了一個儲存池，外部應用可以隨時取用、擴容等等，像是Thin provision，vSAN加上iSCSI技術，把儲存變成「可路由」的，像普通的網路通信一樣，使得遠在天邊的應用或主機可以直接存取vSAN上的儲存池。</p><p><img src="/images/vsan/iscsi_edit_target.png" alt=""></p><span id="more"></span><p>在vSAN中，開啟iSCSI服務後，會產生一個home object for iSCSI去存一些相關的metadata</p><p><img src="/images/vsan/iscsi_add_target.png" alt=""></p><p>iSCSI服務啟動後，我們可以到vSAN Cluster→Configuration→iSCSI Target→add新增一個iSCSI Target，我們可以把iSCSI target當成一個vSAN的endpoint</p><p><img src="/images/vsan/iscsi_add_lun_to_target.png" alt=""></p><p>最後，我們可以根據iSCSI target分配LUN的ID，LUN的單位就是一個磁碟了，這種感覺就像是在一個磁碟組下面創建一個磁碟</p><h3 id="fileservice">Fileservice</h3><p>我們也能基於vSAN Datastore提供NFS的服務，這是vSAN7的新功能，vSAN上的File service是一個分散式的檔案系統(VDFS)，主要的目的是提供VM間的檔案共用，當然也可以透過像NAS那樣在自己的電腦上掛載一個NFS</p><p><img src="/images/vsan/file_service_structure.png" alt=""></p><p>從上圖可以看到vSAN FileService是共用vSAN儲存的，當然，ESXi node上必須啟用一台File service node VM，把Object轉換成File格式，也就是上圖的綠色Applicance VM，最後整合再一起，給Clients或VM透過SMB/NFS共享檔案池</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> fileservice </tag>
            
            <tag> iscsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]Datacenter級別的異地備援 - Stretched Cluster</title>
      <link href="/2022/08/25/vsan/vsan_stretched_cluster/"/>
      <url>/2022/08/25/vsan/vsan_stretched_cluster/</url>
      
        <content type="html"><![CDATA[<p>前面說到了Fault Domain，我們可以把相同機櫃的host匡列成同個Group，這樣Object下的Component就會被分散在不同機櫃裡，那如果擔心地震、火災等等會讓整個Datacenter遭殃，不就造成永久的Data loss嗎？</p><p>Stretched Cluster為一種異地備援機制，可以建立兩個以不同地區Datacenter的Fault Domain，不過由於跨地區，Witness必須是獨立於Cluster之外Host，可以為單個，也可以為多個。</p><span id="more"></span><p>由於是跨地區的Datacenter備份機制，規定了兩個Datacenter互相ping必須是5ms以內，且只能設定兩個Fault Domain - Preferred 和 Secondary Domain，由於只有兩個Domain，所以FTT只能設定為FTT=1，RAID只能設定RAID-1</p><p>然後來說說對於Stretched cluster，資料是如何進行I/O的，Preferred Domain為主要進行I/O的對象，對於寫入，為了確保最終一制性，只有當資料成功寫入兩邊的SSD時，才算是寫入完畢。</p><p>針對資料讀取的部分，vSAN Stretched cluster有支持Site Read Locality，會優先讀取離自己近的資料。</p><p>而Witness作為一個節點或是一個Fault Domain，他的作用就是當Datacenter發生故障時，作為tiebreaker仲裁當VM的I/O過來時，要去哪個Datacenter存取，主要是在故障發生後保證整個系統的可用性。</p><h2 id="故障種類">故障種類</h2><h3 id="一個datacenter-故障">一個Datacenter 故障</h3><p>當一個Datacenter出現異常的時候，例如掉電，或是失去與Witness的聯繫，Witness就會把路由導向健康的Datacenter。</p><h3 id="兩個datacenter之間失去聯繫">兩個Datacenter之間失去聯繫</h3><p>當兩個Datacenter出現了網路的問題，但是各自都能連上Witness，所以都覺得自己是健康的，這時需要Witness作為仲裁，投下那個關鍵的一票，指定誰是外部的存取對象。</p><h3 id="witness-node故障">Witness node故障</h3><p>如果只有Ｗitness node故障，Datacenter裡的VM還是可以照常運行，只是會在vCenter上的vSAN Health監控平台提醒恢復Witness node。</p><h3 id="witness-node和一個datacenter故障">Witness node和一個Datacenter故障</h3><p>當這種情況發生時，只能人工介入了，在vCenter上的vSAN Health監控平台會對其進行報警。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的是怎麼做分散式儲存的</title>
      <link href="/2022/08/13/vsan/vsan_policy_layout/"/>
      <url>/2022/08/13/vsan/vsan_policy_layout/</url>
      
        <content type="html"><![CDATA[<p>我們知道，vSAN是一個Policy based的分散式儲存系統，vSAN會根據Object所設定的Policy，把Object下的Component妥善地分散儲存在不同Host。</p><p>Policy指的就是RAID 0/1/5/6，目前常見的有這四種，其中RAID 5/6由於需要進行erasure coding和XOR操作，需要耗費一些計算資源以及一些I/O，所以只有當使用all flash架構才能設定。</p><span id="more"></span><p>一般來說，Policy除了設定RAID 0/1/5/6，還可以設定FTT，可以這麼說，RAID設定目的是調整怎麼對資料進行備份，FTT單純就是能容忍幾台host failure。例如我們也可以這樣設定，RAID 1, FTT=2，我們知道RAID 1的寫入邏輯是一模一樣寫多份，由於是FTT=2，vSAN會對他一模一樣寫三份，這樣才能容忍三個Host掛掉。</p><h3 id="fault-domain">Fault Domain</h3><p>我們把Object下的Component分散在不同的Host目的是為了安全，如果一台Host掛了也不至於資料丟失，但是現在的主機可能是機架式的，這意味著可能機架掉電會讓整個機架上的Host都掛，如果Object下的所有Components都放在同個機架上怎麼辦？</p><p>我們可以對一組Host進行Group，這一組Host我們就稱為Fault Domain，這麼一來，如果Configure Policy RAID 1, FTT=1，Object下的兩個Component加上Witness就會分散在不同的Fault Domain，注意的是vSAN Cluster至少需要三台Host，這意味著如果要設定Fault Domain，也至少需要三個Fault Domain。</p><p>那接下來有個疑問了，如果我想做的是Datacenter層級的備份呢？如果Datacenter失火了，我想要兩個Datacenter，並把Component妥善地分配在這兩個Datacenter? 接下來提到的Stretched cluster就會提到這部分，為的就是解決這個問題。</p><h3 id="object如何從異常中恢復">Object如何從異常中恢復</h3><p>當vSAN偵測到異常事件，例如Host掉電、Disk損壞、網路異常等等，vSAN會確認故障的設備存放哪些Component，並嘗試對這些Component做出相應的修復，同時將資料I/O等等導向健康的Component</p><p>遇到不同的異常事件，vSAN會採用不同的因應方式，優先重建Component，如果無法達成，例如vSAN Cluster只有三個Host並且Policy FTT=1且一個Host掛了，就會標記為無法重建，這裡列舉幾個在vSAN中定義的Object狀態</p><ul><li>Inaccessible<ul><li>vSAN的Object無法重建，需要人工干預和排查Root Cause，屬於嚴重錯誤</li></ul></li><li>Unassociated<ul><li>當vSAN裡的Object沒有和某一台VM關聯起來，就會被判定為unassociated，</li><li>VMware KB: <a href="https://kb.vmware.com/s/article/70726">https://kb.vmware.com/s/article/70726</a></li></ul></li><li>Reduce availability<ul><li>vSAN正在重建Object使之符合Policy Compliance，短暫時間無法取用Object，有時候可以立即重建，有時候需要等待一段時間(預設值為60分鐘)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的儲存基本單位 - Object</title>
      <link href="/2022/07/29/vsan/vsan_distributed_object/"/>
      <url>/2022/07/29/vsan/vsan_distributed_object/</url>
      
        <content type="html"><![CDATA[<p>再讓我們把主題切回vSAN。現在我們有了儲存系統 - Object Storage的基本知識後，我們可以更深入的探討vSAN是怎麼存Object的。</p><p>vSAN是一種軟體定義儲存的產品，他的儲存單位是Object，Object是什麼呢？回到Day 06，Object可以理解為一個巨大的資料夾，每個檔案就是一個Object，所以搜索Object資料不用一個個資料夾找，今天我們更深入的來理解所謂的「軟體定義」以及Object/Component在vSAN裡面代表著什麼</p><span id="more"></span><p>從傳統的儲存架構來說，我們想對硬碟裡面的資料進行備份，必須透過硬體RAID卡來進行，這就有了缺點了，舉例來說，如果我想對這台虛擬機用RAID 1的方式備份三份，對另外一台虛擬機不需要備份，RAID 0即可，這對於硬體的管理成本非常巨大且可能有資源的浪費</p><p>vSAN裡的「軟體定義」就是指User可以針對這個Object定義他的備份Policy，透過Policy驅動指定備份的方式。透過軟體定義的方式就更方便更彈性多了，VM不受硬體的約束，可以隨時的指定VM的備份Policy。</p><p>講完了Object，最後來說說Component，Component在vSAN中分別代表什麼概念呢？</p><p>假如我們在vSAN有一台虛擬機，其中他的VMDK就是一個Object，裡面存放著虛擬硬碟的資料，我們想對他做一份完整的備份，使用RAID 1，也就是FTT=1。RAID 1前面有提過，這裡就不贅述，FTT 1代表可以容忍一個節點失誤，這樣一來，我們總共需要兩個節點放這個Object，Object變成兩份一模一樣的Components，分散在不同主機上，如下圖所示</p><p><img src="/images/vsan/vsan_object_component_layout.png" alt=""></p><p>從上圖可以看到，兩個Components的資料一模一樣，只是被分配在不同的主機上，再加上一個Witness見證節點，Object的metadata就是存在Witness的，我們知道Object的metadata有個重要的功能就是引導Object資料的位置，所以Witness負責當外部Object request過來之後，判斷要從哪個節點拿Compoent，以免發生腦裂現象或是兩台主機連不上線的時候。</p><p>順帶一提，在vSAN中，預設的Object儲存方式就是RAID 1，FTT-1，所以最小的vSAN Cluster配置是三台主機。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]儲存最速的Protocol - NVMe</title>
      <link href="/2022/07/16/vsan/ssd_nvme_overview/"/>
      <url>/2022/07/16/vsan/ssd_nvme_overview/</url>
      
        <content type="html"><![CDATA[<p>NVMe是一種主機與SSD之間溝通的協議，前面說到PCIe有三層，NVMe屬於第四層，隸屬於協議中的最高層，如下圖所示</p><p><img src="/images/vsan/nvme_structure.png" alt=""></p><span id="more"></span><p>NVMe作為應用層協議，理論上可以是配所有物理接口協議，但是NVMe起初的設計是根據PCIe，所以後面都是基於NVMe+PCIe進行探討。</p><p>NVMe協議是為SSD所生，他就像是古代的軍師，運籌帷幄之中，決勝千里之外，將設計好的計謀交給手下大將去執行，也就是PCIe，NVMe+PCIe這兩個天作之合無疑在SSD領域中是最強的。</p><h3 id="nvme-over fabrics">NVMe over Fabrics</h3><p>在傳統的儲存伺服器，我們利用iSCSI，透過網路的方式連結遠端的硬碟，形成一個儲存池，如下圖所示</p><p><img src="/images/vsan/storage_overall_structure.png" alt=""></p><p>他的好處是非常節省成本，只需要使用ethernet和成熟的iSCSI協議即可。但是這樣的方式會帶來一個問題，NVMe+PCIe的速度非常快，throughput可以做到10us，而iSCSI的極限則是100us，這就像是把一台法拉利跑車放在台北市上班時段的建國高架橋上，縱使有非常快的引擎，還是發揮不出來</p><p>NVMe over Fabrics就是為了解決這個問題，他指定了Transaction Layer的協議例如RDMA、PCIe Fabrics的技術，不過需要專用的硬體網路設備。在眾多的Transaction Layer協議中，重點介紹一下RDMA，RDMA是遠端DMA，他通過網路把資料直接傳入主機的儲存區，不需要CPU一個個編碼協議和解析協議，進而降低了CPU的工作量。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
            <tag> nvme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]SSD PCIe接口</title>
      <link href="/2022/07/09/vsan/ssd_pcie_overview/"/>
      <url>/2022/07/09/vsan/ssd_pcie_overview/</url>
      
        <content type="html"><![CDATA[<p>PCIe是SSD一項重要和主流的接口技術，所以我們有必要對PCIe有深入的了解</p><p>PCIe從第一代，到最近2022年第六代的規格問世，速度越來越快，相比於SAS/SATA，PCIe資料傳輸的「高速公路」更多，最多可以有32個Lane，SAS/SATA只能有一個Lane，所以我們可以說，PCIe的速度就是Lane的數量x單條Lane的速度</p><h3 id="pcie-拓樸結構">PCIe 拓樸結構</h3><p>PCIe採用的是樹形拓樸結構，如下圖所示</p><p><img src="/images/vsan/pci_topology.png" alt=""></p><p>Root Complex是樹的根，為CPU所服務，Root Complex能存取PCIe設備，也能存取記憶體</p><span id="more"></span><p>所以具體來說，Root Complex的spec是什麼呢？他的內部很複雜，PCIe Spec也沒有規定Root Complex該做什麼，不該做什麼，我們可以理解為他是一台筆記型電腦，外部的PCIe設備就是USB的插槽，如果插槽不夠用，我們需要擴充更多設備，就需要一個Switch，像是一個USB的Hub一樣</p><h3 id="pcie分層結構">PCIe分層結構</h3><p>PCIe作為一個資料通訊接口，就某種意義跟跨主機的網路接口類似，都需要分層各司其職的去處理複雜的問題，網路有TCP/IP五層協議，PCIe則定義了三層，Physical, Data Link, Transaction Layer，如下圖所示</p><p><img src="/images/vsan/pci_layer.png" alt=""></p><p>和網路通信一樣，PCIe也是以Packet的形式傳輸，每一層都有固定的格式</p><p><strong>Physical Layer</strong></p><p>負責處理Packet物理傳輸，怎麼分到各個Lane傳輸以及匯總</p><p><strong>Data Link Layer</strong></p><p>主要負責Data的檢錯和糾錯、電源管理等等</p><p><strong>Transaction Layer</strong></p><p>主要負責創建Packet、流量控制還有QOS和事物排序等等</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]電子儲存介質 - SSD的介紹</title>
      <link href="/2022/06/30/vsan/ssd_overview/"/>
      <url>/2022/06/30/vsan/ssd_overview/</url>
      
        <content type="html"><![CDATA[<p>科技日新月異，第一款商用SSD固態硬碟於1991年問世，當時大小只有20MB，然而由於價格太貴，一直到2007年，才開始產生主流需求，在SSD大行其道之前，主要是HDD的天下，到了2022年，SSD單位容量的成本越來越低，所有有興趣想涉略存儲領域的人都必須了解SSD。</p><p>SSD和HDD這兩者最大的差別就是「介質」的不同，HDD使用「磁」的正負極紀錄0和1的資料，SSD使用的是「電子」正負極代表0和1，這間接影響了尋址的速度，HDD需要一個磁碟頭在磁盤上逐一掃描，而SSD利用電子，能快速的定位目標地址，這也說明了為何SSD相較於HDD有這麼大的I/O速度上的差異</p><span id="more"></span><table><thead><tr><th>比較項目</th><th>SATA HDD</th><th>SATA SDD</th><th>差別</th></tr></thead><tbody><tr><td>平均開機時間</td><td>27秒</td><td>8秒</td><td>x3.5</td></tr><tr><td>連續讀/寫(MB/s)</td><td>160 / 60</td><td>540 / 330</td><td>x3 / x6</td></tr><tr><td>隨機讀/寫時間(IOPS)</td><td>450/400</td><td>98000 / 70000</td><td>x217 / x175</td></tr><tr><td>讀寫功耗(W)</td><td>6</td><td>5</td><td>x1</td></tr><tr><td>重量</td><td>120g</td><td>80g</td><td>x1.5</td></tr><tr><td>每GB成本(NTD$)</td><td>1.3$</td><td>2.3$</td><td>x2</td></tr><tr><td>介質</td><td>磁性介質</td><td>電子介質</td><td></td></tr><tr><td>讀取寫入</td><td>磁頭+馬達</td><td>SSD控制器</td><td></td></tr><tr><td>耐震程度</td><td>低</td><td>高</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>如今HDD已經非常成熟，然而SSD還有巨大的進步空間，製程的進步使得晶片密集度越來越高，相同尺寸能容納的容量更多，另外SSD裡面有controller，也就是FTL(Flash Translation Layer)，軟體的迭代升級也能加速的SSD的I/O速度。</p><p>SSD用的半導體元件是NAND Flash，他是一種非易失性儲存技術，即斷電之後資料還會保存，NAND Flash在SSD的排列最小單元為多個bits，根據有幾個bits目前主流有1個~4個，分別為SLC、MLC、TLC和QLC，每次對資料進行I/O，只能對最小單元的所有bits同時操作，這也造就了SLC的I/O速度最快，但是單位容量最貴，QLC的速度最慢，但是單位容量最便宜。</p><p>SSD有個致命的缺點，就是NAND Flash有一定的讀寫數量限制，對同一塊NAND Flash有過多的頻繁寫入，會影響SSD的使用壽命，所以在SSD裏面，假如500GB好了，會預留一小塊空間，作為SSD的firmware，當有I/O過來時，依靠演算法負責「均勻」的對每一塊NAND Flash做寫入和擦除。</p><p>有了上述基本知識後，簡單介紹一下電腦上的一次I/O是如何與SSD固態硬碟交互的，如下圖所示</p><p><img src="/images/vsan/ssd_structure.png" alt=""></p><ol><li>使用者使用鍵盤滑鼠在電腦對資料做讀取/寫入</li><li>電腦的作業系統上的檔案系統針對使用者的操作翻譯成與硬碟交互的Block storage I/O指令</li><li>藉由Interface協議，將I/O指令傳遞給SSD的Controller<ol><li>目前SSD有三個Interface協議，分別為SAS，SATA和PCIe，SAS和SATA比較舊，無法發揮NAND的極速，目前PCIe搭配NVMe的SSD越來越主流，能發揮NAND的</li><li>PCIe是接口，NVMe是傳輸協議</li><li>SATA是接口也是傳輸協議，SATA一般是家用，目前可以到6GB/s</li><li>SAS是接口，用的是SCSI傳輸協議，SAS一般是企業用</li></ol></li><li>SSD Controller(FTL)根據要寫入的I/O，判斷寫入到或讀取哪個Block<ol><li>SSD Controller對NAND Flash的操作有讀取、寫入和擦除，注意，如果要對該NAND Flash上的資料做「更新」，必須要擦除後才能寫入</li><li>影響NAND Flash的壽命就是擦除次數</li><li>Controller做的事就是讓擦除的次數盡量的少，讓擦除盡量平均分配在每一塊NAND Flash</li></ol></li><li>透過Interface協議，將資料一路返回到電腦作業系統</li></ol>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的硬碟如何擺放達到讀寫最佳化？</title>
      <link href="/2022/06/17/vsan/vsan_diskgroup_overview/"/>
      <url>/2022/06/17/vsan/vsan_diskgroup_overview/</url>
      
        <content type="html"><![CDATA[<p>VMware於2014發表了vSAN，在當時HDD仍然是主流，SSD雖然速度快但是成本高昂，為了能達到速度快並且節省成本的目的，vSAN cluster採用的是雙層儲存架構，如下圖所示</p><span id="more"></span><p><img src="/images/vsan/diskgroup_twolayer.png" alt=""></p><p>磁碟群組的入口是SSD，SSD只存放HDD的Cache資料，其中70%的容量用作Read Cache，30%的容量用作Write Cache，一個磁碟群組最多可以放7個HDD device，每個Host最多支持5個磁碟群組，所以一個Host最多可以有49個容量磁盤。</p><p>當然，我們也可以在維持相同的雙層儲存架構下，把所有HDD替換成SSD，也就是All Flash，全閃存模式。啟用了全閃存模式後，vSAN Cluster可以支援更多功能例如Compression、dedup、RAID-5/6等等功能。</p><p>這種兩層的架構缺點是如果唯一入口SSD掛了，就會使得他後面的HDD容量層都不能使用。另外，剛剛提到的Hybrid和All Flash模式，這兩個模式下cache層會有不同的cache演算法，角色也不完全相同。</p><p>當採用Hybrid模式時，快取演算法將著重於「暫時資料」，外部的I/O會先寫入SSD，就馬上回傳I/O成功，之後再透過Async非同步的方式把資料寫入容量層中，快取層同時擔任了「讀取快取」和「寫入緩衝」的角色。</p><p>當採用All flash時，快取演算法將著重於「熱資料」要放在快取層中，快取層全部都是負責寫入緩衝，讀取快取則是放在容量層，因為全部都是SSD讀取可以非常快。</p><p>寫入緩衝的意思是他不會直接寫進去容量層，而是會在快取層停留一段時間，其目的是維持vSAN物件的可用性，當vSAN對一個物件寫入資料時，一般來說當FTT&gt;1，就會對至少一個host寫入，當寫入兩個host的SSD時，才會把真正的寫入容量層內。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的存取形式? DAS、NAS和SAN</title>
      <link href="/2022/06/04/vsan/storage_protocol_overview/"/>
      <url>/2022/06/04/vsan/storage_protocol_overview/</url>
      
        <content type="html"><![CDATA[<p>前面分別講了資料儲存的最小單元、硬碟陣列怎麼做備份以及提高可用性，接下來安迪想講的是儲存系統架構 - DAS、NAS和SAN</p><h3 id="das">DAS</h3><blockquote><p>DAS(Direct Attach Storage) - 本地的檔案系統</p></blockquote><p>DAS可以理解為就是本地的磁碟陣列，透過USB，你的個人電腦或伺服器就可以連結到這個磁碟陣列，根據RAID卡，進行相應的備份，當然，他的缺點就是需要有一條實體USB線，且擴充容量等等比較麻煩。</p><h3 id="nas">NAS</h3><span id="more"></span><blockquote><p>NAS - 網路上的檔案系統</p></blockquote><p>接下來會分享兩個常用的雲端基礎架構NAS和SAN的原理和不同之處，NAS和SAN都是利用網路來連接的，簡單來說NAS適合在家裡使用或小範圍同個網段下使用，而SAN適合大範圍甚至外網使用。</p><p>從NAS說起，NAS的原理就是之前提到的File storage，只是我們一般在使用windows的時候，硬碟都在電腦裡的，不透過網路就可以直連，NAS就是一個把硬碟抽離出來，放在網路上，透過網路存取硬碟的技術架構。</p><p>下圖是NAS的架構</p><p><img src="/images/vsan/nas_overview.png" alt=""></p><p>我們可以看到，是什麼東西在網路上傳遞呢？是檔案系統的指令，我們雖然只需要告訴檔案系統路徑+檔案名稱即可，但是檔案open需要讀吧，所以傳遞了open指令、read指令等，這些都需要網路傳輸，相比於SAN(下一篇會講)把這些都做在主機上，記憶體的傳輸效率一定比網路高</p><p>用人話說就是 - 程式跟自己的電腦說，幫我把/mnt/nas.txt傳到電腦的記憶體，這些話都透過TCP/IP傳輸，然後NAS上的檔案系統根據這個檔案找到佔用了哪個扇區，從本身的server的硬碟找檔案</p><p><strong>優點</strong></p><ol><li>成本低 - NAS只需要一般的Ethernet，好擴增，只要有IP的地方就可以提供服務</li><li>資源獨立 - 檔案讀寫都需要記憶體和CPU資源，有了NAS可以把這些資源抽離出來集中管理</li><li>易共享 - 可以理解為大家都能連上你的D槽，不怕難分享</li><li>協議多元 - 舉凡是FTP或是HTTP等都可以使用</li></ol><p><strong>缺點</strong></p><ol><li>速度慢 - 因為文件系統的指令複雜，可能使用者的一個操作代表很多個指令，不過最大的瓶頸還是底層的Ethernet通常比較慢，NAS一班也不會使用光纖網路</li><li>不支持遠距離 - 由於上述原因，如果又遠距離就更慢了，另外，文件系統on the fly傳輸本身就不安全</li><li>不可靠 - 文件系統難以做到多機器保護</li></ol><h3 id="san">SAN</h3><blockquote><p>SAN - 網路上的硬碟</p></blockquote><p>安迪的工作就是開發公司的SAN產品，所以安迪對他比較了解</p><p>SAN就是空出一個網路區域，讓硬碟機櫃互相連接，網絡專給I/O使用的一塊區域網絡，外部的伺服器或個人電腦可以透過網路的方式連進去存取資料</p><p>下圖是SAN的架構</p><p><img src="/images/vsan/san_overview.png" alt=""></p><p>從上圖可以看出，有別於NAS，SAN就是個block storage，接受block storage的指令，回傳資料，檔案系統的指令和演算法是在前端主機完成的，</p><p>用白話文說就是 - 程式跟自己的電腦說，幫我把/mnt/san.txt傳到電腦的記憶體，檔案系統會計算這個檔案的LBA地址和長度，然後把這個資訊傳給SAN</p><p>我們可以看到SAN有別於NAS，他在網路傳遞的是I/O指令，透過iSCSI或是NVMe包裝，所以速度較NAS快</p><p><strong>優點</strong></p><ol><li>支持遠距離 - iSCSI等協議已經非常成熟</li><li>速度快 - 伺服器與儲存設備傳遞的是I/O指令，較為簡潔</li><li>可靠性高 - 容易做多機器備份、儲存共享</li></ol><p><strong>缺點</strong></p><ol><li>貴 - 通常要做SAN了，代表要買很多台機器、好的網路線等等，通常只有大公司才會使用，不過最近iSCSI逐漸流行，以往SAN都透過光纖，現在也能透過ethernet傳輸了</li><li>複雜度高 - 要用RAID0 1 5 6呢？要用雙主結點還是主從結點還是一主一備呢？這些都要根據實際場景需求決定</li><li>不好管理 - 前端要裝專門的SAN管理系統才能使用</li><li>協議單一 - 只有SCSI協議</li></ol>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
            <tag> nas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的備份形式? RAID</title>
      <link href="/2022/05/10/vsan/storage_raid_overview/"/>
      <url>/2022/05/10/vsan/storage_raid_overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果資料儲存只是把資料存進去硬碟裡，那就有點單調了，不如我們來加點把戲吧！</p></blockquote><p>資料要存，就要把它存好，萬一硬碟不小心壞了怎麼辦？</p><p>於是有了RAID卡，RAID中文是容錯式硬碟陣列，RAID卡是一個硬體設備，可以理解為他能將多個硬碟組合在一起，利用虛擬儲存技術，形成一個硬碟陣列，用來提升儲存空間和製造冗余。</p><p>分散式儲存很多idea就是從Raid來的，只是Raid是提升機櫃與機櫃之間的可靠性，而一般來說的分散式儲存是透過網路串連不同的儲存裝置，更加的靈活。</p><p>常見的RAID層級有RAID 0、RAID 1、RAID 5、RAID 6，本篇只介紹上述幾個基礎的RAID架構，架構圖都是來源於維基百科</p><span id="more"></span><h3 id="raid-0">RAID 0</h3><p>下圖我們可以看到兩個大圓柱，其中一個大圓柱，例如Disk0，就是一塊硬碟，一個小圓柱，例如A1，就是硬碟中的一個Block，我們可以把多個Disk串連，從上層系統來看就是一塊超大硬碟。</p><p><img src="/images/vsan/raid0.png" alt=""></p><p>對於RAID 0，資料寫入的方式會把資料分割然後同時寫入A1、A2同，寫完換A3、A4同時寫，所以當一塊硬碟壞了，全部都壞了，所以RAID 0最簡單，最快，但是也最不安全，因為他不會做任何備份</p><h3 id="raid-1">RAID 1</h3><p>RAID 1 和RAID 0類似，但是寫入會一次寫入兩份，一段資料過來，先寫兩份到各自左右兩邊的A1，A1寫完再寫A2，所以RAID1的資料寫入性能是RAID 0的一半，不過只要一個硬碟活著資料都還在。RAID 1可以並聯更多硬碟以增加可靠性，只是相應的寫入效能會更慢</p><p><img src="/images/vsan/raid1.png" alt=""></p><h3 id="raid-5">RAID 5</h3><p>RAID 0速度快但不可靠，RAID 1可靠但是硬碟利用率和效能差，所以RAID 1往後都在找一種儲存效能、可靠性和成本兼顧的方式，直到RAID 5才漸漸被市場所接受</p><p><img src="/images/vsan/raid5.png" alt=""></p><p>如上圖所示，RAID 5至少需要三塊硬碟，上圖是四塊硬碟的架構，那RAID5怎麼存資料呢？從第一排開始，資料來了，一樣先存進去A1、A2、A3，然後我們看到了A_p，他是A1、A2、A3的奇偶校驗資料，這樣當一塊硬碟掛了，可以透過奇偶校驗復原資料。</p><p>我們假設A1, A2, A3上的資料分別為1, 3, 5，透過奇偶校驗，1 XOR 3 XOR 5 = 7，A_p設置為7</p><p>如果A2不小心壞了，要復原資料，只需要把剩餘的都做XOR計算就能復原資料，1 XOR 5 XOR 7 = 3</p><p>和RAID 0相比，寫入速度較慢，讀取速度差不多，可靠性好很多。</p><p>和RAID 1相比，需要更多硬碟才能保證可靠度，但是硬碟的利用率高很多，寫入速度也較快。</p><h3 id="raid-6">RAID 6</h3><p>RAID 6和RAID 5非常相似，唯一的差別就是需要比RAID 5多一塊硬碟存放第二個奇偶校驗資料，如下圖所示</p><p><img src="/images/vsan/raid6.png" alt=""></p><p>兩個的奇偶校驗演算法不同，所以RAID6至少需要四塊硬碟，可以容許兩塊硬碟損壞。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的儲存形式? Block、File、Object Storage</title>
      <link href="/2022/04/27/vsan/storage_overview/"/>
      <url>/2022/04/27/vsan/storage_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚和安迪説，我大概是明白資料中心的組成了，你能不能再多說說vSAN是怎麼儲存資料呢？他是如何能把我的重要檔案自動備份又能同時取用呢？</p><p>安迪說，當然沒問題！儲存是一個很大的領域，我們只能先從最基本的基礎開始，我會先從三個資料儲存系統 - 區塊儲存系統、檔案儲存系統和物件儲存系統說起，這裡說的系統都是軟體層面上的邏輯，不會深入探討到硬碟。</p><h2 id="block-storage(區塊儲存系統)">Block storage(區塊儲存系統)</h2><span id="more"></span><blockquote><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p></blockquote><p>資料在電腦裡是以1和0儲存在某個&quot;介質&quot;上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，也有用光的CD，而Block storage簡單來說就是我們能看到的一塊塊的硬碟和儲存裝置，我們把儲存裝置與我們的電腦連接，我們的電腦透過Block storage的API對裡面的資料進行增刪改查。</p><p>接下來，我們有了作業系統，作業系統他方便了我們把資料存進去Block storage裝置，可以說，作業系統是上層應用與Block storage裝置溝通的橋樑，那麼回答一個問題，作業系統是如何與硬碟打交道呢？</p><p>首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？</p><p>例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也就是說多台主機能共享一個儲存設備，不過一般不會這麼用，因為Block storage的資料隔離沒有做得這麼好，若是同時寫入資料容易被混淆。</p><h3 id="block">Block</h3><p>那麼block的由來是什麼呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，常見為4096 bytes，這樣的設定的用意是提升資料讀寫的速度，如果一個個byte寫，一來一往速度非常慢。</p><p>對於HDD來說，連續讀寫可以大幅提升I/O速度，然而我們的資料會需要經常性的寫入和刪除，例如我們寫了十筆連續的Block，過一段時間，想把第五個Block資料給刪除，這樣中間就會有空餘的浪費，這樣該怎麼辦呢？</p><p>如果我們時常要求連續讀寫，會造成巨大的資源浪費，所以上層的作業系統會利用Linked-List資料結構把碎片化的Block記錄下來，把整段資料拼湊出來</p><p>一個block對應一個或多個硬體的扇區(sector)，常見的一個sector大小為512 bytes，所以block是給作業系統看的邏輯地址，sector是Block storage上的實體地址。Block大小可以透過作業系統設定，查詢藉由指令<code>stat /boot/ |grep &quot;IO Block&quot;</code> 查詢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat /boot/ |grep &quot;IO Block&quot;</span></span><br><span class="line">Size: 4096          Blocks: 8          IO Block: 4096   directory</span><br></pre></td></tr></table></figure><h3 id="sector(扇區)">Sector(扇區)</h3><p>sector是Block storage上的實體地址，他也是把多個bytes分組成一個sector，我們拿機械式硬碟HDD舉例，HDD有個針頭會去掃描磁碟，掃描的部分就是一個個扇區，如下圖所示</p><p><img src="/images/vsan/magnectic_disk.png" alt=""></p><p>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的&quot;扇區&quot;就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點</p><h3 id="優點">優點</h3><p>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><p><strong>高性能:</strong><br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作公司的database server或數據中心</p></li><li><p><strong>易於修改:</strong><br>如果想改變block裡的一個小部分資料，直接改那個block就可以，如果是檔案系統或object system，需要整個檔案或object都改</p></li><li><p><strong>擴充容易</strong><br>擴充非常簡單，一個LUN ID就可以接上系統了，適合用在SAN(儲存區域網路)裡</p></li></ul><h3 id="缺點">缺點</h3><ul><li><p><strong>不能同時讀寫</strong><br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</p></li><li><p><strong>Metadata</strong><br>Block storage沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</p></li></ul><h2 id="file-storage(檔案系統)">File storage(檔案系統)</h2><blockquote><p>有了File storage，就能方便我們寫程式去操作資料！</p></blockquote><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我怎麼知道我的資料的Block存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好，如果是分散存，需要一個Linked-List資料結構去紀錄。</p><p>任何資訊界的難題只需要加一層就可以解決，如果不行，那就兩層，所以我們就加個一層吧！為了讓使用者能夠輕鬆的操作儲存資料，作業系統在Block storage上面加了一層File system。</p><p>我們平常用的Windows為了讓使用者方便存取資料，就是使用File system，這大家應該很熟悉，用滑鼠鍵盤敲一敲點一點就可以對檔案進行存取，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，檔案的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的地方就叫做inode。</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat demo.txt</span></span><br><span class="line">File: ‘demo.txt’</span><br><span class="line">Size: 12            Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770d    Inode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存資料，一個存inode，並且指定inode分區的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><h3 id="作業系統是如何讀取檔案資料？">作業系統是如何讀取檔案資料？</h3><p>首先，不是透過檔案名字，檔案名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，例如上面的<code>demo.txt</code>就是238749826，根據使用者點開的文件找到inode號碼。</p><p>第二，根據inode號碼去資料分區根據inode找到對應的data。</p><p>最後，根據indoe的data，找到檔案裡的資料存在哪個block。</p><h3 id="優點-1">優點</h3><p>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><p><strong>方便共享</strong><br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</p></li><li><p><strong>安全</strong><br>如上述所示，Linux有三種權限控制 - 自己、組和其他</p></li><li><p><strong>成本低</strong><br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</p></li></ul><h3 id="缺點-1">缺點</h3><ul><li><p><strong>資料讀寫慢</strong><br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</p></li><li><p><strong>難以遷移</strong><br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</p></li><li><p><strong>權限控制</strong><br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</p></li></ul><h3 id="object-storage(物件儲存)">Object storage(物件儲存)</h3><blockquote><p>Object Storage - 雲端系統上最流行的儲存方式</p></blockquote><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合，所以Object storage沒有inode這種方式變得更容易索引和訪問。</p><p>Object storage的Metadata就像是File system的inode，用作索引對應的data位置，Object storage可以隨意定義自己的metadata資料結構，幫助快速檢索目標object，甚至是分散在不同主機的data。</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務。</p><p>從high level講，也就是使用方式講，Object storage主要是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用。這些Object實際上可以是任何類型的資料：PDF、影片、音檔、文本、網站資料或任何其他檔案類型。</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要資料分散且「容易」伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個「資料夾」加大了空間。</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的「可靠性」，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如RAID-5這種空間使用率只要150%，但是保護力也有1。</p><h3 id="優點-2">優點</h3><ul><li><p><strong>方便擴增</strong><br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</p></li><li><p><strong>成本低</strong><br>公有雲端上的Object storage都特別便宜，例如Amazon S3</p></li><li><p><strong>API 簡單</strong><br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</p></li></ul><h3 id="缺點-2">缺點</h3><ul><li><p><strong>不能修改</strong><br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</p></li><li><p><strong>無法和database整合</strong><br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</p></li><li><p><strong>無法與一般作業系統整合</strong><br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]虛擬機？我摸的到嗎？</title>
      <link href="/2022/04/12/vsan/vm_overview/"/>
      <url>/2022/04/12/vsan/vm_overview/</url>
      
        <content type="html"><![CDATA[<p>我的電腦是Windows 10系統，然而有一天，我想懷舊一下玩一個只能在Windows XP的遊戲，該怎麼辦呢？</p><p>抑或是公司有50位員工，所以只好每人派發一台電腦，不可能每台電腦都能把硬碟和計算資源無時無刻用滿，但是我想節省成本，該怎麼辦呢？</p><p>虛擬機就是一個實體電腦的數位版本，讓你可以在作業系統上執行一個不同且獨立的作業系統，這麼一來，就能在Windows 10上運行Windows XP，公司也能透過買一台資源豐富的伺服器，在上面透過虛擬機的方式達到資源最大利用率</p><p>個人用的虛擬機軟體最有名的當數付費的VMware Workstation和開源版本的Virtual box</p><span id="more"></span><p>公司用的虛擬機軟體(hypervisor)則多了，有付費的VMware vSphere、Microsoft的HyperV等等和開源的KVM、Xen等等</p><p>如今雲端技術非常流行，三大公有雲廠商Amazon AWS、Microsoft Azure以及Google GCP，他們三個其實就是建置了大量的數據中心，把裡面的伺服器裝上虛擬機軟體，讓外部的開發人員或公司虛擬出「多個實體電腦」，按需使用，像是家家戶戶的水電一樣，不用維護高昂的IT成本。</p><p>上述是公有雲的範疇，若公司有資料隱私的要求，例如銀行、醫院、公家機關等等，也可以自己建制數據中心，把資料和計算留在本地，這時需要一套虛擬機管理軟體，也能透過VMware vSphere、Microsoft的HyperV等等的建立自己的數據中心。</p><h2 id="虛擬機原理">虛擬機原理</h2><p><img src="/images/vsan/vm_structure.png" alt=""></p><p>虛擬機架構示意圖,如上所示，VMM(Virtual Machine Monitor)是一個軟體，運行在Ring0，也就是CPU上的特權級別，負責給上面的Guest OS提供虛擬化的環境(CPU, Memory和 I/O虛擬化)，VMM會根據Guest OS提供的指令，做出相應的資源分配措施。</p><h3 id="cpu虛擬化">CPU虛擬化</h3><p>目的是利用硬件輔助虛擬化技術(以前是用Binary Translator)攔截敏感指令，會對整個系統造成影響的指令，有了硬件輔助虛擬化技術，實體CPU會自動攔截敏感指令給VMM。</p><h3 id="記憶體虛擬化">記憶體虛擬化</h3><p>主機使用段頁機制，虛擬機有兩層轉換，Guest Virtual Memory -&gt; Guest Physical Memory -&gt; Machine memory，當然，這部分也有硬體虛擬化輔助技術支持。</p><p><img src="/images/vsan/vm_memory_mapping.png" alt=""></p><h3 id="**i/o虛擬化**"><strong>I/O虛擬化</strong></h3><p>虛擬各種外接設備(純軟體虛擬化、硬體輔助虛擬化)硬體輔助虛擬化能讓虛擬機直接使用硬體設備，但是具有獨佔性，例如滑鼠和鍵盤就是一種I/O設備，當一台實體電腦只接上一個鍵盤，那他只能在一台虛擬機或是實體機器上進行輸入。</p><h3 id="**網路虛擬化**"><strong>網路虛擬化</strong></h3><p>讓虛擬機同時使用同個網卡，虛擬交換機可以製造虛擬網絡環境，讓一台實體機器上的所有虛擬機共享同個區域網路。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN簡介-VMware產品中的儲存利器</title>
      <link href="/2022/03/25/vsan/vsan_overview/"/>
      <url>/2022/03/25/vsan/vsan_overview/</url>
      
        <content type="html"><![CDATA[<p>VMware擁有自己一套的軟體定義資料中心SDDC解決方案，以vSphere作為中心的Hypervisor提供虛擬儲存和網路服務，其中儲存的部分有以下幾種</p><ul><li>Local - VMFS</li><li>NAS - NFS</li><li>iSCSI</li><li>VMware Virtual Volume(VVOL) - virtualize SAN and NAS</li><li>vSAN</li></ul><p>vSAN全名是Virtual SAN，顧名思義，他不是類似NAS這種的遠端檔案系統，這裡我們先介紹SAN是什麼</p><span id="more"></span><h3 id="san">SAN</h3><p>一般來說，我們會把主機上的資料存在主機上的硬碟裡，可能主機A只用了20%的容量，主機B用了50%的容量，主機A和主機B都浪費了很多儲存空間，而現在突然有一個主機C，想要用200%的容量，卻捉襟見肘，這該怎麼辦呢？</p><p>於是乎有了SAN這類的儲存架構，SAN在遠端建立了一個儲存池，讓各個主機共享，儲存池裡面各個主機透過網路或是光纖連接，是專門用作儲存的網絡區域。SAN和前面的NAS最大的差別是SAN的檔案系統是保留在主機端的，而NAS的檔案系統是在遠端的，所以兩者在網路上的傳遞的協議會不同。</p><h3 id="vsan">vSAN</h3><p>vSAN會把所有主機上的硬碟整合成一個儲存池，如下所示</p><p><img src="/images/vsan/vsan_overall_structure.png" alt=""></p><p>我們可以看到，每個vSAN Host，也就是物理機，裡面有若干塊硬碟，只要主機被加入vSAN Cluster，他裡面的硬碟資源就會貢獻給vSAN，所以在vSAN上的主機要存取資料，可能是來自主機本身的，也有可能是其他主機的。</p><p>由於vSAN是軟體定義儲存系統，我們能想到的儲存備份、冗余、延伸集群等等的都可以透過vSAN軟體實現而不需要動到硬體，甚至RAID卡也不用。其關鍵技術就是Storage Policy，透過對主機上的虛擬機設定Storage Policy，我們可以指定該虛擬機要做幾份備份，可以容忍多少台主機故障等等的，此外，由於他是軟體定義儲存，對於主機的擴充非常方便，只要在vCenter(主機叢集的控制面板)「新增主機」，即可為這個叢集增加儲存容量。</p><p>vSAN是採用物件(Object)作為儲存系統，物件儲存系統簡單來說就是沒有資料夾的檔案系統，所以查詢非常快且容易共享及備份，vSAN作為服務vSphere上虛擬機的儲存系統，上面的虛擬機就是一個個物件。除此之外，由於深度和vSphere整合，vSAN同時也支持vSphere HA(High Availability)、vSphere DRS(Distributed Resource Scheduler)和vSphere vMotion(虛擬機不掉電遷移)</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]刻意練習</title>
      <link href="/2022/02/03/proative_practice_book/"/>
      <url>/2022/02/03/proative_practice_book/</url>
      
        <content type="html"><![CDATA[<h3 id="刻意練習">刻意練習</h3><p><img src="/images/proactive_practice.jpeg" alt=""><br>我們或許有聽過一萬小時定律: 任何人做一件事，只要經過一萬小時的錘煉，都能從普通人變為某一領域的頂級人才 - 格拉德威爾《異類》<br>1萬小時的錘煉是任何人從平凡變成超凡的必要條件，雖然是必要條件，但是也不是唯一條件，更不一定需要一萬小時，而是足夠多的練習<br>讀了這本書《刻意練習》，除了練習之外，我們更應該考慮外部環境跟內部誘因，並且兩者是相輔相成的，讓我更了解怎麼有效率的「學習」，下面是我讀完後的總結，我會從外部和內部視角提出實操性強的步驟:</p><h3 id="開頭">開頭</h3><ul><li><strong>要成為一個領域的佼佼者，靠的不是天賦，而是刻意並且足夠多的練習</strong><br>沒有一個人是靠天賦成為頂尖人才的，即便是莫札特也是如此，頂尖人才之所以能持續練主要習並不是因為興趣，而是持續練習</li><li><strong>建立目標</strong> - 你能「做」到什麼，而不是你能「學」到什麼</li><li><strong>刻意練習就是</strong> - 做跳脫舒適圈的事、獲得反饋、改進並回到第一步</li></ul><span id="more"></span><h3 id="建立良好的外部環境">建立良好的外部環境</h3><ol><li><strong>想要練習的目標最好是高度發展的領域</strong><br>高度發展的領域除了已經有成熟的訓練方法之外，能建立內部誘因，向強者看齊</li><li><strong>訂立明確的目標</strong></li><li><strong>找個好老師</strong><br>好的老師能給你正確的訓練方法和回饋，如果因為現實問題沒有老師，可以自己找模仿對象加以模仿，以培養「心智表徵」<ul><li>心智表徵<br>心智表徵就是做事時心裡能有一個大致上思考的方向，在未知情況下能夠做出下一步的判斷力，我們能夠透過「老師」或「模仿對象」學習對方的心智表徵</li></ul></li><li><strong>製造回饋機制</strong><br>最好能有個量化的回饋機制，回饋機制能防止自己在學習的道路上偏離，回到正確的方向</li></ol><h3 id="建立內部誘因">建立內部誘因</h3><ol><li><strong>產生興趣</strong><br>產生興趣受外部環境影響較深，例如親近的人的讚美和鼓勵，在這個階段，練習感覺像是遊戲</li><li><strong>將練習融入工作中</strong><br>現代人時間都不太夠，若是能在工作中同時對專業進行練習將節省很多時間</li><li><strong>變得認真</strong><br>到了這個階段，練習不再等於遊戲，而是功課，要靠自我意志力和動機堅持下去，還有一部分的外部讚美和鼓勵，這時應該有了基本的「心智表徵」</li><li><strong>全心投入</strong><br>在這個階段，動機完全來自於自己本身，外部頂多只能進行支持，這一步是最枯燥無聊的，也是最難的，這裡我列出了幾個方法讓自己能夠保持全心投入<ul><li>找出可能受干擾的因素，並盡量減低影響</li><li>不要假設某些事情是「天生的」</li><li>製造出幾個「小成功」，持續讓自己有正反饋</li><li>社會動機 - 得到他人的認可和欽佩</li><li>製造好的外部環境 - 讓自己身邊圍繞著你努力時會給予你鼓勵、支持和挑戰的人</li><li>相信自己能成功</li></ul></li></ol><p><strong>上述步驟必須「有意識」的行動且全神貫注</strong></p><h3 id="運用刻意練習的教學方法">運用刻意練習的教學方法</h3><ol><li><strong>定目標 - 決定學生具備哪些能力，遠比決定應該具備哪些知識有效</strong><br>學生在培養能力的同時，自然會獲得知識</li><li><strong>清單化一系列具體的學習目標</strong><br>將課程分解為一系列小的好做的步驟</li><li><strong>鼓勵學生踏出舒適圈</strong></li><li><strong>即時點出學生的錯誤，給予回饋，並指導如何改正</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 刻意練習 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]雲端? 雲端就是資料中心嗎？</title>
      <link href="/2022/01/20/vsan/cloud_storage_overview/"/>
      <url>/2022/01/20/vsan/cloud_storage_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚一聽到資料中心，突然頭暈目眩，在他的腦海裡，資料中心就是在一個冰冷冷的屋子裡放滿了各種機器</p><p><img src="/images/vsan/datacenter.png" alt=""></p><p>各種機器就是硬體設備，我們已知可以透過虛擬機的方式，把計算軟化，但是資料中心還有「儲存」需求，要怎麼把他也軟化呢？</p><p>軟體定義資料中心(Software-Defined Data Center, SDDC) 顧名思義，就是利用軟體，把資料中心裡的計算、儲存、網路資源「抽象化」和「虛擬化」，當資源都被虛擬化後，IT管理團隊變得更加靈活了。IT人員可以針對使用者需求，提供更細的資源粒度，例如一台CPU 1G Hz，20GB容量的電腦，並且這個電腦還能隨時備份，不但提高了服務和應用的「可用性」及「彈性」，同時也降低了對運維的「複雜度」和「預算」，並簡化服務上線的工作流程和應用的推出時間，接下來的重點將會圍繞在「儲存資源」的部分，也就是VMware vSAN產品相關的技術結構。</p><p>一般的常見解決方案大致分為兩類 - 在雲端的公有雲和在地端的私有雲</p><span id="more"></span><h3 id="公有雲">公有雲</h3><p>常見的如Amazon、Azure、Google Cloud，阿里雲等等，公有雲的好處是資料中心的「硬體設備」可以透過專門的公有雲提供商維護，這樣使用者，也就是工程師們可以專心的開發軟體或應用，不用管資料中心遇到水災、斷電或是地震等自然災害。</p><p>更重要的是，對於新創公司來說，服務的使用量震盪是劇烈的，若事先買了硬體設備，可能會造成大量的浪費，公有雲的按需使用能滿足小型創業公司的需求。</p><h3 id="私有雲">私有雲</h3><p>常見的如VMware vSAN、Nutanix ADSF、HPE StoreVirtual VSA等等，私有雲的好處是資料幾乎100%安全且存取的速度快，不過硬體的選配、維護等等需要抽出部分公司裡的人力去維護。一般來說，是銀行、政府等等對資料安全性比較敏感的單位才會使用私有雲服務</p><p>其中又能細分「融合式解決方案」和「純軟體式解決方案」</p><h3 id="融合式解決方案">融合式解決方案</h3><p>買硬體設備的同時，軟體也裝上去了，例如Dell VxRail、HPE SimpliVity，這樣省去了更多安裝和硬體選配的麻煩，直接購買，直接使用。</p><h3 id="純軟體式解決方案">純軟體式解決方案</h3><p>此方案對於硬體的配置更有彈性，只要符合「硬體相容性清單」，就能在自己的硬體設備搭建軟體定義儲存的伺服器</p><h3 id="混合雲">混合雲</h3><p>混合雲的意思就是一部分的應用在公有雲，一部份在私有雲，但是操控的介面是同一個。例如VMware有和各大公有雲合作 - Amazon, Google, Microsoft, 阿里巴巴。在他們的硬體上安裝VMware的產品，這樣使用者就能在地端和雲端上自由遷移虛擬機和儲存空間。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]雲端，什麼是雲端？</title>
      <link href="/2021/12/05/vsan/vsan_cloud_overview/"/>
      <url>/2021/12/05/vsan/vsan_cloud_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚是一位老師，有一天小羚費盡了功夫，寫好了本學期的教案，她想要備份在安全的地方。<br>小羚想著想著，要存哪好呢？存行動硬碟不太安全，萬一丟了怎麼辦？存自己的電腦，也沒安全感，萬一中毒了怎麼辦？<br>她的男友安迪跟他說，可以買三個行動硬碟，都分別存在裡面呀。<br>小羚回說，這樣子好麻煩，如果我想更新教案裡的某段內容，這樣還要一個個打開來更新。<br>安迪又說，可以存雲端呀！存雲端既不用擔心硬碟損壞，也不用擔心突然有靈感的時候沒辦法隨時修改。</p><p>小羚問安迪，有什麼常見的雲端儲存服務嗎？</p><p>有的，儲存是一個很大的領域，服務的對象也千差萬別，安迪會用兩篇的篇幅介紹，首先會先介紹什麼是「雲」，再來介紹雲端儲存系統</p><h3 id="那麼，什麼是「雲」呢？">那麼，什麼是「雲」呢？</h3><span id="more"></span><p>「雲」就是一個大池子，這個池子裡面裝著豐沛的電腦「計算」資源和「儲存」資源，然後透過「網路」的方式，拿到遠端池子裡幫我們運算好或儲存的結果。</p><p>假如我們只想做個簡單的計算，不需要買一台電腦另外算，只需要短暫的租用一下CPU即可，假如我們只想暫時性存個文件，不需要額外買行動硬碟浪費空間，只需要短暫的租用一下硬碟即可。</p><p>雲主要可以分為以下三種服務</p><ol><li>SaaS</li><li>PaaS</li><li>Iaas</li></ol><p>雲端儲存給使用者使用的「介面」可以區分為以上三個，下面依依來介紹</p><h3 id="saas">SaaS</h3><p>SaaS(Software as a Service)是雲端中最外層的服務，直接讓使用者能使用的服務，讓使用者能打開瀏覽器透過UI操作，例如Dropbox、Google Doc等等。所以，這也是小羚適合使用的服務。雖然找到了最適合的服務，但是秉持著刨根問底的精神，小羚還是很好奇我在雲端上存的檔案是怎麼儲存和備份的呢？那讓我們接著繼續看下去。</p><h3 id="paas">PaaS</h3><p>PaaS(Platform as a Service)，通常Saas下面這一層就是PaaS，他的目的是給最外層的服務提供一個Platform，讓網路應用可以部署在上面，例如Amazon S3等等，使用者一般為工程師，工程師把寫好的服務部署在上面，他不需要管分散式架構、備份等問題，其中，最有名的當數Amazon S3了，這裡容我簡單介紹一下</p><p><strong>Amazon S3</strong></p><p>Amazon S3(Simple Storage Service)是亞馬遜公司提供的一個Object Storage儲存服務，可以透過Restful API、SOAP等方式，把你的把你的檔案儲存在網路伺服器上，目前每個月收費3元台幣/GB，與iCloud比似乎還是有點貴，iCloud月付30元就有50GB了</p><p>Amazon S3有個關鍵的概念，叫做”Bucket”，Bucket有點像是你的名稱唯一個人資料夾，裡面只能存放檔案，不能再新建資料夾，存取檔案只能透過你的資料夾裡面的檔案名字去讀取或是更新，我們通常說的Object儲存系統，就是把檔案存在一個沒有資料夾的大平面。</p><h3 id="iaas">IaaS</h3><p>IaaS(Infrastructure as a Service), PaaS下面那一層就是IaaS。我們知道，一台電腦或伺服器，它是由「計算/CPU」和「儲存/Disk」構成，缺一不可，IaaS的目的是讓工程師可以直接使用這些硬體設備，透過虛擬化的方式，切割成獨立的計算資源，透過iSCSI等方式，切割獨立的儲存資源，例如vSphere, vSAN等等，而這也是資料中心提供的Service方式，下一篇，我們將會介紹vSAN的核心思想以及要解決的問題 - 軟體定義資料中心。</p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]人性的弱點</title>
      <link href="/2021/11/30/influence_people_book/"/>
      <url>/2021/11/30/influence_people_book/</url>
      
        <content type="html"><![CDATA[<h3 id="人性的弱點">人性的弱點</h3><p><img src="/images/influence_people.jpeg" alt=""><br>人性的弱點，這本書的英文原名是&quot;How to Win Friends and Influence People&quot;，如何贏得朋友並影響他人，和&quot;人性的優點&quot;同個作者 - 戴爾・卡內基，人性的優點書評我寫在<a href="/2021/11/11/stop_worrying_book">這裡</a>。</p><span id="more"></span><p>全書通過栩栩如生的故事和通俗易懂的原則，從人性本質的角度，挖掘出潛藏在人心裡影響他人的方法和原則，只有認識自己並理解他改進自己的弱點才會有所進步，本書的一大優點是他的架構非常的有邏輯及有條理，做筆記也非常的方便，我把各個章節也用一行行條理的方式羅列出來，方便內化進去自己的原則</p><ol><li>不要批評他人，不要抱怨、責怪他人<ul><li>對他人的批評，都是關係惡化的導火線</li><li>如果我是他，我也會做同樣的事，他會做這樣的事，一定有他的理由</li></ul></li><li>與人相處的秘訣<ul><li>讓人心甘情願的做某件事情的唯一方法 - 給他需要的東西</li><li>我們做任何事情只有兩個動機 - 性衝動(來自佛洛依德)和渴望成為偉人(獲得別人的重視)</li></ul></li><li>如何左右逢源<ul><li>魚餌的選擇，是釣魚成功的最大關鍵</li><li>談論對方需要的，並且提出建議，是世界上唯一能影響他人的方法(站在對方立場想)</li></ul></li></ol><h4 id="使人喜歡的六個方法">使人喜歡的六個方法</h4><ol><li>如果這樣做，將到處受到歡迎<ul><li>時刻關心周圍的人，發自內心的關心他們</li><li>發自內心的對他人及他從事的事情感興趣</li><li>一個人在生活中不懂的關心他人，對他人不感興趣的人，他的生活必將受到嚴重阻礙和困難</li></ul></li><li>如何給別人留下好印象<ul><li>保持微笑，大部分人的意念決定了他們是否快樂</li></ul></li><li>想要避免發生麻煩，就請這樣做<ul><li>記住他人的名字，所有人對自己的名字，比對任何人有興趣</li><li>example，鋼鐵大王-安德魯卡內基推銷投資者投資建廠，承諾如果投資，就把投資者的名字作為工廠名字</li></ul></li><li>如何養成贏的他人好感的優美談吐習慣<ul><li>善於並專心傾聽對方、在別人說話的時候鼓勵他們</li></ul></li><li>怎麼讓他人對你的話題感興趣<ul><li>接見前，預備好他們感興趣的話題，和對方講他們感興趣的事</li></ul></li><li>如何使人很快地喜歡你<ul><li>讚美一個小細節<ul><li>真希望我也能夠擁有你這樣漂亮的頭髮</li><li>你回答問題的方式很漂亮，清晰又準確</li></ul></li><li>要讓他人覺得他自己很重要，並且還要很真誠</li></ul></li></ol><h4 id="在生活中贏得他人同意的十二條規則">在生活中贏得他人同意的十二條規則</h4><ol><li>你不可能在爭辯中獲勝<ul><li>永遠避免與他人發生正面衝突，發生爭執的時候，唯一獲得最大的利益方式，就是避免與他人爭執</li><li>要讓自己的客戶、朋友、妻子，在細小的問題的爭論上經常勝過我們</li></ul></li><li>怎麼減少樹敵<ul><li>不要直接指出對方的錯誤，我們樂意將我們認爲“正確”的事進行到底</li><li>尊重他人的意見，永遠也不要指責對方“你錯了”</li></ul></li><li>犯了錯誤就要承認<ul><li>如果犯了錯，就要迅速且認真地承認錯誤</li></ul></li><li>從友善待人開始<ul><li>以友好善良的方式與人交往</li></ul></li><li>蘇格拉底讓人說”是”的秘密<ul><li>讓談話中減少對方說不的機會，多說是</li></ul></li><li>盡量多給對方說話的機會</li><li>如何讓別人與你合作<ul><li>自己提出建議，讓別人得出結論</li></ul></li><li>怎麼創造奇蹟的公式<ul><li>當對方不承認自己的錯誤時，嘗試著了解，原諒對方</li><li>不要用命令的語氣</li><li>在處理問題時，真誠地以他人的立場看待問題</li></ul></li><li>了解每一個人所需要的<ul><li>停止爭論的神奇句子 - 我不會責怪你所做的一切，如果換作是我，我也會做出同樣的決定</li><li>同情對方的意念和慾望</li></ul></li><li>激起對方高尚的動機<ul><li>想改變一個人，就需要把他高尚的動機激發出來</li></ul></li><li>把你的想法戲劇化<ul><li>類似二次吸引？讓對方看到你的大改變</li></ul></li><li>當你無計可施時，不妨試試這個<ul><li>假如我們要完成一件事情，要鼓勵競爭</li><li>好勝的意志與勇於挑戰的心理，是效果最好的激勵</li><li>所以要提出一項好的挑戰</li></ul></li></ol><h4 id="讓人同意你的九種方法">讓人同意你的九種方法</h4><ol><li>假如你必須批評，這就是開始的方法<ul><li>先褒後貶</li><li>發自內心的讚賞他人的成就作為開始</li></ul></li><li>怎麼批評才不招致抱怨<ul><li>避免正面批評，這樣毀損傷對方的自尊心</li></ul></li><li>先說出你的錯誤<ul><li>先談論自己的錯誤，再談論別人的錯誤</li></ul></li><li>沒有人喜歡被指使<ul><li>不要做出直接或祈使句的命令</li></ul></li><li>顧全對方的面子<ul><li>表示對別人的做法和想法感到諒解</li><li>每個領導者都要懂的顧全別人的面子</li></ul></li><li>如何鼓勵別人成功<ul><li>哪怕極小的進步都要給予真誠的讚美</li></ul></li><li>給他人一個美好的名聲<ul><li>想讓一個人的缺點有所改善，就要讓他知道，他已經具備一些優點了</li></ul></li><li>讓錯誤看起來容易改正<ul><li>鼓勵可以讓你更容易改正錯誤，也讓別人更容易達到你的期望</li></ul></li><li>讓人們樂意去做你所要做的事<ul><li>賦予特殊榮譽，例如在台灣，很多小公司的工程師都掛名資深工程師</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 人性的弱點 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]人性的優點</title>
      <link href="/2021/11/11/stop_worrying_book/"/>
      <url>/2021/11/11/stop_worrying_book/</url>
      
        <content type="html"><![CDATA[<h3 id="人性的優點">人性的優點</h3><p><img src="/images/notworry.jpg" alt=""><br>人性的優點，這本書的英文原名是&quot;How to stop worrying &amp; start living&quot;，老實說，我也不知道為何中文會翻譯成&quot;人性的優點&quot;，不過總之，他是一本在講如何消除憂慮的書，和&quot;人性的弱點&quot;同個作者 - 戴爾・卡內基。</p><span id="more"></span><p>生活的快樂與否，完全是由思想造成的。憂慮會使人一文不值，挫折是整個事情的一部分 - 是你要爬到最高峰所必須經過的有益的訓練，不要讓憂慮阻礙你的步伐，要善於利用思想的力量，發現人生的美好，通過改變心情自救，事情會在你快樂中變得簡單。對於消除憂慮，本書有五大步驟，從憂慮的本質，然後進而剖析他，消除他，最後是維持快樂與幸福的一些準則。<br>當然，我也是個平凡人，一定會有經常面對憂慮的時候，本書的一大優點是他的架構非常的有邏輯及有條理，做筆記也非常的方便，我把各個章節也用一行行條理的方式羅列出來，方便內化進去自己的原則</p><h4 id="憂慮的真相">憂慮的真相</h4><ol><li>讓自己生活在獨立的隔艙裡<ol><li>愚蠢的人才會為昨天流淚，為明天擔憂</li><li>把全部的心智投入在今天的工作中去</li></ol></li><li>消除憂慮的萬能公式<ol><li>想到最壞的可能性 - 除死無大事</li><li>然後去接受最壞的可能性</li></ol></li><li>過多的憂慮會危及生命<ol><li>要對自己充滿信心</li><li>欣賞美妙的音樂</li><li>樂觀態度看待生活</li></ol></li></ol><h4 id="剖析憂慮的方法">剖析憂慮的方法</h4><ol><li>怎麼分析憂慮並從中把他解脫出來<ol><li>查清憂慮真相-困惑是導致憂慮的主要原因，列出正反兩方因素，能夠找出事實的真相</li><li>列出該怎麼做的Plan A B C D…選一個可以接受的，然後不要猶豫地實施決定</li></ol></li><li>怎麼消除工作中的煩惱<ol><li>回答四個問題<ol><li>問題出在哪裡</li><li>為什麼會有這樣的問題出現</li><li>該怎麼解決這個問題</li><li>能否提出解決問題的建議</li></ol></li></ol></li></ol><h4 id="如何消除憂慮">如何消除憂慮</h4><ol><li>把你的憂慮從心中驅逐出去<ol><li>做事，讓自己忙得沒空憂慮</li></ol></li><li>不因瑣事而煩惱<ol><li>把看法和重點轉移一下，不要當完美主義者</li></ol></li><li>戰勝憂慮的幾個法則<ol><li>不要過度擔心，算好機率，發現他們都是小機率事件</li></ol></li><li>勇敢面對事實<ol><li>不愉快的事情發生了，他們已經如此了</li><li>心甘情願地接受事實，是戰勝之後困難的第一步</li><li>勇於面對那些不可避免的事實</li></ol></li><li>讓憂慮到此為止<ol><li>設定一個底線，和股票投資一樣</li><li>問自己兩個問題<ol><li>我遇到的問題和我有多大的關係？我需要這麼擔憂嗎？</li><li>我如何設定底線？然後把他忘掉</li></ol></li></ol></li><li>不要試著去鋸已經碎掉的木屑<ol><li>我們可以努力改變180秒前發生事情帶來的後果，但我們沒有辦法改變當時的狀況</li></ol></li></ol><h4 id="讓自己平安快樂的七種方式">讓自己平安快樂的七種方式</h4><ol><li>憧憬生活的美好<ol><li>改變對事物的看法，往好的方面想</li><li>只要下定決心就能快樂</li></ol></li><li>不要報復你的敵人<ol><li>報復會損害健康，憤怒不能控制好，會導致高血壓和心臟病</li></ol></li><li>給予，但不求回報</li><li>細數幸福的事</li><li>保持自我本色<ol><li>一個人打算擁有別人的全部優點，那簡直是荒謬</li></ol></li><li>把不利因素轉為有利因素</li><li>忘掉自己，關心他人<ol><li>最無私的人最會享受生活</li><li>多做善事</li><li>多對別人感興趣，多向他人表示關心</li></ol></li></ol><h4 id="如何直面批評帶來的煩惱">如何直面批評帶來的煩惱</h4><ol><li>批評他人是一種自我膨脹的表現<ol><li>對你刻薄的斥責往往能從另一面表現出人們對你的重視</li></ol></li><li>不要讓批評之箭射中你<ol><li>普通人根本不會想到我們</li><li>只不理會不公正的批評</li></ol></li><li>自省，再自省<ol><li>在工作和生活中的缺點積極說&quot;不&quot;</li></ol></li><li>怎麼消除疲勞<ol><li>休息是消除疲勞的首要途徑</li><li>休息放空真的很重要！！！</li></ol></li><li>是什麼讓你疲勞<ol><li>腦力工作者不會因為用腦而疲倦</li><li>用腦的疲倦是因為精神和情緒因素引起的</li></ol></li><li>讓疲憊永遠消失<ol><li>找知心朋友傾訴，是治療煩惱最有效的方法</li><li>讀一些愉悅的文字</li><li>不要過分計較別人的過失</li></ol></li><li>四個良好的工作習慣<ol><li>生活環境井然有序</li><li>處理事情要有重點</li><li>當機立斷，趕快行動</li><li>學會領導、權力下放和監督</li></ol></li><li>怎麼消除煩悶心裡<ol><li>心理上的厭煩比工作中的勞累更容易感到疲倦</li><li>要對工作有熱情</li></ol></li><li>不再為失眠而憂慮<ol><li>安全感是安穩睡覺的第一關鍵</li><li>讓自己身體疲憊</li><li>失眠的時候可以起來做點事</li><li>失眠不會導致死亡，導致死亡的是緊張情緒和精神壓力</li><li>經常鍛鍊身體，使心情放鬆</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 人性的優點 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]解析第二層及第三層的網路封包結構</title>
      <link href="/2021/10/29/eth_and_ip_network/"/>
      <url>/2021/10/29/eth_and_ip_network/</url>
      
        <content type="html"><![CDATA[<p><strong>網路的IP位址讓我們路由到LAN(區域網路)，而MAC位址讓我們找到了目標電腦</strong><br>MAC作用在第二層 - 資料連結層，而IP作用在第三層 - 網路層，關於MAC和IP位址的詳細解說請參考<a href="/2021/09/23/ipbasic-network">這一篇</a></p><p>那麼，讓我們從第二層 - 資料連結層 開始吧！</p><span id="more"></span><h3 id="資料連結層">資料連結層</h3><p>資料連結層透過MAC位址進行溝通，所以他的Header包含了固定長度的來源MAC位址和目的地MAC位址，結構如下所示<br><img src="/images/eth_header.png" alt=""><br>我們可以看到資料連結層的header總共有三項資料，除了MAC位址之外還有<code>type</code>，他是一個2bytes的unsigned short int，具體他所對應的type可以參考<a href="https://en.wikipedia.org/wiki/EtherType#Values">維基百科</a>，比較常見的有</p><ul><li>0x0800 - IPv4</li><li>0x86DD - IPv6</li><li>0x0806 - ARP。我們一直都沒說到IP位址和MAC怎麼做mapping對應，用的就是ARP協議，通知路由器IP和MAC位址的對應關係</li></ul><p>整個header有14個bytes，而這14個bytes後面接的就是網路層的header</p><h3 id="網路層">網路層</h3><p>網路層提供了路由和尋址的功能，幫助封包導向兩端的最佳路徑，並具有一定的擁塞控制和流量控制的功能，和資料連結層一樣，我們來看看網路層header結構<br><img src="/images/ip_header.png" alt=""><br>這裡列出比較重要的</p><ul><li>Total Length：封包總長度</li><li>Identification：識別碼，通常是為了校驗checksum</li><li>Fragmentation: 如果要傳輸大封包，能進行切割標記</li><li>Time To Live(TTL)：通過了幾個路由器，如果為0則傳輸失敗</li><li>Protocol：協定，例如tcp協定、icmp協定等等，這和應用層的http、DNS等是不同的，他們是所屬於這層協定裡，Protocol以一個數字表示，這裡列舉比較常見的<ul><li>1 -&gt; ICMP</li><li>6 -&gt; TCP</li><li>17 -&gt; UDP</li><li>由於不同的Protocol後續的header長度內容也會不同，故需要加以區分</li></ul></li><li>Checksum：用來檢錯用的</li><li>Source IP Address：來源IP地址</li><li>Destination IP Address：目的地IP地址</li></ul><p>其header長度總共有20bytes</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]Socket - 網路程式的大門</title>
      <link href="/2021/10/25/socket_usage_network/"/>
      <url>/2021/10/25/socket_usage_network/</url>
      
        <content type="html"><![CDATA[<p>我們在寫網路相關的程式最底層就是與socket交互，socket是專用於網路通訊的system call。什麼是system call呢？<br>我們知道作業系統有分kernel和user space，從user space要進行I/O操作需要透過system call去呼叫kernel space，kernel space才有權限進行I/O的操作。<br>在Linux中，使用socket宣告一個object會回傳一個file descriptor。在Linux中，一切都是文件，連socket object也不例外，file descriptor在這裡的作用就是指向那個文件的descriptor。</p><span id="more"></span><p>下面簡單介紹本Project會用到的socket基本API的使用，首先開啟socket就是宣告了一個socket的object</p><p><code>sock = Socket(family, type, proto)</code></p><ul><li><p><strong>family</strong><br>family指的是某個通訊協定，例如ipv4, ipv6等等，如果指定ipv4則只對ipv4的通訊協定的封包進行發放，例如AF_PACKET，他能直接從網卡讀和寫上面的數據</p></li><li><p><strong>type</strong><br>type則是封包數據的格式，主要有SOCK_STREAM和SOCK_DGRAM，分別為TCP和UDP為代表，還有更加原始的格式SOCK_RAW，能自行的組裝數據包，由於我們想監聽所有封包，所以會使用SOCK_RAW</p></li><li><p><strong>proto</strong><br>Proto則是protocol的意思，通常預設為0，那麼我們的應用要監聽所有封包，所以設定為0x0003來監聽所有ethernet上的封包</p></li></ul><p>定義好socket file descriptor後，然後下面是socket object常用的API。</p><ul><li><p><strong>bind((addr, port))</strong><br>需監聽和發送的地址和port，地址若為0.0.0.0則代表所有，也能監聽網卡</p></li><li><p><strong>recv(1024)</strong><br>如果有封包進來，則kernel space響應這個函數，讓我們的應用程式可以對封包進行處理，若沒有則會被block在這，函數回傳的是小於等於1024長度的string，看封包大小</p></li><li><p><strong>send(packet)</strong><br>packet就是我們做成的封包，在30天的後半段會教大家怎麼做自己的封包，怎麼算checksum，socket會根據封包裡的mac address和ip address進行路由</p></li></ul><p>除了上述這些API，還有很多很多，有興趣的讀者能再深入研究</p><h4 id="範例">範例</h4><p>最後，我們試著用socket API來獲取封包的來源MAC地址<br>首先，我們需要監聽所有封包，所以<code>family</code>, <code>type</code>和<code>proto</code>分別為<code>AF_PACKET</code>, <code>SOCK_RAW</code>和<code>0x0003</code>，完整來看如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW , socket.ntohs(<span class="number">0x0003</span>))</span><br></pre></td></tr></table></figure><p>接下來，我們需要綁定一個network interface，可以透過指令<code>ifconfig</code>來看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02</span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3496 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1692 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:4623164 (4.6 MB)  TX bytes:93240 (93.2 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:36 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:36 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1800 (1.8 KB)  TX bytes:1800 (1.8 KB)</span><br></pre></td></tr></table></figure><p>在我的環境裡，有<code>eth0</code>這個network interface，所以我決定監聽他</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.bind((<span class="string">&quot;eth0&quot;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>監聽的方式如下，需要一個無限循環去監測，如果沒有新封包則會被block在<code>sock.recvfrom</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    packet, _ = sock.recvfrom(65565)</span><br></pre></td></tr></table></figure><p>一個封包的來源Mac Address會在封包的前六個bytes，我們需要用到python自有的struct library去解析他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_mac_header = packet[:6]</span><br><span class="line">struct.unpack(&#x27;!6s&#x27;, src_mac_header)</span><br></pre></td></tr></table></figure><p>驚嘆號代表的是bytes順序是big endian，6s代表unpack 6個char，也能unpack integer等等的，具體代表的意思可以參考<a href="https://docs.python.org/3/library/struct.html#format-characters">這裡</a><br>所以unpack之後，我們就能取得來源的Mac address，完整的程式碼如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket, struct</span><br><span class="line"></span><br><span class="line">#define ETH_P_ALL    0x0003          /* Every packet (be careful!!!) */</span><br><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW , socket.ntohs(0x0003))</span><br><span class="line">sock.bind((&quot;eth0&quot;,0))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    packet, _ = sock.recvfrom(65565)</span><br><span class="line">    src_mac_header = packet[:6]</span><br><span class="line">    src_mac = struct.unpack(&#x27;!6s&#x27;, src_mac_header)[0]</span><br><span class="line">    mac = map(&#x27;&#123;:02x&#125;&#x27;.format, src_mac)</span><br><span class="line">    print(&#x27;:&#x27;.join(mac))</span><br></pre></td></tr></table></figure><p>實驗方式，可以跑這個程式的電腦發送curl請求，可以看到在我的環境，在eth0的Mac address為<code>02:42:ac:11:00:02</code>，然後我們下指令對自己的電腦產生封包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&gt; curl --interface eth0 127.0.0.1</span><br></pre></td></tr></table></figure><p>在另外一個terminal視窗，就可以看到自己的Mac address被print出來了！</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的記憶體垃圾回收機制</title>
      <link href="/2021/10/20/garbage-collection-python/"/>
      <url>/2021/10/20/garbage-collection-python/</url>
      
        <content type="html"><![CDATA[<p>我們知道，Python應用在執行的時候，需要從記憶體規劃出一段空間，用於存放臨時產生的變數，計算完後再放進永久儲存介質，如果所需要存放的臨時變數過大，則會造成OOM(Out of Memory)記憶體錯誤，程式可能會被作業系統終止<br>對於伺服器應用來說，為了設計永遠不中斷的系統，記憶體管理會變得非常重要，不然容易引發記憶體洩漏(Memory Leak)</p><p>什麼是記憶體洩漏呢？我們的應用一般都是執行過程中不停的對作業系統申請記憶體、釋放記憶體，這裡的洩漏不是指被攻擊，而是程式沒有釋放已不再使用的記憶體，造成記憶體的浪費</p><p>那麼Python是怎麼處理的呢？需要工程師們有意識的申請變數記憶體，用完再手動清除嗎？答案是: NO，Python會幫你自動找出不再使用的變數，然後釋放歸還給作業系統</p><span id="more"></span><h3 id="reference-count(引用計數)">Reference Count(引用計數)</h3><p>Python中一切皆為Object，每個Object都有多個pointer指向它<br>那麼怎麼知道這個Object之後永遠都不會被使用呢？Python使用的是Reference Count(pointer指向數量)，當它為0的時候，代表這個Object不可達，不會再被使用了，需要被回收<br>我們來舉個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span>(<span class="params">hint</span>):</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.30859375 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.09765625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 11.61328125 MB</span></span><br></pre></td></tr></table></figure><p><code>show_memory_info</code>裡面用到了python裡面的library <code>psutil</code>，能夠取得process所消耗的memory bytes，程式剛執行的時候，佔用了7MB左右的記憶體，在我們宣告了長度為一千萬的list之後，記憶體飆漲到了404MB，然而在離開main函數後，變數a不會被用到了，所以reference count=0，就被Python給回收了，所以最後的記憶體消耗又降回來，變成11MB</p><p>再給大家一個例子，如果我們把變數a改成global呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a= []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.0859375 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 404.0859375 MB</span></span><br></pre></td></tr></table></figure><p>即使程式跑到最後一刻，記憶體使用量還是高的誇張，所以Python的記憶體垃圾回收機制並不是一勞永逸的做法，在程式設計上也要謹慎<br>最後，面試官問你，Reference count=0是Python執行垃圾回收的必備條件嗎？還有沒有其他可能性會導致垃圾回收？</p><h3 id="循環引用">循環引用</h3><p>還有一種情況是，變數往後都不會再被用到了，但是他的Reference count不是0，會是什麼樣的情況呢？就是循環引用，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.2890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.67578125 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 790.67578125 MB</span></span><br></pre></td></tr></table></figure><p>承接上個範例，變數a和b都是個長度為一千萬的list，然後互相append，我們發現程式運行結束時，記憶體還是沒有被回收<br>這還只是比較簡單明顯的狀況，很多循環引用是很難被發現的，那麼我們應該要怎麼做呢？<br>遇到這種情況，我們可以手動的call垃圾回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.37890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.03515625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 12.12890625 MB</span></span><br></pre></td></tr></table></figure><p>針對循環引用的垃圾回收，Python使用標記清除(mark-sweep)和分代收集(generational)，這裡來簡單介紹一下</p><h4 id="標記清除演算法">標記清除演算法</h4><p>我們先用圖論來表達不可達概念，對於一個有向圖，從任意一個節點出發進行遍歷，遍歷結束後發現有節點沒有被標記，則為不可達，不可達節點我們就能視為循環引用，需要對其回收<br>然而每次都要遍歷全圖，對Python來說是一個巨大了浪費，所以在Python裡面維護了一個雙向linked-list，並且只維護Container類的變數(只有Container類的變數才會循環引用)</p><h4 id="分代收集演算法">分代收集演算法</h4><p>Python將所有變數分為三代，剛創立的變數為第一代，垃圾回收過一次還存在的變數會從上一代移到下一代，例如第一代到第二代，當垃圾回收中，新增的變數減去刪去的變數超過某個閥值，就對這一代執行垃圾回收</p><h3 id="記憶體洩漏debug">記憶體洩漏debug</h3><p>即使Python有了強大的記憶體管理機制，但是難免還是有漏網之魚，那有沒有什麼好的Debug手段呢？<br>Python有個Library <code>objgraph</code>，使用方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"></span><br><span class="line">objgraph.show_refs([a])</span><br><span class="line">objgraph.show_backrefs([a])</span><br></pre></td></tr></table></figure><h3 id="總結">總結</h3><p>今天我們深入了瞭解了Python垃圾回收機制，主要有下面幾點</p><ul><li>垃圾回收在Python用於釋放不會再用到的記憶體給作業系統</li><li>Reference count是最常見的方式，不過不是回收的唯一條件</li><li>Python的垃圾回收還包含了標記清除和分代收集演算法，主要針對防循環引用</li><li>Debug記憶體洩漏方面，objgraph是個好工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]金錢超思考</title>
      <link href="/2021/10/15/think_money_book/"/>
      <url>/2021/10/15/think_money_book/</url>
      
        <content type="html"><![CDATA[<h3 id="金錢超思考-- 5大金錢迷思 x 25道創造財富的關鍵思考">金錢超思考 - 5大金錢迷思 x 25道創造財富的關鍵思考</h3><p><img src="/images/think_money.jpg" alt=""><br><strong>金錢超思考</strong>這本書不是一本教你投資致富的書，而是**「如何思考金錢？」**，這一個問題的背後，作者娓娓道來背後蘊藏的智慧<br>從出社會開始，邁入職場後都在比誰賺的多，然而我們對於金錢的追求與渴望到底是為了什麼？這又衍伸出更多的問題：我到底該把錢花在哪些地方？如何正確看待金錢？擁有很多金錢的意義是什麼？即使財務自由之後又如何？<br>讀完這本書後，我覺得在我們有限的時間及精力裡，賺更多的錢不是唯一，我們需要懂的如何花錢、賺錢和存錢，三者缺一不可，下面我將用條列式的方式，把書中的精華做一個摘要</p><span id="more"></span><h5 id="如何用錢買到快樂?">如何用錢買到快樂?</h5><p>似乎從小到大，我們的學歷越來越好，賺的錢越來越多，職位越爬越高，但我們仍然沒有感覺更快樂，為什麼會這樣？這是因為我們的「與他人比較」心態，例如我們有錢了，就搬到豪宅區置產，但看到鄰居們更富有，車更豪華，你又開心不起來了。<br>第二個是，我們東西總會越買越好，讓我們陷入無止盡的物質追逐，然而這種快樂是暫時的，作者給出的建議是，<strong>屏除與外界的比較，回歸自己的內心。</strong><br>那麼要如何用錢買到長久的快樂呢？第一個，把錢花在別人身上比花在自己更快樂，當自己有閒錢的時候，幫助弱勢族群所帶來的快樂是無與倫比的</p><ol><li>不要追逐物質，改為追求體驗</li><li>錢可以買到自由</li><li>有錢不一定會快樂，但是沒有錢肯定不快樂</li><li>錢能解決生活中80%的問題，剩下20%可以用錢來緩解</li></ol><h5 id="把退休當成永遠的財務目標">把退休當成永遠的財務目標</h5><p>我們可能在年輕時努力存錢買房買車、關注小孩的教育資源，直到五十歲後才驚覺退休的問題，但時常為時已晚。我們投資的目的並不是要變得大富大貴，而是避免年老得過著窮困潦倒的生活。以退休為首要的財務規劃，可以奉行這三個理財策略:</p><ol><li>長期投資</li><li>減少舉債</li><li>習慣儲蓄</li></ol><h5 id="長期投資，減少債務">長期投資，減少債務</h5><p>除了長期投資之外，短期要盡可能減少舉債，例如：優先償還學貸、提高繳納房貸的月付額、不要動用信用卡的現金借貸。債務纏身的最大隱憂，就是你會在不知不覺間，離財務自由的目標越來越遠。</p><h5 id="愛上儲蓄">愛上儲蓄</h5><p>現在花少一點錢其實算不上犧牲，因為大部分的消費（尤其是物質上的）並不會帶來更多的快樂。反而，為了將來的消費而進行儲蓄，這種對未來產生的期待的「延遲享樂」心態，反而能為心靈帶來更多的富足。只要意識到以下三個儲蓄能帶來的效益:</p><ol><li>降低固定成本，不僅可以存更多錢，手頭上也可以有更多金錢用於自主性消費。</li><li>如果我們習慣了生活成本遠低於收入的日子，等到退休時，不需要太多的積蓄也能過得很舒適。</li><li>如果在二十幾歲時就過著節儉的生活，日後便能享受到生活水準逐步提高所帶來的快樂感受。</li></ol><h5 id="賺錢的同時請思考風險">賺錢的同時請思考風險</h5><p>對於投資，首重「分散持有」與「股債搭配」，避免金融海嘯或單一市場的巨幅崩跌，對資產帶來的鉅額損失。對於仍是家庭經濟支柱的個人，首重「壽險」、「重大疾病險」，避免人身意外對家庭財務帶來巨大的衝擊。</p><p>最後，這是書中一字不漏總結的12點建議，我覺得能納入人生原則，善加運用我們的金錢:</p><ol><li><p><strong>我們偏愛物品的使用價值，但是把錢花費在體驗上會比較快樂</strong>。不要再想著買新車，不如來一場橫跨歐洲的旅行。</p></li><li><p><strong>我們應該運用金錢與朋友和家人共度特別的時光</strong>。帶小孩參加運動比賽，帶你的另一半去看戲，和朋友吃頓晚餐，預訂好行程去探望你的孫子。</p></li><li><p><strong>當我們有時間可以做自己熱愛的工作時，應該好好為自己規劃生活</strong>。為了達到這個目標，我們應該在二十幾歲時盡可能地存錢，才能買到某種程度的財務自由。等到我們四十或五十多歲，就可以運用財務自由轉換到收入不是那麼優渥、但卻能讓我們感到心滿意足的工作。</p></li><li><p><strong>我們不應該擔心退休後會早死，而是要有心理準備，我們的壽命可能會比預期要長</strong>。面對這樣的風險，多數人應該要延遲領取政府退休金福利，以換取每個月能夠獲得較高的固定收入。你也可考慮購買即期年金，如此一來終身都能擁有固定的收入來源。</p></li><li><p><strong>我們的投資期限不是以月或是年，而是以數十年來計算</strong>。我們應該擺脫市場短期下跌的影響，而是像那些分散投資全球股票，並長抱三十、甚至五十年的投資人一樣，才能累積驚人的報酬。確實，對於債券持有或是現金投資不足的退休人士來說，長期的熊市可能會嚴重衝擊他們的報酬，但是對於善於存錢的年輕人來說，卻是一份寶貴的禮物，因為他們可以趁機逢低買進。</p></li><li><p><strong>我們應該盡可能降低每月的固定成本，例如房貸或租金、水電費、雜費、保費等</strong>。降低固定成本才能擁有更大的財務空間，降低財務壓力，可以因此有更多的錢自由地投入「有趣」的消費，同時更積極地存錢。</p></li><li><p><strong>良好的儲蓄習慣並非是自然而然形成，我們必須盡可能讓存錢的過程少一些痛苦</strong>。我們可以固定提撥一定比例的薪資，投入雇主的退休計畫。或是設下定期定額投資計畫，也就是每個月從銀行帳戶中扣除一筆資金，直接投資我們選定的基金。此外，你可以選擇較容易執行的財務策略，例如每個月的房貸還款金額增加兩、三千元，有任何意外之財都應該好好存起來，例如退稅或是兼差的收入。</p></li><li><p><strong>愈是努力想要打敗股市大盤，就愈可能失敗，因為會產生投資成本</strong>。為了避免這樣的結果，我們不應該再認為自己比其他投資人聰明，而是要抱持謹慎的態度，作法是購買分散投資全球的低成本指數型基金。</p></li><li><p><strong>永遠不要忘了股票的基本價值</strong>。如果你的股票投資組合足夠分散，整體基本價值的變動會比市場價格要緩慢。我們應該抱持務實的心態，把重點放在我們投資的金錢能創造多少的股息和盈餘；有效掌握市場可能的長期報酬率；我們應該像購物者一樣思考，看到市場走跌就像是看到地方上的百貨公司推出促銷活動時一樣的興奮。</p></li><li><p><strong>長期而言，退休可能是我們這一生最後一個財務目標，但是我們必須把它放在第一位</strong>。退休是成本最高昂的目標，需要花費數十年的時間儲蓄和累積投資所得，才能存夠需要的金錢。退休的目標也和其他目標很不一樣，不像是買房或是支付小孩教育費用。有什麼不一樣？對多數人來說，退休並非是選擇性的，退休後我們便沒有薪水，因此沒有固定的收入可花用。</p></li><li><p><strong>我們應該採取宏觀的視角，依據我們能夠創造的收入來整合規劃我們的財務</strong>。我們賺取的固定收入就好比是債券，能創造長達四十年的穩定收入來源。擁有了這筆穩定收入，我們可以讓投資組合分散投資全球股票，累積退休之後需要的積蓄；我們可以在二十幾歲時舉債，然後在退休之前還清債務。我們必須保障自己賺錢的本事，因此應該要購買適合的健康保險以及足額的失能與人壽保險。</p></li><li><p><strong>我們的目標不是變有錢。我們的目標是擁有足夠的金錢，去過我們想要的生活</strong>。我們不應該產生過高的投資成本、過度遠離追蹤全球指數的投資策略，或忽略可預防重大財務風險的保險，唯有如此才有可能達成我們希望的目標。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 金錢超思考 </tag>
            
            <tag> 理財 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的GIL</title>
      <link href="/2021/10/10/gil-python/"/>
      <url>/2021/10/10/gil-python/</url>
      
        <content type="html"><![CDATA[<h3 id="gil（global-interpreter lock)">GIL（Global Interpreter Lock)</h3><p>Python的multi thread讓人不明所以，為何我的電腦明明有四個CPU，用multi thread性能卻沒有增長呢？我們先看一個例子</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountDown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Single Thread</span></span><br><span class="line">start = time.time()</span><br><span class="line">CountDown(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two Threads</span></span><br><span class="line">start = time.time()</span><br><span class="line">t1 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t2 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Time consumed: 4.894810676574707</span></span><br><span class="line"><span class="comment"># Time consumed: 4.441636085510254</span></span><br></pre></td></tr></table></figure><p><code>CountDown</code>是個CPU heavy的函數，但是神奇的事情發生了，明明用了兩個Threads，耗時卻差不多，都是4秒左右<br>這是怎麼回事？難道我買的電腦只有一顆CPU有在工作？不對呀，如果換成C++寫，速度提升馬上有感<br>看起來不是電腦的問題，而是Python的multi thread失效了，沒有執行真正的併行運算<br>然而Python的Thread是實實在在的Thread，在Linux，他封裝了Pthread(POSIX Thread)，在Windows，是Windows Thread，由於只是做封裝，所以Python的Thread完全受作業系統管理，例如協調何時執行、資源管理等等</p><p>Python之所以用了multi thread起不到性能提升的作用，正是因為GIL，在整個Python的Process，只允許同時跑一個Thread，其他的會被Lock，所以本質來說，Python的Thread只是&quot;輪流&quot;執行</p><h3 id="為什麼有gil?">為什麼有GIL?</h3><p>我們知道Python是基於C，也就是CPython實現的，之所以有GIL就是和CPython有關<br>CPython使用Reference Count管理記憶體，用來記錄多少pointer指向這塊記憶體，當Reference Count=0時，就會釋放記憶體，看個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>3的由來是a, b和sys.getrefcount傳進a所引發的reference，所以總共是3<br>所以說，如果兩個Python的Threads同時引用了a，同時reference count += 1，觸發了race condition，最終reference count只會加1而已<br>由於有這樣的風險，Python就乾脆的設定了一個GIL，但也不能說Python是天然不用擔心race condition的語言，畢竟Python的一行程式，可能代表著多行的bytescode，例如Python的<code>n+=1</code>，他代表的bytecode是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD_CONST <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">INPLACE_ADD</span><br></pre></td></tr></table></figure><p>若我們在<code>INPLACE_ADD</code>前，GIL被釋放了，而其他Thread跑了<code>LOAD_CONST 1 (1)</code>一樣會造成race condition!<br>我們舉個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>所以說，GIL的目的是<strong>為了方便CPython的編寫者，不用顧慮變數記憶體的分配，而不是為了Python應用的開發者</strong>，所以我們還是需要lock等工具，例如下面這個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="可以繞過gil嗎？">可以繞過GIL嗎？</h3><ul><li>Python的GIL是CPython上的限制，如果要繞過，可以透過JPython(Java實現的Python)等</li><li>把CPU heavy的程式碼放在別的語言實現(C++)，然後提供Python調用的API</li></ul><h3 id="總結">總結</h3><p>我們探究了Python GIL的原理，他的目的是為了避免記憶體回收的race condition設計出來的一套機制，雖然使得CPython更容易開發，但是卻沒有真正意義上的multi threads<br>不過我們也不用太過於糾結GIL的影響，對於CPU heavy的程式碼，我們還是可以透過其他語言的實作，讓Python去call，進而利用好CPU性能</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Asyncio的Event loop</title>
      <link href="/2021/10/08/eventloop-python/"/>
      <url>/2021/10/08/eventloop-python/</url>
      
        <content type="html"><![CDATA[<p>之前我們講過了Python的Coroutine，提到了我們用的是asyncio library，不同於Coroutine那一篇，我們這一篇注重於原理的理解</p><p>我們知道，multi threading能夠使得效率及CPU使用率大大提高，那為什麼我們需要Asyncio(Coroutine)呢？</p><ul><li>因為在multi threading下，程式碼容易被作業系統打斷，因此可能會出現race condition</li><li>以及，context switch會造成性能損耗，如果I/O過多，不停的context switch，會損失很多性能</li></ul><p>於是乎有了Asyncio</p><span id="more"></span><h3 id="asyncio原理">Asyncio原理</h3><p>Asyncio和Python的程式一樣，實際上是single thread的，不過可以不停地切換，只要拿到GIL就可以進行任務，這裡的任務，就是特殊的future object，並且被Event loop所控制<br>我們可以假設任務只有兩個狀態 - 預備狀態和完成狀態，預備狀態指的是任務目前空閒，隨時可以執行，而等待狀態就是任務已經執行，但是被掛著等待某個操作完成，例如I/O<br>於是乎，Event loop有兩個job list，分別對應兩種狀態，並且選取一個預備狀態的任務，執行它，一直到他被交還給Event loop<br>當任務被交還給Event loop時，Event loop會根據其是否完成，把任務放進預備或完成狀態的list</p><ul><li>如果完成，則放進去預備狀態</li><li>如果未完成，則放進去等待狀態</li></ul><p>然後再遍歷等待狀態list，看他們是否完成，如果完成再放進去預備狀態</p><p>然後週而復始，直到所有任務完成，由於Asyncio的任務不會被外部的因素打斷，所以Asyncio裡面的操作不會出現race condition的問題，再讓我們複習一下這段程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>async/await是aysncio的一種寫法，代表這個函數或這行程式碼是non-blocking的，如果這裡很耗時，那們就把控制權交還給Event loop，放進等待狀態list<br>另外，<code>asyncio.run()</code>是Python3.7才有的，在舊版本是這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    loop.run_until_complete(</span><br><span class="line">          asyncio.wait(</span><br><span class="line">             [asyncio.ensure_future(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">main([<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">loop.close()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><h3 id="asyncio有缺點嗎？">Asyncio有缺點嗎？</h3><p>當然有，我們知道Asyncio的eventloop藉由async/await去把job控制權交還給Event loop，所以相應的第三方library也要做調整才能完美地利用Coroutine提升性能，例如，著名的<code>requests</code>library就沒有支持Asyncio，而相同功能的<code>aiohttp</code>有兼容Asyncio</p><h3 id="multli-processing?-multi-threading? or coroutine?">multli-processing? multi-threading? or coroutine?</h3><p>總結來說</p><ul><li>CPU heavy -&gt; 使用multli-processing</li><li>如果I/O慢或太多 -&gt; 使用Coroutine</li><li>反之，如果I/O快 -&gt; 使用multi-threading</li></ul><h3 id="總結">總結</h3><p>這篇文章帶大家過了Asyncio Event loop的原理</p><ul><li>Asyncio是single thread的，但是透過Event loop，併發的執行不同任務，在程式端享有自主控制權</li><li>由於打斷是自己控制的，不會出現race condition的問題，在I/O heavy的情況下，比multi-threading的效率更好，因為不用context switch，且能開啟的任務數量更多</li><li>不過Asyncio的缺點是，需要第三方library的支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> eventloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的並行計算 - Futures</title>
      <link href="/2021/10/05/futures-python/"/>
      <url>/2021/10/05/futures-python/</url>
      
        <content type="html"><![CDATA[<p>無論是哪門程式語言，併發(Concurrent)和並行(Parallel)都是很常用且重要的知識點．例如爬蟲，被廣泛運用在工業界資料收集領域，其用的核心技術，就是併發並行程式<br>正確合理的使用併發並行，無疑會給我們的程式帶來巨大的性能提升，之前我們聊到Python Coroutine，今天我們來聊聊Python的Futures</p><span id="more"></span><p>再稍微複習一下併發(Concurrent)和並行(Parallel)的差別，併發指的是在同一個CPU下，透過上下文切換(Context switch)，讓使用者覺得不同程式段同時執行，並行則是真正意義上的多個CPU同時執行，所以說</p><ul><li>併發 - 通常應用在I/O頻繁或耗時的場景，例如要下載多個檔案，I/O所消耗的時間會比CPU還要多</li><li>並行 - 適合CPU heavy的場景，例如MapReduce的計算，為了加快速度，會需要更多的CPU去完成</li></ul><p>不過需要提到的一點是，如果電腦有四顆CPU，照理說可以同時並行的跑四個Threads，然而在Python卻不能這樣，Python的直譯器天生有race condition的問題，所以同一時刻只能允許一個Thread執行，具體原因後面有機會聊到GIL的時候會提到</p><p>Python的Futures library提供了我們方便建立併發併行的框架，也能夠建立threading pool, process pool等等，我們來看下面簡單的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loading_one</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="comment"># Return value of random.random will be 0 ~ 1</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Job %s is completed.&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">names</span>):</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.<span class="built_in">map</span>(loading_one, names)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    jobnames = [</span><br><span class="line">        <span class="string">&#x27;JobA&#x27;</span>, <span class="string">&#x27;JobB&#x27;</span>, <span class="string">&#x27;JobC&#x27;</span>, <span class="string">&#x27;JobD&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    start_time = time.perf_counter()</span><br><span class="line">    loading(jobnames)</span><br><span class="line">    end_time = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Load &#123;&#125; jobs in &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(jobnames), end_time - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Job JobB is completed.</span></span><br><span class="line"><span class="comment"># Job JobD is completed.</span></span><br><span class="line"><span class="comment"># Job JobA is completed.</span></span><br><span class="line"><span class="comment"># Job JobC is completed.</span></span><br><span class="line"><span class="comment"># Load 4 jobs in 0.706298665 seconds</span></span><br></pre></td></tr></table></figure><p>耗時不到一秒，由於<code>random.random()</code> return介於0和1之間，代表確實是併發執行的<br>這裡我們建立的threading pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>最多可以同時使用五個Threads，而<code>executor.map</code>就像python裡的map一樣，對每個names的元素去call loading_one fucntion<br>另外，雖然我們可以自己設定thread的數量，但是不是越多越好，因為thread的創建、維護、刪除也有一定的性能消耗，設定很大可能會導致速度更慢<br>當然，我們也可以把上述程式碼改成&quot;併行&quot;，併行就是多個CPU一起跑，只要做出下面的變化即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>函數<code>ProcessPoolExecutor</code>代表創建Process pool，有興趣的讀者可以嘗試，一般會遇到改成<code>ProcessPoolExecutor</code>後，耗時更多了，這是因為並行的方式適合在CPU heavy的情況中</p><p>有沒有發覺Python的Futures library和asyncio非常像？，他們都會將處於等待的job放進去list裡，這些job隨時都可以查詢，當然，他們的結果和異常(<code>job.result()</code>)也能在結束之後拿到</p><p>再介紹一個Futures常用的方法 - <code>done()</code>，表示該job是否已經完成，done()是non-blocking的，代表call了他之後會立即返回，還有一個方法是<code>add_done_callback(func)</code>，當job完成後，會被通知並call callback function</p><h3 id="總結">總結</h3><p>首先，我們學習了併發(Concurrent)和並行(Parallel)的差別<br>併發通常用於I/O密集的場景，並行則適合CPU heavy的場景</p><p>隨後，我們展示了Python Futures library的例子，透過Thread Pool和Process Pool展示如何優雅的利用併發和並行執行程式</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> concurrent </tag>
            
            <tag> parallel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]與成功有約：高效能人士的七個習慣</title>
      <link href="/2021/10/03/7habits_book/"/>
      <url>/2021/10/03/7habits_book/</url>
      
        <content type="html"><![CDATA[<h3 id="與成功有約：高效能人士的七個習慣">與成功有約：高效能人士的七個習慣</h3><p><img src="/images/7habit.jpg" alt=""><br>讀了《高效能人士的七個習慣》，學到了不少．喜歡這一種條列式的框架，一點點的歸類不同的高效能人士的不同習慣．這本書我讀的是英文版，一般來說這種書不會像英文小說一樣使用艱深的詞彙，所以想說透過這個機會可以學到我沒有但高效能人士有的好習慣，同時還能提升英文閱讀力，下面是我讀完後的總結:</p><ol><li>主動 Proactive<ul><li>不受周遭环境影响，只受目前的價值做决策</li><li>不要怪外部環境，多想想改變自己</li></ul></li></ol><span id="more"></span><ol start="2"><li>最終目標導向 Begin with the end in mind<ul><li>想清楚最終的目標，而不要被短暫的小目標打斷</li><li>任何事情都被創造兩次，一次是設計藍圖的時候，一次是真正被創造的時候</li><li>領導是做對的事，管理是把事做對</li><li>人生就是由安全感、指導、智慧、能力，如果你是原則至上的人，容易獲得上述四個</li><li>原則至上的人不受外在和情緒的影響，會計算各個選項的價值，再做決定</li><li>我覺得我現在是一半self-center，一半principle-centre</li><li>在做一个可怕的事情前，先想像成功的樣子</li></ul></li><li>把最重要的事擺第一<ul><li>事情分四個維度，重要且緊急、重要但不緊急、不重要但緊急、不重要也不緊急，很多人永遠都困在重要且緊急的事，並把剩下的時間花在不重要也不緊急的事上</li><li>重要和緊急是不相關的</li><li>要高效，必須先定義好重要的事，也就是重要且緊急和重要但不緊急</li><li>設定一周的pricinple剛剛好，一天則太inflexible</li></ul></li><li>Win/Win<ul><li>只有win/win和lose/lose，沒有win/lose和lose/win</li><li>把no deal作為一個option</li></ul></li><li>尋求被理解前，先理解他人<ul><li>幫人解決問題前，必須先診斷，而不是把自己套用在對方的情境，說自己怎麼解決的</li><li>學會聆聽</li><li>聆聽的技巧 - 重複他說的話，或是換句話說，讓對方覺得你懂他</li></ul></li><li>協同效應<ul><li>試著找共享的目標，1 + 1 &gt; 2</li><li>Value the difference 欣賞不同</li><li>換位思考</li><li>透過看見差異和尋找更好的方案，展示創新及解決問題的能力</li></ul></li><li>把優秀變成一種習慣<ol><li>平衡的發展四個維度的能力<ol><li>social - 協同能力</li><li>physical - 身體健康</li><li>Mental - 閱讀、寫作、計劃</li><li>spiritual - 冥想、看清價值</li></ol></li><li>是一種重要但不緊急的事</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 與成功有約：高效能人士的七個習慣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的coroutine</title>
      <link href="/2021/09/29/coroutine-python/"/>
      <url>/2021/09/29/coroutine-python/</url>
      
        <content type="html"><![CDATA[<p>Coroutine(協程)和我們常聽到的multithread, multiprocess一樣，是一种併發(councurrent)的一種方式，注意的是，併發和併行的不同在於，併發是快速的context switch讓user覺得程式同時執行，而併行是指不同CPU同時執行</p><span id="more"></span><p>隨著互聯網快速發展，我們逐漸遇到了C10k的瓶頸，也就是同時連接到Server的數量到達一萬個，這會造成process上下文切換佔用了大量的資源，即使是Thread也頂不住這麼大的壓力，於是Coroutine登場了</p><p>很多人說，Coroutine是輕量化的Thread，那麼Coroutine和Thread有什麼不同呢？<br>兩者最大的差別是，Thread的搶佔式多工，Coroutine是協同式多工</p><h5 id="搶佔式多工">搶佔式多工</h5><p>程式有各自的優先權，作業系統會根據程式的優先權安排當下哪個程式能擁有CPU資源去執行，另外作業系統有權中斷任何正在執行中的程式。</p><h5 id="協同式多工">協同式多工</h5><p>程式會定時放棄已佔有的執行資源讓其它程式執行。由於是由程式自己讓出執行資源，不需要由底層的作業系統來處理，所以 Coroutine 交替時所產生的Context switch負擔比 Thread 小</p><p>接下來，我們給個範例，看一下Python的Coroutine怎麼寫，Python的Coroutine library是<code>asyncio</code>，需要跑在Python3.7以上的環境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> sec <span class="keyword">in</span> secs:</span><br><span class="line">        <span class="keyword">await</span> loading(sec)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br></pre></td></tr></table></figure><p>async代表這個函數是非同步函數，意思是會順序執行的<br>然後再來説説執行，執行有三種方法</p><ol><li>透過 await來call<br>await的執行效果，和Python平常運行程式的效果一樣，會阻塞在這裡，執行完後再繼續</li><li>透過asyncio.create_task()來創建任務</li><li>透過asyncio.run()來執行，不用去理會Event loop怎麼運行的</li></ol><p>上面的程式碼順序的跑了10秒是正常的，因為async會阻塞，接下來我們要來講Coroutine一個重要的概念-Task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="comment"># await asyncio.gather(*tasks)</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>我們可以看到，當Task被create之後就會把上執行，然後我們對每個task加了await，等所有task都執行完後才能繼續下一步，或是可以看我註解掉的那一行<code>await asyncio.gather(*tasks)</code>，也能達到同樣的目的</p><h3 id="coroutine-runtime">Coroutine runtime</h3><p>接下來我們來解析Coroutine的runtime和背後的邏輯，我們一樣用上面的例子，步驟有點多，我們慢慢來</p><ol><li>asyncio.run(main())，程式进入 main() 函数，同時也開啟了Event loop</li><li>兩個task都被創建，進入Event loop等待被執行，執行到print，輸出loading…</li><li>await 五秒的task, Event loop開始調度worker1</li><li>worker1開始執行，遇到await.sleep，從現在的Task切出，Event loop開始調度worker2</li><li>worker2開始執行，一樣遇到await.sleep，從現在的Task切出</li><li>以上的時間都非常快，由於兩個都在sleep，所以Event loop暫停調度</li><li>3秒鐘後worker2的sleep完成，Event loop將控制權交給三秒task，print出OK 3，Task完成，從Event loop退出</li><li>再兩秒鐘後，同理worker1的sleep完成，print完後，從Event loop退出</li><li>Coroutine全部結束</li></ol><p>接下來我們進階一下，如果想給Coroutine任務限定執行時間，一但超時就取消，該怎麼做呢？以及如果runtime發生錯誤，又該怎麼處理？我們來看看下面的程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker1</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker2</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker3</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    task_1 = asyncio.create_task(worker1())</span><br><span class="line">    task_2 = asyncio.create_task(worker2())</span><br><span class="line">    task_3 = asyncio.create_task(worker3())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    task_3.cancel()</span><br><span class="line"></span><br><span class="line">    res = <span class="keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), CancelledError()]</span></span><br></pre></td></tr></table></figure><p>我們可以看到，worker1正常執行，worker2執行中遇到錯誤，worker3執行太久被我們cancel了<br>到這裡，其實thread能做的coroutine也能做</p><h3 id="總結">總結</h3><p>本篇講解了Python Coroutine的基本概念和用法，這裡簡單總結一下</p><ul><li>Coroutine和threading的差別主要是Coroutine只能用一個CPU core，以及Coroutine是程式決定什麼時候要切換任務</li><li>Coroutine的寫法更加簡潔清晰，滿足中小級別的併發需求</li><li>寫Coroutine的時候，腦海要有清晰的Event loop概念，知道什麼時候需要暫停、等待I/O，什麼時候可以執行到底</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的iterator和generator</title>
      <link href="/2021/09/25/iterator-generator-python/"/>
      <url>/2021/09/25/iterator-generator-python/</url>
      
        <content type="html"><![CDATA[<p>剛寫Python的時候，你可能對於Python的語法<code>for i in [2, 4, 6, 8, 10]</code>嘆為觀止，理解起來也非常直觀，比起C++或java的語法，簡潔了不少<br>可是你有想過，Python在處理for in的時候，發生了什麼嗎？什麼樣的object可以被放進for in loop呢？</p><span id="more"></span><h3 id="container和iterator">Container和Iterator</h3><p>Container非常好理解，Python一切皆為object，object的集合就是Container，例如list, set, tuple等等的<br>所有的Container都是iterable(可迭代的)，可迭代是什麼意思呢？你可以想像一下你去水果攤買蘋果，老闆不跟你說庫存，然後你每次都只需要跟老闆說，我要一個蘋果，直到老闆跟你說蘋果沒了<br>Container透過<code>iter()</code>返回一個Iterator，然後我們可以透過<code>next()</code>就能像和老闆要蘋果那樣，一個個要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_arr = <span class="built_in">iter</span>(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>當老闆說沒有蘋果的時候，就會throw exception出來</p><h3 id="generator">Generator</h3><p>Generator可以理解為懶人版的Container<br>生成一個Container很簡單，<code>[i for i in range(100000000)]</code>就可以生成一億個int的array，每個元素都會保存在記憶體當中，當然，轉成Iterator後也是，只是他們取用元素的方式不同而已<br>而Generator的使用方法和Iterator比較類似，都是需要後再取，只是Iterator會預先把所有元素放進記憶體，而Generator會等有需要拿的時候才會把該元素載入記憶體</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span>(<span class="params">hint</span>):</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_iterator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing iterator&#x27;</span>)</span><br><span class="line">    list_1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after iterator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_1))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_generator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing generator&#x27;</span>)</span><br><span class="line">    list_2 = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after generator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_2))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_iterator()</span><br><span class="line">test_generator()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initing iterator memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after iterator initiated memory used: 2015.828125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 3869.05078125 MB</span></span><br><span class="line"><span class="comment"># initing generator memory used: 9.5703125 MB</span></span><br><span class="line"><span class="comment"># after generator initiated memory used: 9.58203125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 9.58203125 MB</span></span><br></pre></td></tr></table></figure><p>我們可以看到記憶體驚人的差異，在Iterator和Generator初始記憶體都差不多的情況下，Iterator需要2GB的記憶體，而Generator只需要9.5MB，如果遇到不需要同時在記憶體保存這麼多東西的場景，例如元素總和，可以使用Generator<br>由上面的範例可以看到，Generator的初始化寫法是<code>(i for i in range(100000000))</code><br>那麼Generator還能怎麼玩呢？例如我們想要驗證一個數學公式{(1+2+3+…+n)^2 = 1^3 + 2^3 + 3^3 + … + n^3}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">k</span>):</span></span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">yield</span> i ** k</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen_1 = generator(<span class="number">1</span>)</span><br><span class="line">gen_3 = generator(<span class="number">3</span>)</span><br><span class="line">sum_1 = <span class="number">0</span></span><br><span class="line">sum_3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   sum_1 += <span class="built_in">next</span>(gen_1)</span><br><span class="line">   sum_2 = sum_1 ** <span class="number">2</span></span><br><span class="line">   sum_3 += <span class="built_in">next</span>(gen_3)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;sum_2: %s, sum_3: %s&quot;</span> % (sum_2, sum_3))</span><br><span class="line">   time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>yield是Generator獨有的，你可以理解為，在next之前，他就會被卡在這裡，call next之後yield就會return值出來<br>你看，有了Generator，我就能一直無限的驗證下去，不用擔心記憶體爆炸，Iterator是一個有限集合，Generator是一個無限集合！</p><p>除此之外，Generator也能讓程式碼更加簡潔有力！讓我們看下面的例子，輸入一個array和一個數字，找出該數字在array的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Iterator</span><br><span class="line">def find_iter(arr, val):</span><br><span class="line">   res = []</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         res.append(idx)</span><br><span class="line">   return res</span><br><span class="line">   </span><br><span class="line"># Generator</span><br><span class="line">def find_gen(arr, val):</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         yield idx</span><br><span class="line"></span><br><span class="line">arr = [1, 5, 2, 9, 1, 7, 2, 1, 2]</span><br><span class="line">val = 2</span><br><span class="line">print(find_iter(arr, val))</span><br><span class="line">print(list(find_gen(arr, val)))</span><br><span class="line"># Output</span><br><span class="line"># [2, 6, 8]</span><br><span class="line"># [2, 6, 8]</span><br></pre></td></tr></table></figure><p>顯然的，Generator清爽多了</p><h3 id="總結">總結</h3><p>本篇講了Container, Iterator和Generator</p><ul><li>Container是Iterable的，代表將Container放進for in裡我們可以一個個迭代</li><li>Generator是一個特殊的Iterator，使用Generator可以寫出更清新，更省資源的程式碼</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]IP&amp;MAC地址 - 網路通訊世界的大門</title>
      <link href="/2021/09/23/ipbasic-network/"/>
      <url>/2021/09/23/ipbasic-network/</url>
      
        <content type="html"><![CDATA[<h3 id="每一個網卡都有一個ip和mac，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼">每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼</h3><p>警察要找你，他是怎麼透過你的身分證找到你的呢？<br>藉由身分證上的戶籍地址(IP)，找到了你的家，按下你家的門鈴後，大喊了身分證號碼(MAC)，你到了門口，警察就這樣找到你了</p><span id="more"></span><h3 id="ip地址">IP地址</h3><p>IP地址就像是電腦網卡裡家家戶戶的門牌號碼，有了IP，資料就能一層層路由到目的地電腦，那麼首先，在你的電腦裡，我們要怎麼查我們電腦裡的IP門牌號碼呢？</p><p>在Linux，有兩個指令可以查詢，分別為<code>ifconfig</code>和<code>ip addr</code><br><strong>ifconfig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6251  bytes 9073424 (8.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3111  bytes 170522 (166.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ip addr</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>ifconfig來自於Linux的net-tools，而ip addr來自於iproute2。net-tools起源於BSD，自2001年起，Linux社群已經對其停止維護，而iproute2旨在取代net-tools，並提供了一些新功能。一些Linux發行版已經停止支援net-tools，只支援iproute2。 net-tools通過procfs(/proc)和ioctl system call去訪問和改變kernel網路設定，而iproute2則通過netlink socket interface與kernel通訊。 net-tools中工具的名字比較雜亂，而iproute2則相對整齊和直觀，基本是ip command加後面的sub-command。不過這麼多年過去了，net-tool依然還在被廣泛使用，最好還是兩套指令都掌握吧。</p></blockquote><p>IP地址是門牌號碼，所以不能大家都一樣，不然就會起衝突．舉個例子，<code>132.128.200.32</code>是一個IP地址，由三個&quot;.&quot;分成四個部分，每個部分有8個bit，四個部分加起來總共有32個bit，也就是最多只能產生<code>2**32</code>個門牌號碼．因為不夠用，所以有了IPv6，也就是上面的輸出結果<code>fe80::ca61:d665:1750:e806</code>，總共有128位，看起來應該是夠了．</p><p>由於現有的32bit ip地址不這麼夠用，其中ip又有分私人ip(自己內網的ip)和公共ip(任何地方都能連的ip，例如Google)，私人ip地址的目的是為了安全以及讓更多電腦能有自己的ip地址，可以試想一下，如果大家都能訪問你的電腦，如果你的電腦被植入了惡意程式，某個port被打開，是如此的不安全，下面的ip地址範圍就是私人地址</p><table><thead><tr><th>地址範圍</th><th>數量</th></tr></thead><tbody><tr><td>10.0.0.0–10.255.255.255</td><td>16,777,216</td></tr><tr><td>172.16.0.0–172.31.255.255</td><td>1,048,576</td></tr><tr><td>192.168.0.0–192.168.255.255</td><td>65,536</td></tr><tr><td>所以說，下次你跑<code>ip addr</code>看到你的ip是<code>192.168.2.132</code>不用懷疑，你在私人ip裡，外面的電腦無法和你的電腦連結</td><td></td></tr></tbody></table><h3 id="mac地址">MAC地址</h3><p>MAC地址是一個容易和IP地址誤解的地址，因為MAC地址號稱全世界唯一，那既然唯一了，為何我們還要IP地址呢？其實MAC地址與其說是個地址，不如說他是個網路ID<br>舉個例子，我們想找的一個人，他的身分證是A123456789，然後他的身分證上面寫的地址是，<code>台北市文山區興隆路五段9弄18號4樓</code>，後面的地址就是像是電腦的IP，而身分證就是這個人．<br>或許你也有聽過，MAC地址其實是可以改的，只要不要在同個內網下有多個MAC地址就好，就像是同個家庭，不要有重複的&quot;身分證&quot;<br>MAC地址從上面的<code>ip addr</code>指令我們可以看到是<code>02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</code></p><h3 id="總結">總結</h3><p>本篇文章講述了IP地址和MAC地址的差別，以及怎麼查詢我們的IP和MAC地址</p><ul><li>IP地址 - 電腦的門牌地址，目的是<strong>路由</strong>，常見於TCP/IP五層上面三層</li><li>MAC地址 - 電腦的唯一ID，目的是<strong>最終指向目的地電腦</strong>，常見於TCP/IP五層中的第二層-鏈接層</li></ul>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> IP </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview-network/"/>
      <url>/2021/09/20/overview-network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成&quot;協議&quot;，巴別塔的計劃就失敗了。<br>但是千年以後，有一種叫&quot;程序猿&quot;的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p><img src="/images/overview_internet.png" alt=""></p><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議(TCP/IP stack)進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的。具體MAC和IP地址的詳細內容何區別可以看<a href="/2021/09/23/ipbasic-network/">這一篇</a></p><h4 id="為何我們常見的tcp/ip要分層呢？">為何我們常見的TCP/IP要分層呢？</h4><p>因為任何複雜的程式或應用都要分，這是大型程式設計的要求。例如，複雜的電商還會分資料庫層、Cache層、Compose 層和Controller 層等等，每一層專注做本層的事情。</p><p>TCP/IP是一個公認的網路通訊協議，是OSI七層的簡化，五層分別為物理層、鏈結層、網路層、傳輸層和應用層，下面用簡短的話分別解釋這五層是做什麼的</p><p><strong>物理層(Physical):</strong> 處理網路線、無線傳輸設備，例如光纖<br><strong>鏈接層(Link):</strong> 乙太網，由於資料經由網路線傳輸過程中難免會錯誤，這一層具有資料糾錯的功能，例如漢明碼<br><strong>網路層(Internet):</strong> 保證路由，如何把數據從MAC傳輸到另一個MAC<br><strong>傳輸層(Transport):</strong> TCP、UDP，其中TCP保證邏輯上end-to-end的可靠性<br><strong>應用層(Application):</strong> 用於與網路相關應用交互的地方，例如http, ssh等等</p><p>那麼層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線，Header放在每一層數據包的最前面，如下圖所示<br><img src="/images/tcpiplayer.png" alt=""></p><p>所以網路封包的傳輸過程是從應用層開始，加header，一直加到下面傳輸層，然後路由器會根據header路由封包到目的地，到了目的地電腦再根據header進行往上逐層解析，再回到應用層</p><p>例如第二層鏈接層，他的header固定就是長度14bytes，我們的作業系統在解析封包時，就會取一個前面14的固定長度進行解析，其中這個14個bytes，包含了三項數據 - 鏈接層的protocol、起始MAC address、目的地MAC address</p><p>網路應用開發人員主要了解第三到第五層就好，我們常看到的ping、traceroute、http、ftp等等都是後三層的應用，之後也會偏重解析這三層並基於這三層建構應用。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的@Decoractor</title>
      <link href="/2021/09/18/decorector-python/"/>
      <url>/2021/09/18/decorector-python/</url>
      
        <content type="html"><![CDATA[<p>今天這篇文章，我們來學習一下Python的Decorator裝飾器</p><p>Decorator在Python是一個非常經典的feature，在工程中也應用廣泛，例如Log, Cache, Threading等等</p><span id="more"></span><h3 id="function-decorator">Function Decorator</h3><p>其實Decorator是對function的封裝，可以理解為對這個function的前後做一點&quot;裝飾&quot;，我們會從python<code>lambda</code>切入講解，引入Decorator的基本概念和用法，最後透過一個實際的例子加深理解</p><p>前面說過，Python的一切皆為Object，連function也不例外，我們看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">helloworld = func</span><br><span class="line">helloworld()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>從上面的例子，我們把func作為一個variable賦予helloworld，然後call helloworld，相當於call了func<br>所以我們也可以把function作為一個參數傳到另外一個function裡面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    func()</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>有了這些基礎概念後，我們接下來可以深入挖掘Decorator<br>按照Decorator的思路，就是對某一個function做前後包裝，例如我們想要計算每個傳進來的function執行花了多少時間，可以這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.220008850097656e-05 secs</span></span><br></pre></td></tr></table></figure><p>更通用一點，我們可以把printer封裝成更generic一點的function直接return</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">printer = decorator_benchmark(print_hello_world)</span><br><span class="line">printer()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 5.2928924560546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們把原本的<code>print_hello_world</code>封裝成<code>decorator_benchmark</code>的內置函數，這樣在外面call就會非常的簡潔，不過這樣還是有點浪費唇舌，如果我們總是需要對<code>print_hello_world</code>測量性能，call之前都需要對他封裝一次，那有沒有一個更簡潔的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.38690185546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們在<code>print_hello_world</code>上面加了<code>@decorator_benchmark</code>，其中<code>@</code>，是Python裡的語法糖，我們可以對一些常見的功能例如benchmark、Log等等寫成一個Decorator function，然後再對其他函數進行&quot;裝飾&quot;，這樣就大大提高了程式的重複利用和可讀性</p><p>當然，Decorator具有強大的靈活性，我們也可以對其傳入參數，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>不過這樣寫有個副作用是，我們裝飾後的<code>print_hello_world</code>的metadata就被改變了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure><p>他告訴了我們function不再是原來的<code>print_hello_world</code>，而是被<code>wrapper</code>取代了<br>不過俗話說的好，見招拆招，為了解決這個問題，我們可以使用Python已有的Decorator <code>@functools.wrap</code>，他會保留原本函數的metadata(也就是將原本函數的metadata copy到Decorator裡面)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function print_hello_world in module __main__:</span></span><br><span class="line"><span class="comment"># print_hello_world()</span></span><br></pre></td></tr></table></figure><h4 id="class-decorator">Class Decorator</h4><p>最後來說說Class Decorator，前面提到的Decorator是以function為形式的，其實class也可以做為Decorator，這樣可以持久化存一些資料．Class Decorator藉由函數<code>__call__</code>，每當call一次被裝飾的function時，就會call一次<code>__call__</code>，我們以&quot;計算函數被call的次數&quot;作為例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">      self.num_call = <span class="number">0</span></span><br><span class="line">      self.func = func</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">      self.num_call += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Num of call is %s&quot;</span> % self.num_call)</span><br><span class="line">      <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Num of call is 1</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Num of call is 2</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><h3 id="總結">總結</h3><p>所謂的Decorator，就是透過去&quot;裝飾&quot;函數，增加或改變已有函數的功能，使得原有函數不需要修改，有如下優點</p><ul><li>封裝原有程式碼</li><li>程式碼簡潔</li><li>易讀</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python Object的比較和複製</title>
      <link href="/2021/09/16/object-op-python/"/>
      <url>/2021/09/16/object-op-python/</url>
      
        <content type="html"><![CDATA[<p>Python的任何variable都是C++的Object<br>所以我們在對Python的variable做任何操作時，其實就是在對Object做，例如我們做variable比較</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><span id="more"></span><p>variable複製</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = <span class="built_in">list</span>(a)</span><br></pre></td></tr></table></figure><p>可是如果只是&quot;賦予&quot;新的variable，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = a</span><br><span class="line">&gt;&gt; b.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt; a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>b會影響a，因為他們共享同個記憶體上的address<br>不過透過上面的範例，你可能還是不太清楚</p><ul><li><code>a==b</code>是比較兩個object address相等呢？還是value相等呢?</li><li><code>b = list(a)</code>是shallow copy還是deep copy呢？</li></ul><h4 id="比較語法">比較語法</h4><p>在Python中你應該遇過下面兩個語法，你能分辨出有什麼不同嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>==</code>表示兩個varaibles的&quot;值&quot;是否相等，<code>is</code>表示兩個varaibles是否為同一個Object，是否address也相同<br>在Python中，我們可以透過<code>id(variable)</code>去拿variable的唯一ID，所以判斷<code>a is b</code>如同<code>id(a) == id(b)</code><br>我們再看一個百思不得其解的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">10</span></span><br><span class="line">&gt;&gt; b = <span class="number">10</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>咦？a和b是兩個不同的變數呀，為何他們的id會相同呢？<br>我們說過，Python的任何variable都是C++的Object，int也不例外，然而為了提升性能，C++把常用的數字-5到256是先定義好，作為cache使用，當Python需要時，直接從這個pool拿去引用，於是乎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">257</span></span><br><span class="line">&gt;&gt; b = <span class="number">257</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>有興趣的讀者可以試試<br>再來，我們來探討<code>==</code>和<code>is</code>性能的部分<br>通常，<code>is</code>會比<code>==</code>快很多，因為<code>is</code>不會被overload，這樣Python就不需要去尋找<code>__eq__</code>，<code>a == b</code>實際上做的事情等同於<code>a.__eq__(b)</code></p><h4 id="copy語法">copy語法</h4><p>所謂的copy，指的是重新分配一塊記憶體，創建一個新的Object，所以他們的id肯定是不同的，而copy又分shallow copy和deep copy<br>所謂的shallow copy，新的Object裡面的元素是原本Object裡面元素的引用，所以如果Object裡面的Object被改了，新舊Object都會被連動，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>可以看到variable b append 4之後，a裡面的list也被影響了<br>而deep copy，相對於shadow copy來說，會遞迴的方式往裡面一直copy，所以新的Object和舊的Object沒有任何關聯<br>Python中透過copy.deepcopy(object)實現deep copy，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>我們可以看到a不受任何影響即使b append了4<br>最後我們再來探討mutable(可變) Object和unmutable(不可變) object，看一下下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>我們可以看到，a+=1後竟然沒有影響b，不是說Python一切variable皆是object嗎？<br>這是因為在Python中int, float, string, tuple等等屬於unmutable object，不能改object裡面的值，我們可以看到a+=1之後，a的id變了，代表他被重新賦予新的object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809328</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809168</span></span><br></pre></td></tr></table></figure><p>而dict, array, set等等，屬於mutable object，在assign或是當作參數傳進去function的時候，會影響該variable</p><h3 id="總結">總結</h3><p>這篇文章講了Python的variable怎麼做比較和複製</p><ul><li>Python的一切皆為Object，所以比較和複製的思維可以參考C++</li><li>Object間的比較分成address和value的比較，分別為<code>is</code>和<code>==</code></li><li>Object間的複製分成shallow和deep copy，一個只複製了第一層的value，另一個會遞迴複製</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object-storage/"/>
      <url>/2021/09/13/object-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="object-storage(物件儲存)">Object storage(物件儲存)</h3><p>Object Storage - 雲端系統上最流行的儲存方式</p><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合，這種方式變得更容易索引和訪問。</p><span id="more"></span><p>Metadata的部分，他不像File system是固定的inode資料結構，Object storage可以隨意定義自己的metadata資料結構，幫助快速檢索目標object。</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務。</p><p>從high level講，也就是使用方式講，Object storage是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用。這些Object實際上可以是任何類型的資料：PDF、影片、音檔、文本、網站資料或任何其他檔案類型。</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要資料分散且&quot;容易&quot;伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個&quot;資料夾&quot;加大了空間。</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的&quot;可靠性&quot;，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如Raid5這種空間使用率只要150%，但是保護力也有1。</p><h4 id="優點">優點</h4><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</li><li><strong>成本低</strong>：<br>公有雲端上的Object storage都特別便宜，例如Amazon S3</li><li><strong>API 簡單</strong>:<br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</li></ul><h4 id="缺點">缺點</h4><ul><li><strong>不能修改</strong>:<br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</li><li><strong>無法和database整合</strong>:<br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</li><li><strong>無法與一般作業系統整合</strong>:<br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file-storage/"/>
      <url>/2021/09/12/file-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="file-storage(檔案系統)">File storage(檔案系統)</h3><p>有了File storage，就能方便我們寫程式去操作資料！</p><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我們怎麼知道我的資料的Block存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好，如果是分散存，需要一個Linked-List資料結構去紀錄<br>任何架構的難題只需要加一層就可以解決，如果不行，那就兩層，為了讓人能夠輕鬆的操作儲存資料，作業系統在Block storage上面加了一層File system</p><span id="more"></span><p>我們平常用的Windows為了讓使用者方便存取資料，就是使用File system，這大家應該很熟悉，用滑鼠鍵盤敲一敲點一點就可以對檔案進行存取，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，檔案的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的地方就叫做inode</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><h3 id="作業系統是如何讀取檔案資料？">作業系統是如何讀取檔案資料？</h3><p>首先，不是透過檔案名字，文件名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，根據使用者點開的文件找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼。<br>第二，根據inode號碼找到inode的data。<br>最後，根據indoe的data，找到檔案裡的數據存在哪個block。</p><h4 id="優點">優點</h4><p>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他</li><li><strong>成本低</strong>：<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</li></ul><h4 id="缺點">缺點</h4><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</li><li><strong>難以遷移</strong>:<br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 檔案系統 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block-storage/"/>
      <url>/2021/09/05/block-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="block-storage(區塊儲存)">Block storage(區塊儲存)</h3><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p><p>資料在電腦裡是以1和0儲存在某個&quot;介質&quot;上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，也有用光的CD，而Block storage簡單來說就是我們能看到的一塊塊的硬碟和儲存裝置，我們把儲存裝置與我們的電腦連接，我們的電腦透過Block storage的API對裡面的資料進行增刪改查。</p><span id="more"></span><p>接下來，我們有了作業系統，作業系統他方便了我們把資料存進去Block storage裝置，可以說，作業系統是上層應用與Block storage裝置溝通的橋樑，那麼回答一個問題，作業系統是如何與硬碟打交道呢？首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也就是說多台主機能共享一個儲存設備，不過一般不會這麼用，因為Block storage的資料隔離沒有做得這麼好，若是同時寫入資料容易被混淆。</p><h3 id="block">Block</h3><p>為什麼叫做block呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，常見為4096 bytes，這樣的設定的用意是提升資料讀寫的速度，如果一個個byte寫，一來一往速度非常慢。我們也不需要連續的儲存這些Block，上層的作業系統會利用Linked-List資料結構把碎片化的Block記錄下來，把整段資料拼湊出來，一個block對應一個或多個硬體的扇區(sector)，常見的一個sector大小為512 bytes，所以block是給作業系統看的邏輯地址，sector是Block storage上的實體地址。Block大小可以透過作業系統設定，查詢藉由指令stat /boot/ |grep “IO Block” 查詢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat /boot/ |grep &quot;IO Block&quot;</span></span><br><span class="line">  Size: <span class="number">4096</span>      Blocks: <span class="number">8</span>          IO Block: <span class="number">4096</span>   directory</span><br></pre></td></tr></table></figure><h3 id="sector(扇區)">Sector(扇區)</h3><p>sector是Block storage上的實體地址，他也是把多個bytes分組成一個sector，我們拿機械式硬碟HDD舉例，HDD有個針頭會去掃描磁碟，掃描的部分就是一個個扇區，如下圖所示<br><img src="/images/sector.png" alt=""><br>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的&quot;扇區&quot;就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點</p><h4 id="優點">優點</h4><p>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><strong>高性能</strong>:<br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作公司的database server或數據中心</li><li><strong>易於修改</strong>:<br>如果想改變block裡的一個小部分資料，直接改那個block就可以，如果是檔案系統或object system，需要整個檔案或object都改</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個LUN ID就可以接上系統了，適合用在SAN(儲存區域網路)裡</li></ul><h4 id="缺點">缺點</h4><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</li><li><strong>Metadata</strong>:<br>Block storage沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
