<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Go] Interface: 為什麼nil接口不等於nil?</title>
      <link href="/2024/02/08/golang/interface_nil/"/>
      <url>/2024/02/08/golang/interface_nil/</url>
      
        <content type="html"><![CDATA[<p>Interface 是 Go 這門靜態語言中具有「動靜兼備」特性的語法元素。它既展示了 Go 的強大表達能力，也經常讓初學者感到迷惑。為了釐清這些迷惑，本文將深入探討 Go 在 runtime 時是如何處理 Interface 的類型表現。</p><p>在我們揭開 Interface 的神秘面紗之前，先來理解其「動靜兼備」的特性究竟是什麼。</p><h3 id="接口的靜態與動態特性"><a href="#接口的靜態與動態特性" class="headerlink" title="接口的靜態與動態特性"></a>接口的靜態與動態特性</h3><p>接口的靜態特性主要是指接口類型變數有其靜態類型，例如在 <code>var err error</code> 中，<code>err</code> 的靜態類型為 <code>error</code>。有了這樣的靜態類型，編譯器在編譯階段對所有接口類型變數的賦值進行類型檢查，確保賦值操作的右值實現了該接口的所有方法，否則會報錯：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span> = <span class="number">1</span> <span class="comment">// cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method)</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>接口的動態特性則顯示在接口類型變數在 runtime 中儲存了右值的真實類型，這種特性讓 Go 的接口變數具有類似動態語言的靈活性，如 Python 的 Duck Typing。這種類型的特性不是由其繼承關係決定的，而是由類型表現出來的行為決定的。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">err = errors.New(<span class="string">&quot;error1&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, err)  <span class="comment">// *errors.errorString</span></span><br></pre></td></tr></table></figure><p>在這裡，我們通過 <code>errors.New</code> 創建了一個錯誤值並賦值給 <code>error</code> 類型的接口變數 <code>err</code>，通過 <code>fmt.Printf</code> 輸出了 <code>err</code> 的動態類型為 <code>*errors.errorString</code>。</p><p>這種「動靜兼備」的特性具體好處包括：</p><ul><li>程序在 runtime 可以將接口類型變數賦值為不同的動態類型，增加了語言的靈活性。</li><li>接口的動態特性還保障了使用時的安全性，如編譯器能在編譯期捕捉到錯誤的賦值。</li></ul><h3 id="nil-error-值不等於-nil-的疑惑"><a href="#nil-error-值不等於-nil-的疑惑" class="headerlink" title="nil error 值不等於 nil 的疑惑"></a>nil error 值不等於 nil 的疑惑</h3><p>這裡我們通過一個範例來探討常見的疑惑 —— 「nil 的 error 值不等於 nil」。讓我們看下這段程式碼：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrBad = MyError&#123;</span><br><span class="line">    <span class="type">error</span>: errors.New(<span class="string">&quot;bad things happened&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bad</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnsError</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *MyError = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> bad() &#123;</span><br><span class="line">        p = &amp;ErrBad</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := returnsError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;error occur: %+v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這個例子中，<code>returnsError</code> 函數返回的是 <code>error</code> 接口類型的變數 <code>err</code>，即使其動態類型 <code>p</code> 為 <code>nil</code>，<code>err</code> 與 <code>nil</code> 進行比較時並不相等，這是因為接口變數的內部表示除了數據pointer，還包括了類型信息。</p><h3 id="接口類型變數的內部表示詳解"><a href="#接口類型變數的內部表示詳解" class="headerlink" title="接口類型變數的內部表示詳解"></a>接口類型變數的內部表示詳解</h3><p>在 Go 語言中，接口類型變數的內部表示是理解其動態行為的關鍵。接口類型變數在內部主要通過兩種結構表達：<code>eface</code> 和 <code>iface</code>。這兩種結構分別對應於不帶有Method的空接口和帶Method的接口。</p><h4 id="1-eface-結構：空接口的表示"><a href="#1-eface-結構：空接口的表示" class="headerlink" title="1. eface 結構：空接口的表示"></a>1. <code>eface</code> 結構：空接口的表示</h4><ul><li><strong>用途</strong>：用於表示空接口 <code>interface&#123;&#125;</code>，這種接口不包含任何方法。</li><li><strong>結構</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type         <span class="comment">// 表示動態類型的 `_type` 結構的pointer</span></span><br><span class="line">    data  unsafe.Pointer <span class="comment">// 實際數據的pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>功能</strong>：<code>_type</code> 指向一個描述數據的動態類型的結構，而 <code>data</code> pointer直接指向實際的數據。這個簡單的表示方式使得空接口能夠儲存任何類型的值。</li></ul><h4 id="2-iface-結構：帶方法的接口表示"><a href="#2-iface-結構：帶方法的接口表示" class="headerlink" title="2. iface 結構：帶方法的接口表示"></a>2. <code>iface</code> 結構：帶方法的接口表示</h4><ul><li><strong>用途</strong>：用於表示包含方法的接口。</li><li><strong>結構</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab           <span class="comment">// 指向 `itab` 結構，包含類型信息和方法pointer</span></span><br><span class="line">    data unsafe.Pointer  <span class="comment">// 指向實際數據的pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>功能</strong>：<code>tab</code> 指向的 <code>itab</code> 結構不僅保存了接口的動態類型信息，還包括了指向實現接口方法的函數pointer。這使得 Go 在執行時能夠通過接口調用具體類型的方法。</li></ul><h4 id="內部實現的影響"><a href="#內部實現的影響" class="headerlink" title="內部實現的影響"></a>內部實現的影響</h4><ul><li><strong>比較行為</strong>：當兩個接口變數進行比較時，Go 不僅比較 <code>data</code> pointer，還要比較他們的類型pointer（<code>eface._type</code> 或 <code>iface.tab._type</code>）。只有當這兩部分都相同時，兩個接口變數才視為相等。</li></ul><p>再回到開頭的問題，是不是已經豁然開朗了？<code>returnsError</code> 函數返回的 <code>error</code> 接口類型變數 <code>err</code> 的數據pointer雖然為空，但其類型（<code>iface.tab</code>）不為空，而是 <code>*MyError</code> 對應的類型，這樣 <code>err</code> 與 <code>nil</code>（0x0, 0x0）相比自然不相等，這就是問題的答案。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>接口的靜態特性</strong>：保障了類型的正確性和編譯期的類型檢查。</li><li><strong>接口的動態特性</strong>：提供了如動態語言般的靈活使用方式。</li><li><strong>nil 的 error 值問題</strong>：揭示了接口類型變數的內部複雜性，說明了為何 <code>nil</code> 的 <code>error</code> 值在某些情況下不等於 <code>nil</code>。<br>通過深入理解這些內部結構和行為，Go 開發者可以更好地掌握接口的使用規則，避免一些常見的錯誤，尤其是在處理接口和 nil 值比較時的特殊行為。</li></ul><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Interface即類型的使用定義</title>
      <link href="/2024/01/31/golang/go_interface/"/>
      <url>/2024/01/31/golang/go_interface/</url>
      
        <content type="html"><![CDATA[<p>在 Go 語言中，<code>interface</code> 是一組方法的集合，透過 <code>type</code> 和 <code>interface</code> 關鍵字來定義。這些方法的集合唯一確定了這個 <code>interface</code> 類型所表示的契約。讓我們來看看一個典型的 <code>interface</code> 類型 <code>MyInterface</code> 的定義：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1(<span class="type">int</span>) <span class="type">error</span></span><br><span class="line">    M2(io.Writer, ...<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從這個定義中，我們可以看到，<code>interface</code> 類型 <code>MyInterface</code> 包含了兩個方法：<code>M1</code> 和 <code>M2</code>。Go 語言要求 <code>interface</code> 類型聲明中的方法必須是具名的，並且方法名字在這個 <code>interface</code> 類型的方法集合中必須唯一。從 Go 1.14 版本開始，Go 允許嵌入的不同 <code>interface</code> 類型的方法集合存在交集，但前提是交集中的方法不僅名字一樣，連方法簽名（參數列表和返回值列表）也必須一致，否則 Go 編譯器會報錯。</p><p>例如，以下示例中 <code>Interface3</code> 嵌入了 <code>Interface1</code> 和 <code>Interface2</code>，但它們之間的 <code>M1</code> 方法簽名不同，導致編譯出錯：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Interface2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1(<span class="type">string</span>) </span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Interface1</span><br><span class="line">    Interface2 <span class="comment">// 編譯器報錯：duplicate method M1</span></span><br><span class="line">    M3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>Go 語言也可以定義空 <code>interface</code> 類型，代表沒有定義任何方法集合的 <code>interface</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EmptyInterface <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果一個變數的類型是空 <code>interface</code> 類型，由於空 <code>interface</code> 類型的方法集合為空，這意味著<strong>任何類型都實現了空 <code>interface</code> 的方法集合</strong>。所以我們可以將任何類型的值賦值給空 <code>interface</code> 類型的變數。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">15</span> <span class="comment">// ok</span></span><br><span class="line">i = <span class="string">&quot;hello, golang&quot;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">i = t  <span class="comment">// ok</span></span><br><span class="line">i = &amp;t <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>空 <code>interface</code> 類型能夠接受任意類型變數值，使它成為 Go 在引入泛型之前唯一具備“泛型”能力的語法元素。包括 Go 標準庫在內的一些通用資料結構與算法的實現，都使用了空 <code>interface</code> <code>interface&#123;&#125;</code> 作為參數元素的類型，這樣我們就無需為每種支持的元素類型單獨編寫程式碼或方法。</p><p>Go 語言還支持從 <code>interface</code> 類型變數“還原”其右值的類型與值信息，這個過程稱為“Type Assertion”。Type Assertion 通常使用以下語法形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := i.(T) </span><br></pre></td></tr></table></figure><p>其中 <code>i</code> 是某個 <code>interface</code> 類型變數。如果 <code>T</code> 是一個非 <code>interface</code> 類型且 <code>T</code> 是想要還原的類型，這句程式碼的含義是“斷言”儲存在 <code>interface</code> 類型變數 <code>i</code> 中的值的類型為 <code>T</code>。</p><p>如果 <code>interface</code> 類型變數 <code>i</code> 之前被賦予的值確為 <code>T</code> 類型的值，這個語句執行後，左側 <code>comma, ok</code> 語句中的變數 <code>ok</code> 的值將為 <code>true</code>，變數 <code>v</code> 的類型為 <code>T</code>，其值為之前賦予給 <code>i</code> 的值。如果 <code>i</code> 之前被賦予的值不是 <code>T</code> 類型，這個語句執行後，變數 <code>ok</code> 的值為 <code>false</code>，變數 <code>v</code> 的類型仍然是 <code>T</code>，但其值是類型 <code>T</code> 的初始值。</p><p>好了，到這裡關於 <code>interface</code> 類型的基礎語法我們已經全部講完了。有了這個基礎後，我們再來看看 Go 語言 <code>interface</code> 定義的慣例，也就是盡量定義“小 <code>interface</code>”。</p><h3 id="盡量定義“小-interface”"><a href="#盡量定義“小-interface”" class="headerlink" title="盡量定義“小 interface”"></a>盡量定義“小 <code>interface</code>”</h3><p><code>interface</code> 類型的背後，是透過將類型的行為抽象成契約，建立雙方共同遵守的約定，從而降低耦合度。和生活中的契約有繁有簡、形式多樣一樣，程式碼間的契約也有大小之分。而 Go 選擇了簡單的形式，主要體現在以下兩點上：</p><h4 id="隱式契約，無需顯示，立即生效"><a href="#隱式契約，無需顯示，立即生效" class="headerlink" title="隱式契約，無需顯示，立即生效"></a>隱式契約，無需顯示，立即生效</h4><p>在 Go 語言中，<code>interface</code> 類型與其實現者之間的關係是隱式的，不需要像其他語言（如 Java）那樣要求實現者顯式聲明 <code>implements</code>。實現者只需要實現 <code>interface</code> 方法集合中的全部方法，便自動生效。</p><h4 id="更傾向於“小契約”"><a href="#更傾向於“小契約”" class="headerlink" title="更傾向於“小契約”"></a>更傾向於“小契約”</h4><p>這點也不難理解。若契約太繁雜，就會束縛手腳，缺少靈活性。因此 Go 選擇了“小契約”，表現在程式碼上就是盡量定義小 <code>interface</code>，即方法個數在 1~3 個之間的 <code>interface</code>。Go 語言之父 Rob Pike 曾說過，“<code>interface</code> 越大，抽象程度越弱”，這也是 Go 社群傾向於定義小 <code>interface</code> 的原因之一。</p><h5 id="小-interface-的優點"><a href="#小-interface-的優點" class="headerlink" title="小 interface 的優點"></a>小 <code>interface</code> 的優點</h5><ul><li><strong><code>interface</code> 越小，抽象程度越高</strong><br>抽象程度越高，對應的集合空間就越大；抽象程度越低，也就是越具像化，更接近事物真實面貌，對應的集合空間越小。</li><li><strong>小 <code>interface</code> 易於實現和測試</strong><br>小<code>interface</code>擁有較少的Method，一般情況下只有一個Method。所以要想滿足這一<code>interface</code>，我們只需要實現一個Method或者少數幾個Method就可以了，這顯然要比實現擁有較多Method的<code>interface</code>要容易得多。尤其是在單元測試環節，構建類型去實現只有少量Method的<code>interface</code>要比實現擁有較多Method的<code>interface</code>付出的勞動要少許多。</li><li><strong>小 <code>interface</code> 表示職責單一，易於複用和組合</strong><br>寫程式時，如果有眾多候選<code>interface</code>類型供我們選擇，我們會怎麼選擇呢？顯然，我們會選擇那些新<code>interface</code>類型需要的契約職責，同時也要求不要引入我們不需要的契約職責。在這樣的情況下，擁有單一或少數Method的小<code>interface</code>便更有可能成為我們的目標，而那些擁有較多Method的大<code>interface</code>，可能會因引入了諸多不需要的契約職責而被放棄。由此可見，小<code>interface</code>更契合 Go 的組合思想，也更容易發揮出組合的威力。</li></ul><h3 id="如何定義小-interface"><a href="#如何定義小-interface" class="headerlink" title="如何定義小 interface"></a>如何定義小 <code>interface</code></h3><p>保持簡單有時比複雜更難。小 <code>interface</code> 雖好，但如何定義出小 <code>interface</code> 是每個 Gopher 面前的一道難題。雖然這道題沒有標準答案，但有一些建議可供參考：</p><ol><li><strong>首先，先抽象出 <code>interface</code>，不管大小</strong>：在定義小 <code>interface</code> 之前，我們需要深入理解問題領域，聚焦抽象並發現 <code>interface</code>。初期，先不要介意 <code>interface</code> 裡的方法數量，因為對問題域的理解是循序漸進的。在第一版程式碼中直接定義出小 <code>interface</code> 可能不現實。例如，標準庫中的 <code>io.Reader</code> 和 <code>io.Writer</code> 也不是 Go 剛誕生時就有的，而是在發現對網路、文件、其他資料處理的實現十分相似後才抽象出來的。</li><li>**將大 <code>interface</code> 拆分為小 <code>interface</code>**：有了 <code>interface</code> 後，我們會在程式碼中各處使用 <code>interface</code>。一段時間後，分析哪些場合使用了 <code>interface</code> 的哪些方法，是否可以將這些方法提取出來，放入一個新的小 <code>interface</code> 中。</li><li><strong>注意 <code>interface</code> 的單一職責</strong>：被拆分成的小 <code>interface</code> 是否需要進一步拆分，以滿足單一職責原則，如同 <code>io.Reader</code> 一樣。如果需要，就進一步拆分，提升抽象程度。</li></ol><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong><code>interface</code> 是方法的集合</strong>：用來定義類型的行為契約。</li><li><strong>Go 中的 <code>interface</code> 是隱式實現的</strong>：不需要顯式聲明 <code>implements</code>。</li><li><strong>小 <code>interface</code> 更具靈活性和複用性</strong>：方法數量在 1~3 個之間。</li><li>**將大 <code>interface</code> 拆分為小 <code>interface</code>**：聚焦單一職責，提升抽象程度，符合高內聚、低耦合的精神。</li></ul><p>這些建議和技巧將幫助你在 Go 語言中有效地使用 <code>interface</code>，寫出更具高內聚、低耦合的程式碼。</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Method: 怎麼用變數模擬繼承</title>
      <link href="/2024/01/23/golang/go_inherit/"/>
      <url>/2024/01/23/golang/go_inherit/</url>
      
        <content type="html"><![CDATA[<h3 id="Go-語言的繼承與組合"><a href="#Go-語言的繼承與組合" class="headerlink" title="Go 語言的繼承與組合"></a>Go 語言的繼承與組合</h3><p>Go 語言沒有像 C++/Java 等語言可以透過 <code>extend</code> 關鍵字來繼承某個 class。因此，Go class的所有方法都是自己顯式實現的。讓我們舉個例子，自定義class <code>T</code> 有兩個methods <code>M1</code> 和 <code>M2</code>，如果 <code>T</code> 是一個獨立的自定義class，那我們在聲明class <code>T</code> 的 Go 包原始碼文件中一定可以找到其所有method的實現程式碼，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M1() &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M2() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在 Go 語言中，如果我們真的想模擬繼承的效果，可以透過 Go 語言設計思想的“組合”來實現。具體的 Go 語言設計思想可以參考我的這篇文章 - <a href="../../../../../2023/12/12/golang/design_philosophy/">Go語言的設計哲學</a></p><span id="more"></span><p>這種“繼承”是通過 Go 語言的類型嵌入（Type Embedding）來實現的。因此，這篇文章將帶你了解這種語法，看看我們如何通過這種語法來實現對嵌入類型的方法的“繼承”，同時也搞清楚這種方式對新定義的類型的方法集合的影響。首先，我們來學習一下什麼是類型嵌入。</p><h3 id="類型嵌入"><a href="#類型嵌入" class="headerlink" title="類型嵌入"></a>類型嵌入</h3><p>類型嵌入指的是在一個類型的定義中嵌入了其他類型。Go 語言支持兩種類型嵌入，分別是 <code>interface</code> 類型的類型嵌入和 <code>struct</code> 類型的類型嵌入。</p><h4 id="interface-類型的類型嵌入"><a href="#interface-類型的類型嵌入" class="headerlink" title="interface 類型的類型嵌入"></a>interface 類型的類型嵌入</h4><p>interface類型聲明了由一個方法集合代表的interface，比如下面interface類型 <code>E</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> E <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們再定義另外一個interface類型 <code>I</code>，它的方法集合中包含了三個方法 <code>M1</code>、<code>M2</code> 和 <code>M3</code>，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">    M3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們看到interface類型 <code>I</code> 方法集合中的 <code>M1</code> 和 <code>M2</code>，與接口類型 <code>E</code> 的方法集合中的方法完全相同。在這種情況下，我們可以用interface類型 <code>E</code> 替代上面interface類型 <code>I</code> 定義中的 <code>M1</code> 和 <code>M2</code>，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    E</span><br><span class="line">    M3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這種在一個interface類型（<code>I</code>）定義中嵌入另外一個interface類型（<code>E</code>）的方式，就是我們說的interface類型的<strong>類型嵌入</strong>。</p><h4 id="struct-類型的類型嵌入"><a href="#struct-類型的類型嵌入" class="headerlink" title="struct 類型的類型嵌入"></a>struct 類型的類型嵌入</h4><p><code>struct</code> 類型的類型嵌入就要更複雜一些了，以下是 Go struct類型的“完全體”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> t2 <span class="keyword">struct</span>&#123;</span><br><span class="line">    n <span class="type">int</span></span><br><span class="line">    m <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    T1</span><br><span class="line">    *t2</span><br><span class="line">    I            </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們看到，struct <code>S1</code> 定義中有三個“非常規形式”的attribute，分別是 <code>T1</code>、<code>t2</code> 和 <code>I</code>。這三個struct裡的attribute究竟代表的是什麼呢？是名字還是類型呢？</p><p>這裡我直接告訴你答案：它們既代表attribute的名字，也代表attribute的類型。我們分別以這三個attribute為例，說明一下它們的具體含義：</p><ul><li><code>T1</code> 表示attribute名為 <code>T1</code>，它的類型為自定義類型 <code>T1</code>；</li><li><code>t2</code> 表示attribute名為 <code>t2</code>，它的類型為自定義struct類型 <code>t2</code> 的pointer類型；</li><li><code>I</code> 表示attribute名為 <code>I</code>，它的類型為interface類型 <code>I</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *MyInt)</span></span> Add(m <span class="type">int</span>) &#123;</span><br><span class="line">    *n = *n + MyInt(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    *MyInt</span><br><span class="line">    t</span><br><span class="line">    io.Reader</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">    n <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := MyInt(<span class="number">17</span>)</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;hello, go&quot;</span>)</span><br><span class="line">    s := S&#123;</span><br><span class="line">        MyInt: &amp;m,</span><br><span class="line">        t: t&#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            b: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Reader: r,</span><br><span class="line">        s:      <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sl = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(<span class="string">&quot;hello, go&quot;</span>))</span><br><span class="line">    s.Read(sl)              <span class="comment">// 等同於 s.Reader.Read(sl)</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(sl)) <span class="comment">// 輸出：hello, go</span></span><br><span class="line">    s.Add(<span class="number">5</span>) </span><br><span class="line">    fmt.Println(*(s.MyInt)) <span class="comment">// 輸出：22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到這段程式碼，你可能會問：類型 <code>S</code> 沒有定義 <code>Read</code> 方法和 <code>Add</code> 方法啊，這樣寫不會導致 Go 編譯器報錯嗎？如果你有這個疑問，可以暫停一下，先用你手上的 Go 編譯器編譯運行一下這段程式碼看看。</p><p>是不是很驚喜？這段程序不但沒有引發編譯器報錯，還可以正常運行並輸出正確的結果！</p><p>這段程式碼似乎在告訴我們：<code>Read</code> 方法和 <code>Add</code> 方法就是類型 <code>S</code> 方法集合中的方法。其實，這兩個方法來自於struct類型 <code>S</code> 的兩個嵌入attribute <code>Reader</code> 和 <code>MyInt</code>。struct類型 <code>S</code> “繼承”了 <code>Reader</code> attribute的方法 <code>Read</code> 的實現，也“繼承”了 <code>*MyInt</code> 的 <code>Add</code> 方法的實現。注意，我這裡的“繼承”用了引號，說明這並不是真正的繼承，而是 Go 語言的一種“障眼法”。</p><p>這種“障眼法”的工作機制是這樣的：當我們通過struct類型 <code>S</code> 的變量 <code>s</code> 呼叫 <code>Read</code> 方法時，Go 發現struct類型 <code>S</code> 自身並沒有定義 <code>Read</code> 方法，於是 Go 會查看 <code>S</code> 的嵌入attribute對應的類型是否定義了 <code>Read</code> 方法。這時，<code>Reader</code> attribute就被找了出來，之後 <code>s.Read</code> 的呼叫就被轉換為 <code>s.Reader.Read</code> 的呼叫。</p><p>這樣一來，嵌入attribute <code>Reader</code> 的 <code>Read</code> 方法就被提升為 <code>S</code> 的方法，放入了類型 <code>S</code> 的方法集合。同理，<code>*MyInt</code> 的 <code>Add</code> 方法也被提升為 <code>S</code> 的方法而放入 <code>S</code> 的方法集合。從外部來看，這種嵌入attribute的方法的提升就給了我們一種struct類型 <code>S</code> “繼承”了 <code>io.Reader</code> 類型 <code>Read</code> 方法的實現，以及 <code>*MyInt</code> 類型 <code>Add</code> 方法的實現的錯覺。嵌入attribute的使用的確可以幫我們在 Go 中實現方法的“繼承”。</p><h3 id="多重繼承"><a href="#多重繼承" class="headerlink" title="多重繼承"></a>多重繼承</h3><p>不過有一種情況需要注意，那就是當struct嵌入的多個接口類型的方法集合存在交集時，你要小心編譯器可能會出現的錯誤提示。</p><p>Go 1.14 版本解決了嵌入接口類型的方法集合有交集的情況，僅限於interface類型中嵌入interface類型。這裡我們討論的是在struct類型中嵌入方法集合有交集的interface類型。</p><p>如果struct自身實現了該方法，Go 就會優先使用struct自己實現的方法。如果沒有實現，那麼 Go 就會查找struct中的嵌入attribute的方法集合中是否包含這個方法。如果多個嵌入attribute的方法集合中都包含這個方法，那麼我們就說方法集合存在交集。這時，Go 編譯器就會因無法確定究竟使用哪個方法而報錯，所以 Go 會在編譯階段就限制多重繼承的問題。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>Go 語言沒有傳統意義上的繼承，所有方法都必須顯式實現。</li><li>可以通過類型嵌入（Type Embedding）來模擬繼承的效果，將嵌入類型的方法提升為新類型的方法。</li><li><code>interface</code> 和 <code>struct</code> 都支持類型嵌入。</li><li>使用嵌入attribute到class的方法提升機制，可以實現方法的“繼承”，但需注意多重繼承的衝突問題。</li></ul><p>這些技巧和知識將幫助你在 Go 語言中有效地使用組合和嵌入，編寫出更靈活且可維護的程式碼。</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Method: Method與如何選擇Receiver類型</title>
      <link href="/2024/01/17/golang/method_receiver/"/>
      <url>/2024/01/17/golang/method_receiver/</url>
      
        <content type="html"><![CDATA[<p>和多數程式語言一樣，在 Go 語言中，我們需要考慮如何設計方法。由於在 Go 語言中，方法本質上就是函數，所以我們之前講解的關於函數設計的內容同樣適用於方法，例如錯誤處理設計、針對異常的處理策略、使用 <code>defer</code> 提升簡潔性，等等。</p><p>Receiver（Receiver）也是設計方法時需要考量的一點。Receiver定義了一個Method所屬的類型，有點類似於其他語言中的 class 或 object 的概念，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面範例中的 <code>t</code> 就是Receiver，而 <code>M1</code> 和 <code>M2</code> 是Receiver定義的Method。<code>M1</code> 方法代表Receiver類型為 <code>T</code> 的Method，而 <code>M2</code> 方法則代表Receiver類型為 <code>*T</code> 的Method。下面我們來看看不同的Receiver類型對 <code>M1</code> 和 <code>M2</code> 的影響。</p><span id="more"></span><h3 id="當Receiver類型為-T-時"><a href="#當Receiver類型為-T-時" class="headerlink" title="當Receiver類型為 T 時:"></a>當Receiver類型為 <code>T</code> 時:</h3><p>代表 <code>T</code> 類型Object的Receiver參數以pass by value傳遞到 <code>M1</code> 方法中，實際上是 <code>T</code> 類型Object的副本，因此 <code>M1</code> 方法中對副本的任何修改操作，都不會影響原 <code>T</code> 類型Object。</p><h3 id="當Receiver類型為-T-時-1"><a href="#當Receiver類型為-T-時-1" class="headerlink" title="當Receiver類型為 *T 時:"></a>當Receiver類型為 <code>*T</code> 時:</h3><p>代表 <code>*T</code> 類型實例的Receiver參數以pass by reference傳遞到 <code>M2</code> 方法中，實際上是 <code>T</code> 類型Object的地址，因此 <code>M2</code> 方法可以通過該address對原 <code>T</code> 類型Object進行修改操作。</p><p>我們來看看一個更直觀的範例，來證明上述分析結果，並觀察 Go 方法選擇不同的Receiver類型對原類型Object的影響：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;</span><br><span class="line">    t.a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;</span><br><span class="line">    t.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="built_in">println</span>(t.a) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    t.M1()</span><br><span class="line">    <span class="built_in">println</span>(t.a) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    p := &amp;t</span><br><span class="line">    p.M2()</span><br><span class="line">    <span class="built_in">println</span>(t.a) <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這個範例中，我們為類型 <code>T</code> 定義了兩個Method - <code>M1</code> 和 <code>M2</code>，其中 <code>M1</code> 的Receiver類型為 <code>T</code>，而 <code>M2</code> 的Receiver類型為 <code>*T</code>。<code>M1</code> 和 <code>M2</code> 方法都通過Receiver參數 <code>t</code> 修改了 <code>t</code> 的attribute - <code>a</code>。</p><p>了解了不同Receiver類型對 Go 方法的影響後，我們可以總結一下，日常寫程式中選擇Receiver參數類型時可以參考的原則：</p><ol><li><strong>如果 Go 方法需要修改Receiver代表的類型Object，並將修改反映到原類型Object上，應選擇 <code>*T</code> 作為Receiver參數類型。</strong></li><li><strong>如果Receiver的 size 太大，應選擇 <code>*T</code> 作為Receiver參數類型，以避免複製大Object。</strong></li><li><strong>如果需要縮小外部接觸面，盡量少暴露可以修改內部型態的方法，可以考慮使用 <code>T</code> 作為Receiver。</strong></li><li><strong>T 類型是否需要實作某個interface</strong>：<br>如果 <code>T</code> 類型需要實作某個interface，那我們就要使用 <code>T</code> 作為Receiver參數類型，以滿足interface類型方法集合中的所有Method。如果 <code>T</code> 不需要實作某個interface，但 <code>*T</code> 需要實作該interface，則 <code>*T</code> 的方法集合包含 <code>T</code> 的方法集合。因此，我們在確定 Go 方法的Receiver類型時，可以參考上述原則。</li></ol><p>這裡可以解釋一下什麼是<strong>方法集合</strong>，我們先通過一個範例來直觀了解為什麼要有方法集合，以及它主要用來解決什麼問題：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt *T</span><br><span class="line">    <span class="keyword">var</span> i Interface</span><br><span class="line"></span><br><span class="line">    i = pt</span><br><span class="line">    i = t <span class="comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>運行這個範例程式，我們在 <code>i = t</code> 這一行會得到 Go 編譯器的錯誤提示，Go 編譯器提示我們：<code>T</code> 沒有實作 <code>Interface</code> 類型方法列表中的 <code>M2</code>，因此類型 <code>T</code> 的Object <code>t</code> 不能賦值給 <code>Interface</code> 變量。</p><p>Interface類型相對特殊，它只會列出代表interface的方法列表，不會具體定義某個方法，類似C++的virtual和Java的interface，其方法集合就是<strong>它的方法列表中的所有方法</strong>，我們可以一目了然地看到。因此，我們下面重點講解的是非interface類型的方法集合。</p><p>為了方便查看一個非interface類型的方法集合，我這裡提供了一個函數 <code>dumpMethodSet</code>，用於輸出一個非interface類型的方法集合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dumpMethodSet</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    dynTyp := reflect.TypeOf(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dynTyp == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;there is no dynamic type\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := dynTyp.NumMethod()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, dynTyp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&#x27;s method set:\n&quot;</span>, dynTyp)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-&quot;</span>, dynTyp.Method(j).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我們利用這個函數，試著輸出一下 Go 原生類型以及自定義類型的方法集合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M1() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> M3() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> M4() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    dumpMethodSet(n)</span><br><span class="line">    dumpMethodSet(&amp;n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    dumpMethodSet(t)</span><br><span class="line">    dumpMethodSet(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們得到如下結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int&#x27;s method set is empty!</span><br><span class="line">*int&#x27;s method set is empty!</span><br><span class="line">main.T&#x27;s method set:</span><br><span class="line">- M1</span><br><span class="line">- M2</span><br><span class="line"></span><br><span class="line">*main.T&#x27;s method set:</span><br><span class="line">- M1</span><br><span class="line">- M2</span><br><span class="line">- M3</span><br><span class="line">- M4</span><br></pre></td></tr></table></figure><p>我們看到以 <code>int</code> 和 <code>*int</code> 為代表的 Go 原生類型，由於沒有定義Method，所以它們的方法集合都是空的。自定義類型 <code>T</code> 定義了方法 <code>M1</code> 和 <code>M2</code>，因此其方法集合包含了 <code>M1</code> 和 <code>M2</code>，也符合我們的預期。然而，<code>*T</code> 的方法集合中除了預期的 <code>M3</code> 和 <code>M4</code> 外，還包含了類型 <code>T</code> 的方法 <code>M1</code> 和 <code>M2</code>！</p><p>這是因為，Go 語言規定，**<code>*T</code> 類型的方法集合包含所有以 <code>*T</code> 為Receiver參數類型的方法，以及所有以 <code>T</code> 為Receiver參數類型的方法**。這就是為何 <code>*T</code> 類型的方法集合包含四個方法的原因，以及第一個範例會報錯的原因。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>Receiver類型為 <code>T</code> 時</strong>：方法Receiver是一個值，任何修改都不會影響原Object。</li><li><strong>Receiver類型為 <code>*T</code> 時</strong>：方法Receiver是一個pointer，可以修改原Object。</li><li><strong>選擇Receiver類型的原則</strong>：<ul><li>如果需要修改原Object，使用 <code>*T</code>。</li><li>如果Receiver的 size 太大，使用 <code>*T</code>。</li><li>如果希望縮小外部接觸面，減少Method, Attribute暴露，使用 <code>T</code>。</li><li>根據是否需要實作Interface來決定使用 <code>T</code> 還是 <code>*T</code>。</li></ul></li></ul><p>這些原則可以幫助你在 Go 程式設計中做出更好的Method設計決策。</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Defer的妙用 - 跟蹤函數調用鏈</title>
      <link href="/2024/01/06/golang/defer/"/>
      <url>/2024/01/06/golang/defer/</url>
      
        <content type="html"><![CDATA[<p>在 Go 語言中，defer 關鍵字是一個強大而且實用的工具，能讓你更優雅地處理資源釋放和一些在函數結束前必須執行的清理工作。本文將通過生動的比喻和簡單的示例，幫助你理解 defer 的使用方法及其重要性。</p><h3 id="defer-是什麼？"><a href="#defer-是什麼？" class="headerlink" title="defer 是什麼？"></a>defer 是什麼？</h3><p>簡單來說，defer 是用來延遲執行一段程式碼，直到所在的函數即將返回時才執行。就像你在餐廳吃飯，最後才會付錢一樣，defer 讓你在程式的適當位置安排程式碼，但等到適當的時候才執行。</p><span id="more"></span><h3 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h3><p>使用 defer 非常簡單，只需在你要延遲執行的函數或表達式前面加上 defer 關鍵字即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Doing something...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果將是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start</span><br><span class="line">Doing something...</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>可以看到，defer 語句會在 main 函數即將返回前執行，無論函數中間發生了什麼。</p><h3 id="典型使用場景"><a href="#典型使用場景" class="headerlink" title="典型使用場景"></a>典型使用場景</h3><p>defer 最常見的使用場景是資源釋放，例如文件操作、網絡連接、資料庫連接等。以下是一個簡單的文件操作示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;example.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error opening file:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 延遲關閉文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假設這裡有一些讀取文件的操作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Reading file...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這個例子中，file.Close() 被延遲執行，確保無論 main 函數如何返回，文件都會被正確關閉，避免資源洩漏。</p><h3 id="延遲執行的捕捉"><a href="#延遲執行的捕捉" class="headerlink" title="延遲執行的捕捉"></a>延遲執行的捕捉</h3><p>你可以用 defer 來捕捉並處理異常，確保在異常情況下也能執行必要的清理工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Starting&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Something went wrong&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;This will not be printed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在這個例子中，recover 函數會捕捉到 panic，並且 defer 語句保證了即使發生異常，也能執行清理工作。</p><h3 id="多個-defer-語句"><a href="#多個-defer-語句" class="headerlink" title="多個 defer 語句"></a>多個 defer 語句</h3><p>如果你在一個函數中使用多個 defer 語句，它們會按照後進先出的順序執行（LIFO）。這就像你堆疊盤子，最後放上的盤子會最先被拿走。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Doing something...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果將是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Doing something...</span><br><span class="line">Third</span><br><span class="line">Second</span><br><span class="line">First</span><br></pre></td></tr></table></figure><h3 id="高效使用-defer"><a href="#高效使用-defer" class="headerlink" title="高效使用 defer"></a>高效使用 defer</h3><p>雖然 defer 是一個非常有用的工具，但它並非免費的。每次調用 defer 都會有一些額外的開銷，尤其是在高頻率調用的場景中。例如，在一個非常深的遞迴函數中頻繁使用 defer 可能會帶來性能問題。可以考慮在這種情況下使用顯式的資源管理方式來代替 defer。<br>以下是defer 的最佳實踐</p><ul><li>資源管理：defer 非常適合用來管理資源的釋放，如文件、網路socket連接等。</li><li>錯誤處理：在需要進行清理操作的錯誤處理中使用 defer 確保資源被正確釋放。</li><li>讀取程式碼順序：在程式碼靠近資源分配的地方使用 defer，提高程式碼的可讀性和可維護性。</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>defer 是 Go 語言中一個簡單但強大的工具，可以讓你的程式更加優雅和可靠。無論是資源釋放、捕捉異常還是簡單的清理工作，defer 都能幫助你寫出更加整潔和易於維護的程式碼。</p><p>記得，像處理餐廳賬單一樣，把 defer 放在適當的位置，等到最後才執行，就能讓你的程式運行更加順暢！</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 搞清楚Go語言的生命週期</title>
      <link href="/2023/12/27/golang/go_runtime_cycle/"/>
      <url>/2023/12/27/golang/go_runtime_cycle/</url>
      
        <content type="html"><![CDATA[<p>在剛開始學習 Go 語言的時候，我們可能經常會遇到這樣一個問題：一個 Go 專案中有數十個 Go packages，每個package中又有若干常數、變數、各種函數和方法，那 Go 程式究竟是從哪裡開始執行的呢？後續的執行順序又是什麼樣的呢？</p><p>了解這門語言的執行次序，對我們寫出結構合理、邏輯清晰的程式大有助益。無論你使用的是哪種編程範式（Paradigm），過程式的、物件導向的、函數式的，還是其他編程範式，深入了解一下總歸是好的。</p><p>今天這篇文章，我就帶你來了解一下 Go 程式的執行次序，這樣在後續閱讀和理解 Go 程式碼的時候，你就好比擁有了“通往寶藏的地圖”，可以直接沿著 Go 程式碼執行次序這張“地圖”去閱讀和理解 Go 程式碼，不會在龐大的程式庫中迷失。</p><p>Go 程式由一系列 Go package組成，程式碼的執行也是在各個package之間跳轉。和其他語言一樣，Go 也擁有自己的執行入口 - <strong>main 函數</strong>。這篇文章我們就從 main 函數入手，逐步展開，最終帶你掌握 Go 程式的執行順序。</p><span id="more"></span><h3 id="main-main-函數：Go-應用的入口函數"><a href="#main-main-函數：Go-應用的入口函數" class="headerlink" title="main.main 函數：Go 應用的入口函數"></a>main.main 函數：Go 應用的入口函數</h3><p>Go 語言中有一個特殊的函數：main package中的 main 函數，也就是 main.main，它是所有 Go 可執行程式的用戶層執行邏輯的入口函數。Go 程式的執行邏輯，會在這個函數內按照它的調用順序展開。</p><p>入口函數 - main 的定義是這樣的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 執行程式邏輯</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你會發現，main 的定義非常簡單，沒有參數也沒有返回值。而且，Go 語言要求：可執行程式的 main package必須定義 main 函數，否則 Go 編譯器會報錯。在啟動了多個 Goroutine（Go 語言的輕量級userspace執行緒，後面的文章會詳細講解）的 Go 程式中，main.main 函數將在 Go 應用的主要的 Goroutine 中執行。main 函數返回就意味著整個 Go 程式的終結，而且你也不用管這個時候是否還有其他子 Goroutine 正在執行。</p><p>另外還值得我們注意的是，除了 main package外，其他package也可以擁有自己的名為 main 的函數或方法。但按照 Go 的可見性規則（小寫字母開頭的函數無法被導出），非 main package中自定義的 main 函數僅限於package內使用，就像下面程式碼這樣，這是一段在非 main package中定義 main 函數的程式碼：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main func for pkg1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，這裡 main 函數就主要是用來在package pkg1 內部使用的，它是沒法在package外使用的。</p><p>現在我們已經了解了 Go 應用的入口函數 main.main 的特性。不過對於 main package的 main 函數來說，你還需要明確一點，就是它雖然是用戶層邏輯的入口函數，但它卻不一定是Go程式第一個被執行的函數。這是為什麼呢？</p><p>這跟 Go 語言的另一個函數 init 有關。</p><h3 id="init-函數：Go-package的初始化函數"><a href="#init-函數：Go-package的初始化函數" class="headerlink" title="init 函數：Go package的初始化函數"></a>init 函數：Go package的初始化函數</h3><p>除了前面講過的 main.main 函數之外，Go 語言還有一個特殊函數，它就是用於進行package初始化的 init 函數。和 main.main 函數一樣，init 函數也是一個無參數無返回值的函數：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// package初始化邏輯</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不過對於 init 函數來說，我們還需要注意一點，就是在 Go 程式中我們不能顯式地調用 init，否則就會收到編譯錯誤，就像下面這個範例，它表示的手工顯式調用 init 函數的錯誤做法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init invoked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，在構建並運行上面這些範例程式碼之後，Go 編譯器會報下面這個錯誤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; go run call_init.go </span></span><br><span class="line">./call_init.go:10:2: undefined: init</span><br></pre></td></tr></table></figure><p>實際上，Go package可以擁有不止一個 init 函數，每個組成 Go package的 Go 原始檔(.go文件)中，也可以定義 init 函數。</p><p>所以說，在初始化 Go package時，Go 會按照一定的次序，逐一、順序地調用這個package的 init 函數。一般來說，先傳遞給 Go 編譯器的原始檔中的 init 函數，會先被執行；而同一個原始檔中的多個 init 函數，會按定義順序依次執行。</p><p>現在我們就知曉了 main.main 函數可能並不是第一個被執行的函數的原因。所以，當我們要在 main.main 函數執行之前，執行一些函數或語句的時候，我們只需要將它放入 init 函數中就可以了。</p><p>了解了這兩個函數的執行順序之後，我們現在就來整體地看看，一個 Go package的初始化是以何種次序和邏輯進行的。</p><h3 id="Go-package的初始化次序"><a href="#Go-package的初始化次序" class="headerlink" title="Go package的初始化次序"></a>Go package的初始化次序</h3><p>從程式邏輯結構角度來看，Go package是程式邏輯封裝的基本單位，每個package都可以理解為是一個“自治”的、封裝良好的、對外部暴露有限接口的基本單位。一個 Go 程式就是由一組package組成的，程式的初始化就是這些package的初始化。每個 Go package還會有自己所需的外部package、常數、變數、init 函數（其中 main package有 main 函數）等。</p><p>在這裡你要注意：<strong>我們在閱讀和理解程式碼的時候，需要知道這些元素在程式初始化過程中的初始化順序，這樣便於我們確定在某一行程式碼處這些元素的當前狀態。</strong><br>簡而言之，記住 Go package的初始化次序並不難，你只需要記住這三點就可以了：</p><ul><li>package按“深度優先DFS”的次序進行初始化；</li><li>每個package內按以“常數 -&gt; 變數 -&gt; init 函數”的順序進行初始化；</li><li>package內的多個 init 函數按出現次序進行自動調用。</li></ul><h3 id="init-函數的用途"><a href="#init-函數的用途" class="headerlink" title="init 函數的用途"></a>init 函數的用途</h3><p>其實，init 函數的這些常用用途，與 init 函數在 Go package初始化過程中的次序密不可分。我們前面講過，Go package初始化時，init 函數的初始化次序在變數之後，這給了開發人員在 init 函數中對package變數進行進一步檢查與操作的機會。</p><h4 id="1-重置package變數值和初始化"><a href="#1-重置package變數值和初始化" class="headerlink" title="1. 重置package變數值和初始化"></a>1. 重置package變數值和初始化</h4><p>初始化 package 內部會用到的各種變數</p><h4 id="2-在-init-函數中實現“註冊模式”"><a href="#2-在-init-函數中實現“註冊模式”" class="headerlink" title="2. 在 init 函數中實現“註冊模式”"></a>2. 在 init 函數中實現“註冊模式”</h4><p>為了讓你更好地理解，首先我們來看一段使用 lib/pq package連接 PostgreSQL 資料庫的程式碼範例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;user=pqgotest dbname=pqgotest sslmode=verify-full&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    age := <span class="number">21</span></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;SELECT name FROM users WHERE age = $1&quot;</span>, age)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是一段“神奇”的程式碼，你可以看到範例程式碼是以空導入的方式導入 lib/pq package的，main 函數中沒有使用 pq package的任何變數、函數或方法，這樣就實現了對 PostgreSQL 資料庫的訪問。而這一切的奧秘，全在 pq package的 init 函數中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sql.Register(<span class="string">&quot;postgres&quot;</span>, &amp;Driver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個奧秘就在，我們其實是利用了用空導入的方式導入 lib/pq package時產生的一個“副作用”，也就是 lib/pq package作為 main package的所需的Library，它的 init 函數會在 pq package初始化的時候得以執行。</p><p>這種通過在 init 函數中註冊自己的實現的模式，就有效降低了 Go package對外的直接暴露，尤其是package變數的暴露，從而避免了外部通過package變數對package狀態的改動。</p><p>另外，從標準庫 database/sql package的角度來看，這種“註冊模式”實質是一種工廠設計模式的實現，sql.Open 函數就是這個模式中的工廠方法，它根據外部傳入的驅動名稱“生產”出不同類別的資料庫instance。</p><p>現在我們了解了 init 函數的常見用途。init 函數之所以可以勝任這些工作，恰恰是因為它在 Go 應用初始化次序中的特殊“位次”，也就是 main 函數之前，常數和變數初始化之後。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p><strong>main 函數的特徵</strong></p><ul><li>Go 應用的用戶層入口函數</li></ul><p><strong>init 函數的特徵</strong></p><ul><li>執行順位排在package內其他語法元素(var, const)的後面；</li><li>每個 init 函數在整個 Go 程式生命週期內僅會被執行一次；</li><li>init 函數是順序執行的，只有當一個 init 函數執行完畢後，才會去執行下一個 init 函數。</li></ul><p>大多 Go 程式都是併發程式，程式會啟動多個 Goroutine 併發執行程式邏輯，這裡你一定要注意主 Goroutine 的優雅退出，也就是main上的 Goroutine 要根據實際情況來決定，是否要等待其他子 Goroutine 做完清理收尾工作退出後再行退出。</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 一個Go的程式專案是怎麼樣的</title>
      <link href="/2023/12/19/golang/project_structure/"/>
      <url>/2023/12/19/golang/project_structure/</url>
      
        <content type="html"><![CDATA[<p>我們編寫的 Go 程式一般都是簡單程式，一般由一個或幾個 Go 原始碼檔案組成，而且所有原始碼檔案都在同一個目錄中。但是生產環境中運行的程式可不會這麼簡單，通常它們都有著複雜的專案結構佈局。弄清楚一個實用 Go 專案的專案佈局標準是 Go 開發者走向編寫複雜 Go 程式的第一步，也是必經的一步。</p><p>但 Go 官方到目前為止也沒有給出一個關於 Go 專案佈局標準的正式定義。那在這樣的情況下，Go 社群是否有我們可以遵循的參考佈局，或者標準呢？有的。在這一篇文章裡，我就來告訴你 Go 社群廣泛採用的 Go 專案佈局是什麼樣子的。</p><span id="more"></span><p>一個 Go 專案通常分為可執行程式專案和第三方module/lib，現在我們就來分析一下這兩類 Go 專案的典型結構佈局分別是怎樣的。首先我們先來看 Go 可執行程式專案的典型結構佈局。可執行程式專案是以建構可執行程式為目的的專案，Go 社群針對這類 Go 專案所形成的典型結構佈局是這樣的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; tree -F goProject</span></span><br><span class="line">goProject</span><br><span class="line">├── cmd/</span><br><span class="line">│   ├── app1/</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   └── app2/</span><br><span class="line">│       └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── internal/</span><br><span class="line">│   ├── pkga/</span><br><span class="line">│   │   └── pkg_a.go</span><br><span class="line">│   └── pkgb/</span><br><span class="line">│       └── pkg_b.go</span><br><span class="line">├── pkg1/</span><br><span class="line">│   └── pkg1.go</span><br><span class="line">└── pkg2/</span><br><span class="line">    └── pkg2.go</span><br></pre></td></tr></table></figure><p>我來解釋一下這裡面的幾個重點。</p><p>我們從上往下按順序來，先來看 cmd 目錄。cmd 目錄就是存放專案要編譯構建的可執行檔案對應的帶有<code>func main()</code>.go檔案。如果你的專案中有多個可執行檔案需要構建，每個可執行檔案的 main 套件單獨放在一個子目錄中，比如圖中的 app1、app2，cmd 目錄下的各 app 的 main 套件將整個專案的依賴連接在一起。</p><p>而且通常來說，main 應該很簡潔。我們在 main 裡的實作會做一些command參數解析、資源初始化、Logger初始化、資料庫連接初始化等工作，之後就程式就會進去其他package去執行更高級的邏輯控制。另外，也有一些 Go 專案將 cmd 這個名字改為 app 或其他名字，但它的功能其實並沒有變。</p><p>接著我們來看 pkgN 目錄，這是一個存放專案自身要使用、同樣也是可執行檔案對應 main 所要依賴的Library，同時這些目錄下的Library還可以被外部Project引用。</p><p>然後是 go.mod 和 go.sum，它們是管理 Go 語言第三方Library所使用的配置檔。建議所有新專案都基於 Go Module 來進行Library管理，因為這是目前 Go 官方推薦的標準構建模式。</p><p><strong>好了到這裡，我們已經了解了 Go 可執行程式專案的典型佈局，現在我們再來看看 Go Library的典型結構佈局是怎樣的。</strong><br>Go Library僅對外暴露 Go 套件，這類專案的典型佈局形式是這樣的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; tree -F libLayout </span></span><br><span class="line">libLayout</span><br><span class="line">├── go.mod</span><br><span class="line">├── internal/</span><br><span class="line">│   ├── pkga/</span><br><span class="line">│   │   └── pkg_a.go</span><br><span class="line">│   └── pkgb/</span><br><span class="line">│       └── pkg_b.go</span><br><span class="line">├── pkg1/</span><br><span class="line">│   └── pkg1.go</span><br><span class="line">└── pkg2/</span><br><span class="line">    └── pkg2.go</span><br></pre></td></tr></table></figure><p>我們看到，Library類型專案相比於 Go 可執行程式專案的佈局要簡單一些。因為這類Project不需要構建可執行程式，所以去除了 cmd 目錄。</p><p>Go Library的初衷是為了對外部（開源或組織內部公開）暴露 API，對於僅限Project內部使用而不想暴露到外部的套件，可以放在Project頂層的 internal 目錄下面。當然 internal 也可以有多個並存在於Project結構中的任一目錄層級中，關鍵是專案結構設計人員要明確各級 internal 套件的應用層次和範圍。</p><p>對於有一個且僅有一個套件的 Go Library來說，我們也可以將上面的佈局做進一步簡化，簡化的佈局如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; tree -L 1 -F singleLibLayout</span></span><br><span class="line">singleLibLayout</span><br><span class="line">├── feature1.go</span><br><span class="line">├── feature2.go</span><br><span class="line">├── go.mod</span><br><span class="line">└── internal/</span><br></pre></td></tr></table></figure><p>簡化後，我們將這唯一套件的所有原始碼檔案放置在Project的頂層目錄下（比如上面的 feature1.go 和 feature2.go），其他佈局元素位置和功用不變。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>首先，對於以生產可執行程式為目的的 Go Project，它的典型Project結構分為五部分：</p><ul><li>放在Project頂層的 Go Module 相關檔案，包括 go.mod 和 go.sum</li><li>cmd 目錄：存放Project要編譯構建的可執行檔案所對應的 main 套件的源檔</li><li>Project套件目錄：每個Project下的非 main 套件都“平鋪”在Project的根目錄下，每個目錄對應一個 Go 套件</li><li>internal 目錄：存放僅Project內部引用的 Go 套件，這些套件無法被Project外引用</li></ul><p>第二，對於以生產可復用Library為目的的 Go Project，它的典型結構則要簡單許多，我們可以直接理解為在 Go 可執行程式專案的基礎上去掉 cmd 目錄。</p><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Go語言的設計哲學</title>
      <link href="/2023/12/12/golang/design_philosophy/"/>
      <url>/2023/12/12/golang/design_philosophy/</url>
      
        <content type="html"><![CDATA[<p>Go語言，又稱Golang，是由Google開發的一種現代程式語言。它在2007年誕生，由Robert Griesemer、Rob Pike和Ken Thompson設計。Go語言的設計哲學非常獨特，使它在眾多程式語言中脫穎而出。這篇文章，我們來聊聊Go語言的設計哲學，看看這門語言是如何讓寫程式變得更加簡單、高效和愉快的。</p><span id="more"></span><p>所謂程式語言的設計哲學，就是指決定這門語言演化進程的高級原則和依據。好比Python的設計哲學是<strong>簡單就是美</strong>，使開發者能專注於解決問題本身，而不是被語法所困擾。而Java的設計哲學強調穩定性、可擴展性和跨平台性，Java的座右銘是「Write Once, Run Anywhere」。</p><p><strong>設計哲學之於程式語言，就好比一個人的價值觀之於這個人的行為</strong><br>因為如果你不認同一個人的價值觀，那你其實很難與之持續交往下去，即所謂道不同不相為謀。類似的，如果你不認同一門程式語言的設計哲學，那麼很有可能你在後續的語言學習中，就會遇到上面提到的這些問題，而且可能會讓你失去繼續學習的精神動力。</p><p>我認為Go語言的設計哲學可以總結為以下五點：簡單、顯式、組合、併發和工程導向。<br><img src="/images/golang/philosophy.jpg"></p><h3 id="簡單"><a href="#簡單" class="headerlink" title="簡單"></a>簡單</h3><p>簡單意味著語言本身保持最小的語法和特性集，避免過於複雜的結構和特性，使程式碼更易於閱讀和理解。例如，Go 不支持繼承、多型等傳統 OOP（物件導向程式設計）的特性，而是依賴於更簡單的結構體和接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;John&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顯式"><a href="#顯式" class="headerlink" title="顯式"></a>顯式</h3><p>Go 語言強調「顯式」而非「隱式」，這意味著程式碼應該明確表達其意圖。這有助於減少錯誤，提高程式碼的可讀性和可維護性。Go 的錯誤處理機制也是這一理念的體現，它要求開發者顯式處理錯誤，而不是依賴隱式的異常機制。所以在開發Go程式時，經常可以在開發中而不是編譯或運行時才捕捉到人為錯誤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error opening file:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 處理文件的邏輯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="組合"><a href="#組合" class="headerlink" title="組合"></a>組合</h3><p>Go 語言提倡通過「組合」來構建複雜的系統，而不是通過繼承。這種方式使得程式碼更加靈活和可重用。Go 的接口系統允許我們定義一組行為，而不需要在類層次上建立複雜的繼承關係。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bird is flying&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plane <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Plane)</span></span> Fly() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Plane is flying&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f Flyer</span><br><span class="line"></span><br><span class="line">    f = Bird&#123;&#125;</span><br><span class="line">    f.Fly()</span><br><span class="line"></span><br><span class="line">    f = Plane&#123;&#125;</span><br><span class="line">    f.Fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這有點類似物件導向的多型，只要struct滿足事先定義的interface介口方法，就可以實作並且執行。</p><h3 id="併發"><a href="#併發" class="headerlink" title="併發"></a>併發</h3><p>Go 語言原生支持「併發」，並通過 goroutine 和 channel 提供了簡單且強大的併發程式開發模型。這使得開發者能夠輕鬆地寫出高效的併發程式，而不需要處理複雜的併發控制機制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工程導向"><a href="#工程導向" class="headerlink" title="工程導向"></a>工程導向</h3><p>Go 語言的設計非常「工程導向」，它關注於實際工程中的問題，提供了快速編譯、簡單部署、以及高效執行的特性。這使得 Go 成為構建大型分佈式系統和微服務架構的理想選擇。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>Go語言設計哲學強調簡單、顯式、組合、併發和工程導向。</li><li>它通過減少語法和特性，使程式碼更易讀和理解。</li><li>強調顯式處理錯誤，減少潛在錯誤風險。</li><li>鼓勵組合而非繼承，提高程式碼靈活性和重用性。</li><li>原生支持併發，方便開發高效的併發程式。</li><li>工程導向設計，適合大型分佈式系統和微服務架構。</li></ul><div style="text-align: center;">  <a href="../../../../../categories/Go/">Go語言進階學習系列</a>  <img src="/images/golang/overview.jpg" alt="" /></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] esxcli 指令</title>
      <link href="/2023/12/03/vsan/esxcli_list/"/>
      <url>/2023/12/03/vsan/esxcli_list/</url>
      
        <content type="html"><![CDATA[<h1 id="ESXi-Host"><a href="#ESXi-Host" class="headerlink" title="ESXi Host"></a>ESXi Host</h1><h3 id="esxcli-vsan-cluster"><a href="#esxcli-vsan-cluster" class="headerlink" title="esxcli vsan cluster"></a>esxcli vsan cluster</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan cluster</span></span><br><span class="line">Available Commands:</span><br><span class="line">  get                   Get information about the vSAN cluster that this host is joined to.</span><br><span class="line">  <span class="built_in">join</span>                  Join the host to a vSAN cluster.</span><br><span class="line">  leave                 Leave the vSAN cluster the host is currently joined to.</span><br><span class="line">  list                  Get information about the vSAN clusters that this host is joined to.</span><br><span class="line">  new                   Create a vSAN cluster with current host joined. A random sub-cluster UUID will be generated.</span><br><span class="line">  restore               Restore the persisted vSAN cluster configuration.</span><br></pre></td></tr></table></figure><p>我們可以看到，除了可以獲取當前vSAN cluster的詳細訊息之外，也可以將Host加入或移除vSAN Cluster之外</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan cluster get</span></span><br><span class="line">Cluster Information</span><br><span class="line">   Enabled: <span class="literal">true</span></span><br><span class="line">   Current Local Time: 2023-08-20T13:38:32Z</span><br><span class="line">   Local Node UUID: 63003af1-640c-87f6-85d3-02007444d88c</span><br><span class="line">   Local Node Type: NORMAL</span><br><span class="line">   Local Node State: AGENT</span><br><span class="line">   Local Node Health State: HEALTHY</span><br><span class="line">   Sub-Cluster Master UUID: 63003ae6-92df-1255-9453-020074c6ad8b</span><br><span class="line">   Sub-Cluster Backup UUID: 63003b06-7d5e-4c7c-4b6f-020074c6bbaa</span><br><span class="line">   Sub-Cluster UUID: 5252eeac-5b6e-92cd-f76b-a890203522c7</span><br><span class="line">   Sub-Cluster Membership Entry Revision: 3</span><br><span class="line">   Sub-Cluster Member Count: 4</span><br><span class="line">   Sub-Cluster Member UUIDs: 63003ae6-92df-1255-9453-020074c6ad8b, 63003b06-7d5e-4c7c-4b6f-020074c6bbaa, 63003aea-e18d-be96-3912-020074ed789f, 63003af1-640c-87f6-85d3-02007444d88c</span><br><span class="line">   Sub-Cluster Member HostNames: sc1-10-78-93-157.eng.vmware.com, sc1-10-78-86-136.eng.vmware.com, sc1-10-78-95-9.eng.vmware.com, sc1-10-78-85-223.eng.vmware.com</span><br><span class="line">   Sub-Cluster Membership UUID: a9440063-9232-c388-fa87-020074c6ad8b</span><br><span class="line">   Unicast Mode Enabled: <span class="literal">true</span></span><br><span class="line">   Maintenance Mode State: OFF</span><br><span class="line">   Config Generation: 59c0eefe-98d4-4167-9638-52b24a862fed 3 2023-08-20T04:55:23.533</span><br><span class="line">   Mode: REGULAR</span><br></pre></td></tr></table></figure><p>我們可以看到目前vSAN主機擔任的是AGENT的角色，AGENT角色的作用，可以參考CMMDS那個章節介紹。也能看到主機的健康狀態、Master Node等等訊息</p><h3 id="esxcli-vsan-debug"><a href="#esxcli-vsan-debug" class="headerlink" title="esxcli vsan debug"></a>esxcli vsan debug</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan debug</span></span><br><span class="line">Usage: esxcli vsan debug &#123;cmd&#125; [cmd options]</span><br><span class="line"></span><br><span class="line">Available Namespaces:</span><br><span class="line">  disk                  Debug commands <span class="keyword">for</span> vSAN physical disks</span><br><span class="line">  object                Debug commands <span class="keyword">for</span> vSAN objects</span><br><span class="line">  resync                Debug commands <span class="keyword">for</span> vSAN resyncing objects</span><br><span class="line">  advcfg                Debug commands <span class="keyword">for</span> vSAN advanced configuration options.</span><br><span class="line">  controller            Debug commands <span class="keyword">for</span> vSAN disk controllers</span><br><span class="line">  evacuation            Debug commands <span class="keyword">for</span> simulating host, disk or disk group evacuation <span class="keyword">in</span> various modes and their impact on objects <span class="keyword">in</span> vSAN cluster</span><br><span class="line">  <span class="built_in">limit</span>                 Debug commands <span class="keyword">for</span> vSAN limits</span><br><span class="line">  memory                Debug commands <span class="keyword">for</span> vSAN memory consumption.</span><br><span class="line">  mob                   Debug commands <span class="keyword">for</span> vSAN Managed Object Browser Service.</span><br><span class="line">  vmdk                  Debug commands <span class="keyword">for</span> vSAN VMDKs</span><br></pre></td></tr></table></figure><p>我們可以透過debug指令查詢此Host上更細節的資訊，例如Disk的容量、Object、memory、vmdk等等的，例如我們可以透過limit，查看當前Host使用的Capacity、Components</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan debug limit get</span></span><br><span class="line">   Component Limit Health: green</span><br><span class="line">   Max Components: 750</span><br><span class="line">   Free Components: 742</span><br><span class="line">   Disk Free Space Health: green</span><br><span class="line">   Lowest Free Disk Space: 96 %</span><br><span class="line">   Used Disk Space: 2820082236 bytes</span><br><span class="line">   Used Disk Space (GB): 2.63 GB</span><br><span class="line">   Total Disk Space: 96619986944 bytes</span><br><span class="line">   Total Disk Space (GB): 89.98 GB</span><br></pre></td></tr></table></figure><p>也可以觀察物理硬碟的健康狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan debug disk list</span></span><br><span class="line">UUID: 5229d71d-422e-a985-dc72-33b326a3dcf4</span><br><span class="line">   Name: mpx.vmhba0:C0:T3:L0</span><br><span class="line">   Owner: sc1-10-78-85-223.eng.vmware.com</span><br><span class="line">   Version: 17</span><br><span class="line">   Disk Group: 5229d71d-422e-a985-dc72-33b326a3dcf4</span><br><span class="line">   Disk Tier: Cache</span><br><span class="line">   SSD: <span class="literal">true</span></span><br><span class="line">   In Cmmds: <span class="literal">true</span></span><br><span class="line">   In Vsi: <span class="literal">true</span></span><br><span class="line">   Fault Domain: N/A</span><br><span class="line">   Model: Virtual disk</span><br><span class="line">   Encryption: <span class="literal">false</span></span><br><span class="line">   Compression: <span class="literal">false</span></span><br><span class="line">   Deduplication: <span class="literal">false</span></span><br><span class="line">   Dedup Ratio: N/A</span><br><span class="line">   Overall Health: green</span><br><span class="line">   Metadata Health: green</span><br><span class="line">   Operational Health: green</span><br><span class="line">   Congestion Health:</span><br><span class="line">         State: green</span><br><span class="line">         Congestion Value: 0</span><br><span class="line">         Congestion Area: none</span><br><span class="line">         All Congestion Fields:</span><br><span class="line">   Space Health:</span><br></pre></td></tr></table></figure><h3 id="esxcli-vsan-health-cluster"><a href="#esxcli-vsan-health-cluster" class="headerlink" title="esxcli vsan health cluster"></a>esxcli vsan health cluster</h3><p>我們能透過此命令，在vSAN Host上面對Cluster進行基本的健康檢查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan health cluster list</span></span><br><span class="line">Health Test Name                                    Status</span><br><span class="line">--------------------------------------------------  ------</span><br><span class="line">Overall health findings                             green (OK)</span><br><span class="line">Cluster                                             green</span><br><span class="line">  Advanced vSAN configuration <span class="keyword">in</span> <span class="built_in">sync</span>               green</span><br><span class="line">  vSAN daemon liveness                              green</span><br><span class="line">  vSAN Disk Balance                                 green</span><br><span class="line">  Resync operations throttling                      green</span><br><span class="line">  Software version compatibility                    green</span><br><span class="line">  Disk format version                               green</span><br><span class="line">Network                                             green</span><br><span class="line">  Hosts with connectivity issues                    green</span><br><span class="line">  vSAN cluster partition                            green</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我們也可以指定一個特定的健康檢查，來查看細節，例如我們想查看Disk balance的情況</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan health cluster get -t diskbalance</span></span><br><span class="line">vSAN Disk Balance        green</span><br><span class="line"></span><br><span class="line">Checks the vSAN disk balance status on all hosts.</span><br><span class="line">Ask VMware: http://www.vmware.com/esx/support/askvmware/index.php?eventtype=com.vmware.vsan.health.test.diskbalance</span><br><span class="line"></span><br><span class="line">Overview</span><br><span class="line">Metric                    Value</span><br><span class="line">------------------------------------</span><br><span class="line">Average Disk Usage        3 %</span><br><span class="line">Maximum Disk Usage        4 %</span><br><span class="line">Maximum Load Variance     2 %</span><br><span class="line">Average Load Variance     1 %</span><br><span class="line"></span><br><span class="line">Disk Balance</span><br><span class="line">Host     Device     Rebalance State     Data To Move (GB)</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="esxcli-vsan-iscsi"><a href="#esxcli-vsan-iscsi" class="headerlink" title="esxcli vsan iscsi"></a>esxcli vsan iscsi</h3><p>iSCSI也是vSAN一個很好用的功能，所以有必要說說</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan iscsi</span></span><br><span class="line">Usage: esxcli vsan iscsi &#123;cmd&#125; [cmd options]</span><br><span class="line"></span><br><span class="line">Available Namespaces:</span><br><span class="line">  initiatorgroup        Commands to manipulate vSAN iSCSI target initiator group</span><br><span class="line">  target                Commands <span class="keyword">for</span> vSAN iSCSI target configuration</span><br><span class="line">  defaultconfig         Operation <span class="keyword">for</span> default configuration <span class="keyword">for</span> vSAN iSCSI Target</span><br><span class="line">  homeobject            Commands <span class="keyword">for</span> the vSAN iSCSI target home object</span><br><span class="line">  status                Enable or <span class="built_in">disable</span> iSCSI target support, query status.</span><br></pre></td></tr></table></figure><p>透過status，我們可以查看iscsi服務已經enable了沒</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan iscsi status get</span></span><br><span class="line">   Enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>若enable了，可以看看我們現有target的詳細訊息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan iscsi target list</span></span><br><span class="line">Alias    iSCSI Qualified Name (IQN)                                Interface  Port  Authentication <span class="built_in">type</span>  LUNs  Is Compliant  UUID                                  I/O Owner UUID</span><br><span class="line">-------  --------------------------------------------------------  ---------  ----  -------------------  ----  ------------  ------------------------------------  --------------</span><br><span class="line">target1  iqn.1998-01.com.vmware:52d9508e346523dc-fcfb76c951cd3aec  vmk0       3260  No-Authentication       1          <span class="literal">true</span>  49ec0063-d44c-d840-dc9f-020074c6bbaa  63003b06-7d5e-4c7c-4b6f-020074c6bbaa</span><br><span class="line">target2  iqn.1998-01.com.vmware:520b1fcc2b101a18-6aaa64b27b3abc64  vmk0       3260  No-Authentication       0          <span class="literal">true</span>  25ed0063-d098-6f0b-6b90-020074c6bbaa  63003b06-7d5e-4c7c-4b6f-020074c6bbaa</span><br></pre></td></tr></table></figure><p>並觀察Lun的使用狀況</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">esxcli vsan iscsi target lun list -t target1</span><br><span class="line">ID  Alias        Size  UUID                                  Is Compliant  Status</span><br><span class="line">--  -----  ----------  ------------------------------------  ------------  ------</span><br><span class="line"> 0  lun0   102400 MiB  d0ec0063-bc6d-8ff2-84c6-020074c6bbaa          <span class="literal">true</span>  online</span><br></pre></td></tr></table></figure><h3 id="esxcli-vsan-maintenancemode"><a href="#esxcli-vsan-maintenancemode" class="headerlink" title="esxcli vsan maintenancemode"></a>esxcli vsan maintenancemode</h3><p>然而，該command沒辦法讓host進入或離開Maintenance mode，若要進入或離開，需透過其他指令</p><p><strong>Enter Maintenance mode</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esxcli system maintenanceMode <span class="built_in">set</span> --<span class="built_in">enable</span> <span class="literal">true</span> -m noAction</span><br></pre></td></tr></table></figure><p><strong>Exit Maintenance mode</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esxcli system maintenanceMode <span class="built_in">set</span> --<span class="built_in">enable</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="esxcli-vsan-network"><a href="#esxcli-vsan-network" class="headerlink" title="esxcli vsan network"></a>esxcli vsan network</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esxcli vsan network list</span></span><br><span class="line">Interface</span><br><span class="line">   VmkNic Name: vmk0</span><br><span class="line">   IP Protocol: IP</span><br><span class="line">   Interface UUID: 52219973-1c85-f21e-8990-2871036add42</span><br><span class="line">   Agent Group Multicast Address: 224.2.3.4</span><br><span class="line">   Agent Group IPv6 Multicast Address: ff19::2:3:4</span><br><span class="line">   Agent Group Multicast Port: 23451</span><br><span class="line">   Master Group Multicast Address: 224.1.2.3</span><br><span class="line">   Master Group IPv6 Multicast Address: ff19::1:2:3</span><br><span class="line">   Master Group Multicast Port: 12345</span><br><span class="line">   Host Unicast Channel Bound Port: 12321</span><br><span class="line">   Data-in-Transit Encryption Key Exchange Port: 0</span><br><span class="line">   Multicast TTL: 5</span><br><span class="line">   Traffic Type: vsan</span><br></pre></td></tr></table></figure><p>當遇到網路分區錯誤時，可以透過上述指令進行故障排除</p><h1 id="vCenter"><a href="#vCenter" class="headerlink" title="vCenter"></a>vCenter</h1><h3 id="RVC"><a href="#RVC" class="headerlink" title="RVC"></a>RVC</h3><p>rvc管理工具內建於vCenter，當管理人員ssh登入進去vCenter的console後，可以執行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rvc &lt;user&gt;@&lt;vc-ip&gt;</span></span><br><span class="line">Welcome to RVC. Try the <span class="string">&#x27;help&#x27;</span> <span class="built_in">command</span>.</span><br><span class="line">0 /</span><br><span class="line">1 localhost/</span><br></pre></td></tr></table></figure><p><strong>health summary</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; vsan.health.health_summary /localhost/DataCenter/computers/Vsan1Cluster</span></span><br><span class="line">Overall health findings: yellow (Cluster health issue)</span><br><span class="line">+------------------------------------------------------+---------+</span><br><span class="line">| Health check                                         | Result  |</span><br><span class="line">+------------------------------------------------------+---------+</span><br><span class="line">| Cluster                                              | Warning |</span><br><span class="line">|   Time is synchronized across hosts and VC           | Passed  |</span><br><span class="line">|   Advanced vSAN configuration <span class="keyword">in</span> <span class="built_in">sync</span>                | Passed  |</span><br><span class="line">|   vSAN daemon liveness                               | Passed  |</span><br><span class="line">|   vSAN Disk Balance                                  | Passed  |</span><br><span class="line">|   Resync operations throttling                       | Passed  |</span><br><span class="line">|   vSAN Direct homogeneous disk claiming              | Passed  |</span><br><span class="line">|   vCenter state is authoritative                     | Passed  |</span><br><span class="line">|   vSAN cluster configuration consistency             | Passed  |</span><br><span class="line">|   vSphere cluster members match vSAN cluster members | Passed  |</span><br><span class="line">|   Host Maintenance Mode                              | Warning |</span><br><span class="line">|   Software version compatibility                     | Passed  |</span><br><span class="line">|   Disk format version                                | Passed  |</span><br><span class="line">|   vSAN extended configuration <span class="keyword">in</span> <span class="built_in">sync</span>                | Passed  |</span><br><span class="line">+------------------------------------------------------+---------+</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>RVC的規則是指令 - Target，例如我們使用的指令是vsan.health.health_summary，target是cluster，所以返回了整個Cluster的健康狀態</p><p>RVC有非常多的指令集，有興趣的讀者可以查閱</p><p><a href="https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/products/vsan/vmware-ruby-vsphere-console-command-reference-for-virtual-san.pdf">https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/products/vsan/vmware-ruby-vsphere-console-command-reference-for-virtual-san.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> esxcli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] 運維管理</title>
      <link href="/2023/11/26/vsan/cluster_monitor/"/>
      <url>/2023/11/26/vsan/cluster_monitor/</url>
      
        <content type="html"><![CDATA[<p>vSAN作為VMware一個重要的儲存產品，它深度融合了VMware的vSphere，並能透過vCenter一站式管理儲存資源池。我們可以透過vCenter建立vSAN Cluster、創建vSAN Datastore，更能夠在vCenter上直接監控vSAN Cluster的健康和I/O性能狀態。接下來，讓我來介紹如何透過7.0U3的vCenter進行運維管理。</p><h2 id="vSAN-Skyline-Health"><a href="#vSAN-Skyline-Health" class="headerlink" title="vSAN Skyline Health"></a>vSAN Skyline Health</h2><p>vSphere提供了esxcli指令，讓用戶可以透過esxcli指令主動查詢當前ESXi host的硬體、儲存、網路等資訊。那麼，有沒有方法可以被動提示用戶當前vSAN cluster的健康狀態呢？</p><span id="more"></span><p>當我們登入vCenter，點選左邊的vSAN Cluster→Monitor→Skyline Health，就可以看到Cluster健康檢查的細節，如下圖所示：</p><p><img src="/images/vsan/Skyline_Health.png"></p><p>vSAN是一個分散式物件儲存系統，因此vSAN Skyline Health會從網路、硬碟、驅動程式/韌體、儲存策略等各個維度進行全盤檢查，以確保vSAN Cluster的各個方面都是健康的。此外，在對ESXi Host進行升級或進入維護模式時，也會進行檢查，防止資料丟失。</p><h2 id="Objects-View"><a href="#Objects-View" class="headerlink" title="Objects View"></a>Objects View</h2><p>我們的VM是以Object的形式儲存在vSAN Storage中的。由於資料的儲存安全非常重要，在vCenter裡，有一個獨立的View讓用戶可以查看Object Health更詳細的訊息。</p><p>當我們登入vCenter，點選左邊的vSAN Cluster→Monitor→Virtual Objects，就可以看到Object健康檢查的細節，如下圖所示：</p><p><img src="/images/vsan/Virutal_Object.png"></p><p>由上圖可以看到，我們有三台已經開機的虛擬機，所以有三個Object，分別是VM Home Namespace、VMDK和Swap，並且儲存策略設定為vSAN Default Storage Policy，代表的是RAID-1/FTT-1的策略，即備份一份，最多只容忍丟失一份資料。</p><p>我們勾選想要檢查的Object，並點選”VIEW PLACEMENT DETAILS”，就會進入如下畫面：</p><p><img src="/images/vsan/Physical_Placement.png"></p><p>我們可以看到各個Object裡的Component/Witness被分配到哪個ESXi host的物理硬碟上，並且可以檢查該Component是否是健康的。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>不同於前面說的Skyline Health和Object View，Performance Service主要是搜集歷史Cluster/VM的Performance訊息並展示給用戶。我們可以透過Performance View來查看Cluster近一個小時所產生的IOPS/Throughput/Latency/Congestions訊息。</p><p><img src="/images/vsan/Performance_Overview.png"></p><p>我們也可以細化到單一VM，來觀察虛擬機的Performance使用情況。</p><p><img src="/images/vsan/Performance_VM.png"></p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>vSAN Skyline Health</strong>：透過vCenter查看vSAN Cluster健康狀態。</li><li><strong>Objects View</strong>：查看vSAN中虛擬機的Object健康狀況。</li><li><strong>Performance</strong>：監控並分析Cluster和VM的歷史性能數據。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> monitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] 物理硬碟狀態</title>
      <link href="/2023/11/18/vsan/physical_disk_states/"/>
      <url>/2023/11/18/vsan/physical_disk_states/</url>
      
        <content type="html"><![CDATA[<p>Disk 由於晶圓問題、firmware 問題、driver 問題等等會造成一定機率上的故障。假如一塊硬碟每天的故障機率是 1%，那麼一座有一萬個 disk 的資料中心，每天可能會有 100 塊硬碟損壞。當然，vSAN 對於部分類型的損壞會嘗試自動修復，這樣能大幅減少人力成本，畢竟大部分問題重開機就能解決。</p><p>LSOM 是最底層與硬碟打交道的元件，它的 DDH（Degraded Device Handling）服務可以監控硬碟狀態。當 DDH 偵測到 Disk 即將故障或損壞時，會將 Disk 標記為有問題的裝置，讓它不再參與資料的 I/O 流程。更多細節可以參考 VMware KB：<a href="https://kb.vmware.com/s/article/2148358">https://kb.vmware.com/s/article/2148358</a></p><p>這裡列舉 vSAN 偵測到的硬碟狀態及其原因：</p><h3 id="PDL"><a href="#PDL" class="headerlink" title="PDL"></a>PDL</h3><p>Permanent Disk Loss (PDL) 是一種嚴重的錯誤，需要人工介入。一般情況下是 Host 與 Disk 的連結出了問題，無法連接。可能是 ESXi Host 內部或 Disk 的 bug 導致的。</p><span id="more"></span><h3 id="Transient-Error"><a href="#Transient-Error" class="headerlink" title="Transient Error"></a>Transient Error</h3><p>這種錯誤可以藉由多次 I/O 重試修復。一般是由於 ESXi Host 內部或 SCSI 的 bug，例如 I/O 工作負載突然激增。</p><h3 id="Stuck-I-O"><a href="#Stuck-I-O" class="headerlink" title="Stuck I/O"></a>Stuck I/O</h3><p>Stuck I/O 發生在 ESXi Host 外面，一般由 firmware 或 hardware 的 bug 導致 I/O 無法完成。在 vSAN 7.0 Update 3 以前，Stuck I/O 會使整個 Host 關機。一個 disk 的 I/O 無反應會影響整個 Cluster 處理 I/O 的進程，自動重啟後 I/O 仍會繼續 Stuck。因此，最好手動移除 Disk 再重啟。vSAN 7.0 Update 3 之後，監控平台會提示使用者某個 Disk 發生 Stuck I/O，需要手動重啟 Host。</p><h3 id="URE"><a href="#URE" class="headerlink" title="URE"></a>URE</h3><p>Unrecovered Read Error (URE) 是 LSOM 遇到 metadata 讀取錯誤時發生的問題。這是由於 Disk 介質的錯誤，能夠自動修復。當 Disk 發生 URE 並且 DDH 開啟時，vSAN 會透過將資料撤出並重建 disk 來處理此錯誤。</p><h3 id="High-Latency"><a href="#High-Latency" class="headerlink" title="High Latency"></a>High Latency</h3><p>當 LSOM 偵測到過多的 High Latency I/O 時會觸發此狀態。</p><h3 id="Congestion"><a href="#Congestion" class="headerlink" title="Congestion"></a>Congestion</h3><p>當 LSOM 偵測到以下 Congestion 時，會通知 DOM 降低 I/O 流量直到 Congestion 解除：</p><ol><li>Log Congestion</li><li>SSD Congestion</li><li>Component Congestion</li><li>Memory Congestion</li><li>IOPS Congestion</li></ol><p>最後，當 DDH 偵測到 Disk 的錯誤後，需將 Disk 上的 Object Component 即時撤離，此時需進行 Evacuation 操作。</p><h3 id="Evacuate"><a href="#Evacuate" class="headerlink" title="Evacuate"></a>Evacuate</h3><p>由於 Disk 發生錯誤，需要將 Disk 上的 Component 撤出到其他 Disk，以確保 Object 能符合使用者設定的 Policy。當然，也可能發生 Evacuate 錯誤，此時需要人工介入。關於 Evacuation 的結果，有以下三種：</p><ol><li><strong>Data evacuation completed</strong><br> 成功撤離。</li><li><strong>Data evacuation failed due to insufficient resources</strong><br> 由於 Cluster 容量不足導致撤離失敗，需人工介入。</li><li><strong>Data evacuation failed due to inaccessible objects</strong><br> 當 ESXi host 重啟或發生網路問題，容易觸發 inaccessible object。需人工介入修復基礎設施問題或刪除該 object。</li></ol><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>PDL</strong>: 嚴重錯誤需人工介入並手動移除Disk，相關人員需手動確保資料可用性</li><li><strong>Transient Error</strong>: 暫時的error，可通過 I/O 重試修復</li><li><strong>Stuck I/O</strong>: Disk I/O發生卡住事件，需要手動重啟 Host</li><li><strong>URE</strong>: 由 Disk 介質錯誤引起，可自動修復</li><li><strong>High Latency</strong>: 高延遲 I/O 觸發的error，一般發生在HDD</li><li><strong>Congestion</strong>: 減少 I/O 流量直至 Congestion 解除</li><li><strong>Evacuate</strong>: 確保 Object 符合使用者設定的 Policy前提下，安全把disk撤出ESXi Host</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> disks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] vSAN 資料加密保護</title>
      <link href="/2023/11/05/vsan/data_encryption/"/>
      <url>/2023/11/05/vsan/data_encryption/</url>
      
        <content type="html"><![CDATA[<p>vSAN 作為軟體定義儲存，它的加密機制也與硬體無關，無需額外的加密裝置，硬碟也無需額外的加密插件。vSAN 加密機制採用的是 XTS-AES 256 加密標準，可以同時保護快取層和容量層的資料。值得注意的是，當資料進入快取層時，系統會對資料進行加密，而當資料要轉存進去容量層時，會先把準備要寫入容量層的資料解密，然後執行重複資料刪除和壓縮的動作，再加密資料，最後寫進容量層。</p><p>vSAN 的加密機制採用的是 KMS (Key Manager Server) 解決方案，使用者需要從外部例如 Google 或 Amazon 取得 KMS 加密金鑰。</p><p>KMS 採用的是 KEK (Key Encryption Key) 和 DEK (Data Encryption Key) 機制。DEK 先將硬碟資料進行加密，然後 KEK 負責加密 DEK。DEK 透過 KMIP (Key Management Interoperability Protocol) 傳送加密後的資料到 vSAN 節點主機中，這樣只有當管理人員拿到 KEK，才可以解密所有資料。Hybrid 和 All Flash 都支援此機制。</p><span id="more"></span><h3 id="Data-at-rest-encryption"><a href="#Data-at-rest-encryption" class="headerlink" title="Data-at-rest encryption"></a>Data-at-rest encryption</h3><p>當啟用了 Data-at-rest encryption，vSAN 會把所有在 vSAN Datastore 裡的資料全數加密。即使硬碟被偷了也不怕，只有管理者有權限解密資料。</p><p>KEK 不會存在 vCenter，而是在 KMS 裡。DEK 有多個，每個 disk 一個，存在各個 host 裡。每次需要加解密，需從 host 透過 vCenter 拿到 KEK 進行加解密。</p><h3 id="Data-in-transit-encryption"><a href="#Data-in-transit-encryption" class="headerlink" title="Data-in-transit encryption"></a>Data-in-transit encryption</h3><p>Data-in-transit 顧名思義，就是在資料傳輸中加密而已。它不需要 KMS，而是透過對稱加密 AES 256 bits encryption，能防止中間人攻擊。</p><p>Data-in-transit 和 Data-at-rest 是獨立的，管理人員可以個別啟用或關閉它們。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>vSAN 採用 XTS-AES 256 加密標準，保護快取層和容量層資料。</li><li>KMS 提供 KEK 和 DEK 機制，確保資料加密安全。</li><li>Data-at-rest encryption 保障靜態資料安全。</li><li>Data-in-transit encryption 保障傳輸中資料安全，防止中間人攻擊。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] vSAN的重複資料刪除、壓縮和資料校驗</title>
      <link href="/2023/10/25/vsan/data_compress/"/>
      <url>/2023/10/25/vsan/data_compress/</url>
      
        <content type="html"><![CDATA[<h2 id="重複資料刪除和壓縮"><a href="#重複資料刪除和壓縮" class="headerlink" title="重複資料刪除和壓縮"></a>重複資料刪除和壓縮</h2><p>在資料儲存領域，除了使用RAID 5/6之外，還可以啟用「重複資料刪除和壓縮」來節省儲存資源。這個功能會針對每個資料區塊進行重複資料刪除，如果vSAN Datastore中已經有相同的資料區塊，系統就不會重複儲存。為了判斷資料區塊是否相同，系統會使用雜湊算法來建立資料索引。</p><p>在vSAN架構中，雜湊使用了SHA-1演算法來為每段資料建立Hash value，每段大小為4KB。</p><p>壓縮則是使用LZ4演算法。在重複資料刪除的過程中，當系統發現有新資料要寫入時，會進行壓縮，將原本4KB的資料壓縮成大約2KB，然後再寫入容量層。</p><span id="more"></span><p>另外，只有All flash架構才支援重複資料刪除和壓縮功能。</p><h3 id="總結："><a href="#總結：" class="headerlink" title="總結："></a>總結：</h3><ul><li>重複資料刪除：使用SHA-1演算法，4KB為單位</li><li>壓縮：使用LZ4演算法，將4KB壓縮至約2KB</li><li>All flash架構才支援這些功能</li></ul><h2 id="資料校驗"><a href="#資料校驗" class="headerlink" title="資料校驗"></a>資料校驗</h2><p>在網路上下載大檔案或機密文件時，網站會提供一個下載連結和md5 Hash來驗證資料來源。這是為了避免中間人攻擊，在下載的文件中植入惡意程式。</p><p>vSAN也有類似的功能，預設情況下就會啟用，Hybrid和All flash架構都支援。vSAN使用CRC-32C校驗機制來最佳化性能。如果ESX host上的CPU支援Intel c2c32c指令集，運作會更快。</p><p>除了校驗，在傳輸過程中也有檢查碼機制，針對每4KB資料區塊建立一個5字節的總和檢查碼，並與資料分開存放。當vSAN Cluster檢查到I/O路徑有錯誤或資料不一致時，會自動修復。</p><p>預設情況下，vSAN每年會自動對所有資料進行檢查碼檢查，若發現錯誤，會立即修正。</p><p>我們可以查看各個Object裡的Component/Witness被分配到哪個ESXi host的實體硬碟，並檢查Component是否健康。</p><h3 id="總結：-1"><a href="#總結：-1" class="headerlink" title="總結："></a>總結：</h3><ul><li>CRC-32C校驗機制：提高性能</li><li>傳輸過程檢查碼：每4KB資料區塊建立5字節檢查碼</li><li>自動檢查和修復：每年進行檢查，發現錯誤立即修正</li></ul><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>不同於前面提到的Skyline Health和Object View，Performance Service主要是收集歷史Cluster/VM的Performance資訊並展示給用戶。我們可以透過Performance View來查看Cluster近一個小時的IOPS、Throughput、Latency和Congestions資訊。</p><p><img src="/images/vsan/Performance_Overview.png"></p><p>我們也可以細化到單一VM，來觀察虛擬機的Performance使用情況。</p><p><img src="/images/vsan/Performance_VM.png"></p><h3 id="總結：-2"><a href="#總結：-2" class="headerlink" title="總結："></a>總結：</h3><ul><li>Performance View：查看Cluster和VM的歷史性能資訊，包括：IOPS、Throughput、Latency、Congestions</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] VMware虛擬機是怎麼存在vSAN的呢？</title>
      <link href="/2023/10/18/vsan/vm_persist/"/>
      <url>/2023/10/18/vsan/vm_persist/</url>
      
        <content type="html"><![CDATA[<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>VMware vSAN 是一種分散式儲存技術，它將多個 ESXi 主機的儲存資源組合成一個共享的資料儲存區域。這篇文章會詳細解釋虛擬機在 vSAN 中是如何儲存數據，以及不同類型的物件如何運作。</p><h3 id="vSAN-與虛擬機"><a href="#vSAN-與虛擬機" class="headerlink" title="vSAN 與虛擬機"></a>vSAN 與虛擬機</h3><p>vSAN 是一個 Object-based 的儲存系統，這意味著數據是以物件的形式儲存的。當在 vSAN Datastore 部署虛擬機時，系統會生成五種類型的物件來管理和儲存虛擬機的數據。</p><h3 id="五種類型的物件"><a href="#五種類型的物件" class="headerlink" title="五種類型的物件"></a>五種類型的物件</h3><span id="more"></span><ol><li><p><strong>VM Home Namespace 物件</strong></p><ul><li>這個物件在 VM 被創建時生成，用於儲存所有 VM 的元數據，如配置文件、日志和其他必要的控制信息。</li></ul></li><li><p><strong>SWAP 物件</strong></p><ul><li>當 VM 啟動時生成的物件，用於儲存內存交換（swap）文件，確保系統在內存不足時有足夠的虛擬內存。</li></ul></li><li><p><strong>VMDK 虛擬硬碟物件</strong></p><ul><li>這個物件在 VM 被創建時生成，類型是 vdisk，主要用於儲存 VM 的虛擬磁碟數據。</li></ul></li><li><p><strong>Snapshot Delta VMDKs</strong></p><ul><li>當 VM 建立 Snapshot 時生成的物件，儲存 Snapshot 的數據變更部分，使得系統可以還原到 Snapshot 時的狀態。</li></ul></li><li><p><strong>Memory Object</strong></p><ul><li>當 VM 建立包含記憶體狀態的 Snapshot 時生成的物件，用於儲存當前內存的內容，確保 Snapshot 能夠完全恢復當前狀態。</li></ul></li></ol><p>這些物件都是 DOM 物件，並共用一個不存在的 VM Object UUID 祖先。</p><h3 id="查看-vSAN-中的虛擬物件"><a href="#查看-vSAN-中的虛擬物件" class="headerlink" title="查看 vSAN 中的虛擬物件"></a>查看 vSAN 中的虛擬物件</h3><p>LSOM Object 是 Component，可以透過以下指令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmmds-tool find -t DOM_OBJECT -f json</span><br></pre></td></tr></table></figure><p>另外，你也可以進入 vSAN Cluster 的監控頁面查看虛擬物件（以 vSAN 7.0U3 為例）：</p><ol><li>進入 vSAN Cluster</li><li>選擇 “Monitor”</li><li>點擊 “Virtual Objects”</li></ol><p><img src="/images/vsan/virtual_obj.png"></p><p>更多 VM 在 vSAN 怎麼部署和分配的資訊，請參考 <a href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vsan-planning.doc/GUID-1D8956A2-3F46-49C8-9231-38F3A9D09A0F.html">Objects and Components</a></p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>VMware vSAN</strong> 是分散式儲存技術，將多個 ESXi 主機的儲存資源組合成一個共享的資料儲存區域。</li><li><strong>Object-based</strong> 儲存系統，數據以物件形式儲存。</li><li><strong>五種類型的物件</strong> 包括 VM Home Namespace 物件、SWAP 物件、VMDK 虛擬硬碟物件、Snapshot Delta VMDKs 和 Memory Object。</li><li><strong>查看虛擬物件</strong> 可以透過命令或進入 vSAN Cluster 監控頁面。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] vSAN的I/O流程</title>
      <link href="/2023/10/12/vsan/ioworkflow_overview/"/>
      <url>/2023/10/12/vsan/ioworkflow_overview/</url>
      
        <content type="html"><![CDATA[<p>接下來我們會根據前面所學的知識，梳理一下端到端 vSAN 的讀取和寫入的 I/O 流程。我們將以儲存 Policy RAID-1, Stripe=2, FTT=1 來討論。Strip 對讀取的影響較大，FTT 對寫入的影響較大。Stripe=2 代表一個 Component 會被分半寫入同個 Host 的兩個 Disk，FTT=1 代表一個 Object 會被分成兩個 Components 寫入兩個 Host。</p><p>這裡快速地複習一下，vSAN 採用的是雙層架構。第一層硬碟是快取層，一般來說會使用 SSD 硬碟作為快取，裡面有 70% 的容量作為寫入緩衝，30% 的容量是讀取快取。</p><p>什麼是寫入緩衝呢？以上述 RAID-1, FTT=1 的模式來說，每當寫入一個 I/O，會寫入兩個 DataGroup。vSAN 定義的一個完整的寫入 I/O 是 Data 寫進去兩個 DataGroup 裡的 SSD 就算完成 I/O 了，所以寫入緩衝只是暫時放在 SSD，準備要寫進去容量層的 Data。</p><span id="more"></span><h3 id="讀取"><a href="#讀取" class="headerlink" title="讀取"></a>讀取</h3><p>在 FTT=1 中，Hybrid 架構中，當資料讀取進行時，會根據硬碟中的 LBA 地址，將不同的資料讀寫請求傳給不同的副本，提升讀的速度。</p><p>當 VM 裡的應用程式發出讀取請求時，CMMDs 會確認 DOM Owner，然後 DOM Owner 會透過 LBA 確認並找到要讀取的 Component，然後向 Component 所在的 LSOM 發送 I/O request。</p><p>由於 SSD 的容量很珍貴，相同的 Object 資料塊最多只會存一份在某個 vSAN 主機內。如果都不在 SSD 裡，就稱為 cache miss，需要去容量層找。如果容量層用的是 HDD，那檢索的效率就會很低。</p><p>在 All Flash 的架構中，由於 SSD 的 I/O 非常快，就算 cache miss 讀數據還是非常快，所以快取層全都拿來做寫入緩衝了。DOM 會先看快取層有沒有經常被存取的寫入緩衝熱資料，有的話再返回，沒有的話就在容量層檢索資料。</p><h3 id="寫入"><a href="#寫入" class="headerlink" title="寫入"></a>寫入</h3><p>在 Hybrid 架構中，當 VM 裡的應用程式發出寫入請求時，Object owner 會把資料寫入他所在的 Host 的快取層內，同時發出請求，把快取層內的東西也寫入進去另一個 Host 的快取層內。當資料預備寫入到容量層的動作要啟動時，就會回傳 ACK 訊號給 Object owner，Object owner 才會跟 VM 裡的應用程式說寫入完成。所以需要注意的是，一個寫入操作不會保證兩個 Host 同時寫入完成，只能保證一個寫入完成代表他們都在寫入緩衝區內了。</p><p>慢慢的，寫入緩衝層越塞越滿，就需要把部分資料寫進去容量層了。vSAN 採用的是電梯式演算法 (Elevator Algorithm)，把寫入緩衝分成多個 Bucket，把相近的 LBA 地址放在同一個 Bucket，當然還會考慮更多因素，例如硬碟使用狀況等等環境因素歸類，以提升寫入容量層的效率。</p><p>All-Flash 和 Hybrid 的寫入方法非常像，只是 All-Flash 是 100% 用於寫入緩衝，Hybrid 是 70% 寫入緩衝。由於快取層的 SSD 還是會經常地被讀寫，所以快取層的 SSD 最好放置耐用性高的 SSD。另外，All Flash 的資料寫入可以啟用 RAID 5/6 達到節省儲存空間的目的，以及重複資料刪除和壓縮的機制。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>vSAN 採用雙層架構，SSD 作為快取層，70% 用於寫入緩衝，30% 用於讀取快取。</li><li>讀取過程中，資料根據 LBA 地址分配到不同副本，提升速度。</li><li>寫入過程中，資料會先寫入快取層，再同步到另一個 Host，最後寫入容量層。</li><li>All-Flash 架構中，SSD 的 I/O 快速提升整體效能，並支持 RAID 5/6 和重複資料刪除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] LSOM (Local log-structured object manager)</title>
      <link href="/2023/10/05/vsan/ioworkflow_lsom/"/>
      <url>/2023/10/05/vsan/ioworkflow_lsom/</url>
      
        <content type="html"><![CDATA[<p>vSAN 的四大 Component - CMMDS、DOM、CLOM、LSOM，從最底層與物理硬碟交互到最上層協同各個 Cluster 裡的 Nodes，彼此各司其職。以下圖為例，本篇將介紹 vSAN CMMDS。</p><p><img src="/images/vsan/vsan_ioworkflow.png"></p><p>vSAN LSOM（Local log-structured object manager）運作在 ESXi node 裡面，負責將 Object 和 Component 放在 ESXi node 裡面，並在資料發生 I/O 時，管理 cache disk 和 capacity disk 的資料 I/O。</p><span id="more"></span><p>由於 LSOM 負責硬碟層的 I/O，它同時也負責監控硬碟的健康狀態。LSOM 使用 Log 的方式從硬碟讀取 Component 並回傳，支援 SSD 和 HDD 的硬碟。LSOM 處理和硬碟最底層的 I/O 交互，通過 Log 記錄寫的順序。例如在 RAID-1 的情況下，對 Object 寫入代表要對兩個不同的 ESXi Node 的 Component 寫入。如果在 Cluster 發生故障前，只有 Node A 記錄到了寫入，那麼就會用 Log 回溯，Node A 會把 Write log 複製給 Node B，達成最終一致性。</p><p>DOM 是實現在 ESXi 的 Kernel 層，負責接收來自 DOM 的 Components 的增刪改查，LSOM 會給予 CMMDS 所有 disk 的 Metadata。</p><p>LSOM 具有以下 Components：</p><ul><li><p><strong>LSOM Logical Log (LLOG)</strong><br>作為 VMFS 與 SSD 互動的橋樑，提供多種 API。</p></li><li><p><strong>Read Cache (RC)</strong><br>負責 cache 的 Policy。</p></li><li><p><strong>LSOM Physical Log (PLOG)</strong><br>作為 cache tier 和 capacity tier 之間的橋樑。</p></li><li><p><strong>SSD Log</strong><br>管理 SSD 的空間和 Read cache，並提供 LLOG、PLOG 和 RC 所需的 log infrastructure。</p></li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>Component 持久化</strong>：Object 下的 Component 存在 LSOM 層，確保 Component 持久化在實體 Disk。</li><li><strong>I/O 處理</strong>：接收來自 DOM Owner 的 I/O，完成寫入後通知 DOM。</li><li><strong>資源管理</strong>：處理 SSD 上的 write buffer、read cache，並將資料寫入 capacity tier。</li><li><strong>專責 I/O</strong>：LSOM 只負責處理 I/O，分散式儲存的其他事務由其他組件處理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> lsom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] CLOM (Cluster-level object manager)</title>
      <link href="/2023/09/30/vsan/ioworkflow_clom/"/>
      <url>/2023/09/30/vsan/ioworkflow_clom/</url>
      
        <content type="html"><![CDATA[<h1 id="vSAN的四大Component-CMMDS、DOM、CLOM、LSOM"><a href="#vSAN的四大Component-CMMDS、DOM、CLOM、LSOM" class="headerlink" title="vSAN的四大Component - CMMDS、DOM、CLOM、LSOM"></a>vSAN的四大Component - CMMDS、DOM、CLOM、LSOM</h1><p>這四個組件從最底層與物理硬碟交互到最上層協同各個Cluster裡的Nodes，彼此各司其職。本篇將介紹的是vSAN CLOM。</p><p><img src="/images/vsan/vsan_ioworkflow.png"></p><span id="more"></span><h2 id="vSAN-CLOM-Cluster-level-object-manager"><a href="#vSAN-CLOM-Cluster-level-object-manager" class="headerlink" title="vSAN CLOM(Cluster-level object manager)"></a>vSAN CLOM(Cluster-level object manager)</h2><p>vSAN CLOM負責根據Policy產生Object Configuration，並將Object裡的Component放在Cluster下適當的ESXi Node裡面。DOM和CLOM之間的溝通緊密無間，且是雙向的。</p><h3 id="vSAN-CLOM的主要特性"><a href="#vSAN-CLOM的主要特性" class="headerlink" title="vSAN CLOM的主要特性"></a>vSAN CLOM的主要特性</h3><p>vSAN CLOM具有以下主要特性：</p><ul><li><strong>物件放置</strong>：CLOM負責根據定義的儲存策略進行物件的初始放置。它決定物件的組件應該位於vSAN集群中的哪個ESXi主機上。</li><li><strong>策略執行</strong>：CLOM確保數據物件的分佈遵從用戶定義的儲存策略。這些策略可以包括關於數據冗餘、條帶化和緩存的規則。</li><li><strong>負載平衡</strong>：CLOM監控vSAN集群的容量和性能，並在必要時重新分佈數據物件以保持平衡。這可能涉及將物件的組件移動到vSAN集群內的其他ESXi主機。</li><li><strong>重新配置</strong>：如果儲存策略發生變化，或者如果從vSAN集群中添加或移除主機，CLOM將重新配置數據物件的分佈以適應新的條件。</li><li><strong>錯誤處理</strong>：如果出現任何錯誤或故障，CLOM會與分佈式物件管理器（DOM）進行通信，以處理情況並確保數據的可用性和完整性。</li></ul><h3 id="DOM和CLOM的溝通"><a href="#DOM和CLOM的溝通" class="headerlink" title="DOM和CLOM的溝通"></a>DOM和CLOM的溝通</h3><p>DOM負責傳送帶有Policy info的請求給CLOM，而CLOM則負責回傳結果或是Error message給DOM。兩者之間透過一個專用的vmkernel protocal進行溝通。</p><h3 id="CLOM的性能和任務"><a href="#CLOM的性能和任務" class="headerlink" title="CLOM的性能和任務"></a>CLOM的性能和任務</h3><p>CLOM的首要任務是確定Object最初的擺放位置，然後再根據DOM給的Policy決定Component要放在哪裡。此外，CLOM也要負責balance的問題，當一個ESXi Node或是Disk裡的使用容量或是Components過多時，需要做平衡，並遷移Component到較為空閒的Node。</p><h3 id="CLOM的daemon"><a href="#CLOM的daemon" class="headerlink" title="CLOM的daemon"></a>CLOM的daemon</h3><p>在vSAN cluster裡，每個vSAN node都會運作一個clomd的daemon，負責確認每個vSAN node裡DOM的configuration是否合乎標準，同時還需要與CMMDS相互溝通。</p><h2 id="CLOM的特性"><a href="#CLOM的特性" class="headerlink" title="CLOM的特性"></a>CLOM的特性</h2><p>CLOM是在ESXi userspace層實現的，具有以下特性：</p><ul><li>負責編排Object和Component</li><li>保證Object的編排能滿足Policy的需求</li><li>當Policy或Configuration或環境變了，也需要調整Object和Component的編排需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> CLOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] DOM (Distributed Object Manager)</title>
      <link href="/2023/09/21/vsan/ioworkflow_dom/"/>
      <url>/2023/09/21/vsan/ioworkflow_dom/</url>
      
        <content type="html"><![CDATA[<p>vSAN 的四大組件：CMMDS、DOM、CLOM、LSOM，從最底層與物理硬碟交互到最上層協同各個 Cluster 裡的 Nodes，各司其職。下圖展示了它們的大致交互邏輯，本文將介紹 vSAN 的 CMMDS。</p><p><img src="/images/vsan/vsan_ioworkflow.png"></p><p>vSAN DOM（Distributed Object Manager）顧名思義，就是負責管理 Object 以及分散 Component。</p><blockquote><p>Component 是由 LSOM 管理，會在下一篇提到。</p></blockquote><span id="more"></span><p>舉例來說，最常見的 RAID-1 Policy 會將一個 Object 完整地複製一份，加上原本的，變成兩個 Components，並將這兩個 Components 分散在不同主機或不同 Fault Domain 上。再加上一個 Witness，當 Cluster 發生故障，例如一個 Node 網路出現問題時，Witness 會協調 I/O 請求應該訪問哪個 Component。</p><p>除了 RAID-1，還有更複雜的 RAID-5/6，也是通過 DOM 去協調應該到哪個 Node 存取 Component 資料。</p><p>每個 DOM Object 有兩個角色：DOM Client 和 DOM Owner。每個 ESXi Node 都有這兩個角色，每個 Object 會有一個專屬的 DOM Owner，而 DOM Client 則存在於每個 Object 所在的 Node 上。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>DOM 是在 ESXi kernel 層實現的，具有以下特性：</p><ul><li>vSAN 的 Object 概念存在於 DOM 層，一般稱為 DOM Object。</li><li>DOM Object 根據 RAID Policy 產生 Component 並保證 Component 的數據一致性。</li><li>Component 的位置由 CLOM 管理，Component 內的內容由 LSOM 管理。</li><li>Object 中的 Witness 只有在 Cluster 發生異常時才有作用，作為決定要訪問哪個 Component 的仲裁者。</li><li>負責接收 CLOM 和其他節點的 DOM 指令，並根據指令與 LSOM 交互。</li><li>每個 vSAN ESXi Node 只有一個 DOM Client，所有外部 I/O 都與這個 DOM Client 對接，然後傳遞 I/O 給相應的 DOM Owner。</li><li>每個 Object 都有一個 DOM Owner，負責決定應用程序傳來的 I/O 是否可以被執行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN] CMMDS (Cluster monitoring, membership, and directory service)</title>
      <link href="/2023/09/15/vsan/ioworkflow_cmmds/"/>
      <url>/2023/09/15/vsan/ioworkflow_cmmds/</url>
      
        <content type="html"><![CDATA[<p>vSAN的四大Component - CMMDS、DOM、CLOM、LSOM，他們四個從最底層與物理硬碟交互到最上層協同各個Cluster裡的Nodes，彼此各司其職，大致上的交互邏輯如下圖所示，本篇將介紹的是vSAN CMMDS。</p><p><img src="/images/vsan/vsan_ioworkflow.png"></p><p>vSAN CMMDS（Cluster Monitoring, Membership, and Directory Service）主要運作在ESXi的kernel層。負責在vSAN Cluster和vSAN Node之間，進行探索、維護等監控任務，並管理Cluster裡的各項資源，例如網路、儲存空間、Component數量等。這些Cluster metadata會以key-value形式存在directory中。</p><span id="more"></span><p>由於vSAN是一個分散式儲存系統，directory上面的資料難免會有碰撞和衝突。vSAN CMMDS採取的是master-agent架構，vSAN Cluster會透過Paxos演算法選舉出master node，其他node則為agent。當Object訊息發生異動時，agent會向master node提供更新訊息，由master決定是否要更新。同時，master也會單播（unicast）這些metadata訊息給其他節點。節點彼此間會透過經典的heartbeat傳輸以保證Cluster內的所有node都是健康的。</p><p>vSAN CMMDS為最終一致性架構，意思是如果A對一個Object做寫入或修改，同時B讀取Object的metadata時可能會有過期的資訊。一般來說，1毫秒內可以消除這個資訊不對稱的問題。</p><p>到目前為止，vSAN CMMDS聽起來像是vSAN內部的一個Backend Service，專門搜集Cluster的metadata然後存著。那麼，vSAN的哪個Component會對CMMDS發出request呢？是DOM（Distribute Object Manager）。我們會在下一篇提到DOM。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>CMMDS負責搜集Cluster的metadata，例如網路、儲存空間、Component數量等。</li><li>CMMDS以key-value的形式儲存metadata，各個ESXi host可以query這些資料。</li><li>CMMDS是分散式系統架構，每個node可擔任master、agent或backup的角色。agent向master提供Cluster metadata，master決定是否更新，backup則作為master的備份，萬一master掛掉可以替代。</li><li>CMMDS為最終一致性架構，但Cluster裡的metadata通常可以保證1毫秒內達成一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cmmds </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]FileService &amp; iSCSI</title>
      <link href="/2023/09/07/vsan/vsan_fileservice_iscsi/"/>
      <url>/2023/09/07/vsan/vsan_fileservice_iscsi/</url>
      
        <content type="html"><![CDATA[<p>我們知道vSAN主要是以Object的形式作為儲存單位，存的是VM Object，而Block和File兩個常用的儲存單位也經常被大企業或資料中心所用到。vSAN當然也有暴露相關的接口，這裡來聊聊vSAN裡iSCSI存取block storage和Fileservice存取檔案的原理。</p><h3 id="iSCSI"><a href="#iSCSI" class="headerlink" title="iSCSI"></a>iSCSI</h3><p>首先，SCSI是SAS/SATA的SSD/HDD用於與作業系統溝通的一種interface protocol，本來是需要透過實體接口才能進行存取。後來又制定了可以透過網路TCP/IP來傳送SCSI指令的技術，叫做iSCSI，使得連接距離可以達到無上限，連結的伺服器數量也是無限。</p><p>這也是為何vSAN提供此接口的原因。vSAN本質上是一塊專用儲存網路，形成了一個儲存池，外部應用可以隨時取用、擴容等等。像是Thin provision，vSAN加上iSCSI技術，把儲存變成「可路由」的，像普通的網路通信一樣，使得遠在天邊的應用或主機可以直接存取vSAN上的儲存池。</p><p><img src="/images/vsan/iscsi_edit_target.png"></p><span id="more"></span><p>在vSAN中，開啟iSCSI服務後，會產生一個home object for iSCSI去存一些相關的metadata。</p><p><img src="/images/vsan/iscsi_add_target.png"></p><p>iSCSI服務啟動後，我們可以到vSAN Cluster→Configuration→iSCSI Target→add新增一個iSCSI Target。我們可以把iSCSI target當成一個vSAN的endpoint。</p><p><img src="/images/vsan/iscsi_add_lun_to_target.png"></p><p>最後，我們可以根據iSCSI target分配LUN的ID。LUN的單位就是一個磁碟，這種感覺就像是在一個磁碟組下面創建一個磁碟。</p><h3 id="Fileservice"><a href="#Fileservice" class="headerlink" title="Fileservice"></a>Fileservice</h3><p>我們也能基於vSAN Datastore提供NFS的服務，這是vSAN 7的新功能。vSAN上的File service是一個分散式的檔案系統(VDFS)，主要的目的是提供VM間的檔案共用，當然也可以像NAS那樣在自己的電腦上掛載一個NFS。</p><p><img src="/images/vsan/file_service_structure.png"></p><p>從上圖可以看到vSAN FileService是共用vSAN儲存的。當然，ESXi node上必須啟用一台File service node VM，把Object轉換成File格式，也就是上圖的綠色Applicance VM，最後整合在一起，給Clients或VM透過SMB/NFS共享檔案池。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>vSAN 支援 iSCSI，使得遠端應用或主機能夠直接存取 vSAN 儲存池。</li><li>啟用 iSCSI 服務後，可以在 vSAN 中設定 iSCSI Target 和 LUN。</li><li>vSAN 7 提供了 NFS 服務，透過分散式檔案系統 VDFS 來實現 VM 間的檔案共用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> fileservice </tag>
            
            <tag> iscsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]Datacenter級別的異地備援 - Stretched Cluster</title>
      <link href="/2023/08/25/vsan/vsan_stretched_cluster/"/>
      <url>/2023/08/25/vsan/vsan_stretched_cluster/</url>
      
        <content type="html"><![CDATA[<p>前面說到了 Fault Domain，我們可以把相同機櫃的 host 匡列成同個 Group，這樣 Object 下的 Component 就會被分散在不同機櫃裡。但如果擔心地震、火災等自然災害會讓整個 Datacenter 遭殃，不就會造成永久的 Data loss 嗎？</p><p>Stretched Cluster 是一種異地備援機制，可以建立兩個位於不同地區的 Datacenter 作為 Fault Domain。不過由於跨地區，Witness 必須是獨立於 Cluster 之外的 Host，可以是單個，也可以是多個。</p><span id="more"></span><p>由於是跨地區的 Datacenter 備份機制，規定了兩個 Datacenter 之間的互相 ping 時間必須在 5ms 以內，而且只能設定兩個 Fault Domain：Preferred 和 Secondary Domain。由於只有兩個 Domain，所以 FTT 只能設定為 FTT=1，RAID 只能設定為 RAID-1。</p><p>接下來說說在 Stretched Cluster 中，資料是如何進行 I/O 的。Preferred Domain 為主要進行 I/O 的對象，對於寫入，為了確保資料的一致性，只有當資料成功寫入兩邊的 SSD 時，才算是寫入完畢。</p><p>針對資料讀取的部分，vSAN Stretched Cluster 支援 Site Read Locality，會優先讀取離自己最近的資料。</p><p>而 Witness 作為一個節點或一個 Fault Domain，它的作用是在 Datacenter 發生故障時，作為 tiebreaker 仲裁，決定當 VM 的 I/O 過來時，要去哪個 Datacenter 存取，主要是在故障發生後保證整個系統的可用性。</p><h2 id="故障種類"><a href="#故障種類" class="headerlink" title="故障種類"></a>故障種類</h2><h4 id="一個-Datacenter-故障"><a href="#一個-Datacenter-故障" class="headerlink" title="一個 Datacenter 故障"></a>一個 Datacenter 故障</h4><p>當一個 Datacenter 出現異常時，例如掉電或失去與 Witness 的聯繫，Witness 會把路由導向健康的 Datacenter。</p><h4 id="兩個-Datacenter-之間失去聯繫"><a href="#兩個-Datacenter-之間失去聯繫" class="headerlink" title="兩個 Datacenter 之間失去聯繫"></a>兩個 Datacenter 之間失去聯繫</h4><p>當兩個 Datacenter 出現網路問題，但各自都能連上 Witness，所以都覺得自己是健康的。這時需要 Witness 作為仲裁，投下關鍵的一票，指定誰是外部的存取對象。</p><h4 id="Witness-node-故障"><a href="#Witness-node-故障" class="headerlink" title="Witness node 故障"></a>Witness node 故障</h4><p>如果只有 Witness node 故障，Datacenter 裡的 VM 還是可以照常運行，只是會在 vCenter 上的 vSAN Health 監控平台提醒恢復 Witness node。</p><h4 id="Witness-node-和一個-Datacenter-故障"><a href="#Witness-node-和一個-Datacenter-故障" class="headerlink" title="Witness node 和一個 Datacenter 故障"></a>Witness node 和一個 Datacenter 故障</h4><p>當這種情況發生時，只能人工介入，在 vCenter 上的 vSAN Health 監控平台會對其進行報警。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>Fault Domain 可以將相同機櫃的 host 歸類為同一個 Group，確保資料分散。</li><li>Stretched Cluster 提供異地備援機制，Witness 作為獨立於 Cluster 的 Host。</li><li>資料 I/O 主要由 Preferred Domain 處理，確保資料一致性。</li><li>Witness 主要在故障發生時進行仲裁，保證系統可用性。</li><li>常見故障包括單一 Datacenter 故障、兩個 Datacenter 之間失聯、Witness node 故障、Witness node 和 Datacenter 同時故障。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的是怎麼做分散式儲存的</title>
      <link href="/2023/08/13/vsan/vsan_policy_layout/"/>
      <url>/2023/08/13/vsan/vsan_policy_layout/</url>
      
        <content type="html"><![CDATA[<p>我們知道，vSAN是一個以Policy為基礎的分散式儲存系統。vSAN會根據Object設定的Policy，把Object下的Component妥善地分散在不同Host上。</p><p>Policy指的就是RAID 0/1/5/6，目前常見的有這四種。RAID 5/6由於需要進行erasure coding和XOR操作，會耗費一些計算資源和I/O，所以只有在使用all flash架構時才能設定。</p><span id="more"></span><p>一般來說，Policy除了設定RAID 0/1/5/6，還可以設定FTT（Failures To Tolerate）。RAID設定的目的是調整怎麼對資料進行備份，而FTT則是設定能容忍幾台Host故障。例如，可以設定RAID 1和FTT=2。RAID 1的寫入邏輯是寫多份，由於FTT=2，vSAN會對資料一模一樣地寫三份，這樣才能容忍三個Host掛掉。</p><h3 id="Fault-Domain"><a href="#Fault-Domain" class="headerlink" title="Fault Domain"></a>Fault Domain</h3><p>我們把Object下的Component分散在不同的Host目的是為了安全。如果一台Host掛了，資料也不會丟失。但是現在的主機可能是機架式的，這意味著機架掉電會讓整個機架上的Host都掛掉。如果Object下的所有Components都放在同個機架上怎麼辦？</p><p>我們可以對一組Host進行Group，這一組Host稱為Fault Domain。這樣一來，如果設定RAID 1和FTT=1，Object下的兩個Component加上Witness就會分散在不同的Fault Domain。注意，vSAN Cluster至少需要三台Host，也就是說如果要設定Fault Domain，至少需要三個Fault Domain。</p><p>那接下來有個疑問了，如果我想做Datacenter層級的備份呢？如果Datacenter失火了，我想要兩個Datacenter，並把Component分配在這兩個Datacenter？這時候就需要Stretched Cluster來解決這個問題。</p><h3 id="Object如何從異常中恢復"><a href="#Object如何從異常中恢復" class="headerlink" title="Object如何從異常中恢復"></a>Object如何從異常中恢復</h3><p>當vSAN偵測到異常事件，例如Host掉電、Disk損壞、網路異常等，vSAN會確認故障的設備存放哪些Component，並嘗試對這些Component進行修復，同時將資料I/O導向健康的Component。</p><p>遇到不同的異常事件，vSAN會採取不同的應對方式，優先重建Component。如果無法重建，例如vSAN Cluster只有三個Host且Policy是FTT=1且一個Host掛了，就會標記為無法重建。以下列舉幾個在vSAN中定義的Object狀態：</p><ul><li>Inaccessible<ul><li>vSAN的Object無法重建，需要人工干預和排查Root Cause，屬於嚴重錯誤。</li></ul></li><li>Unassociated<ul><li>當vSAN裡的Object沒有和某一台VM關聯起來，就會被判定為unassociated。</li><li>VMware KB: <a href="https://kb.vmware.com/s/article/70726">https://kb.vmware.com/s/article/70726</a></li></ul></li><li>Reduce availability<ul><li>vSAN正在重建Object使之符合Policy Compliance，短暫時間無法取用Object。有時候可以立即重建，有時候需要等待一段時間（預設值為60分鐘）。</li></ul></li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>vSAN是一個以Policy為基礎的分散式儲存系統</li><li>Policy設定包括RAID 0/1/5/6和FTT</li><li>Fault Domain用於提升資料安全</li><li>Stretched Cluster適用於Datacenter層級的備份</li><li>vSAN會自動應對異常事件並嘗試修復Component</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的儲存基本單位 - Object</title>
      <link href="/2023/07/29/vsan/vsan_distributed_object/"/>
      <url>/2023/07/29/vsan/vsan_distributed_object/</url>
      
        <content type="html"><![CDATA[<p>再讓我們把主題切回vSAN。現在我們有了儲存系統 - Object Storage的基本知識後，我們可以更深入的探討vSAN是怎麼存Object的。</p><p>vSAN是一種軟體定義儲存的產品，它的儲存單位是Object。Object是什麼呢？回到Day 06，Object可以理解為一個巨大的資料夾，每個檔案就是一個Object，所以搜索Object資料不用一個個資料夾找。今天我們更深入的來理解所謂的「軟體定義」以及Object/Component在vSAN裡面代表著什麼。</p><span id="more"></span><p>從傳統的儲存架構來說，我們想對硬碟裡面的資料進行備份，必須透過硬體RAID卡來進行，這就有了缺點。例如，如果我想對這台虛擬機用RAID 1的方式備份三份，對另外一台虛擬機不需要備份，只需要RAID 0即可，這對於硬體的管理成本非常巨大且可能有資源的浪費。</p><p>vSAN裡的「軟體定義」就是指User可以針對這個Object定義他的備份Policy，透過Policy驅動指定備份的方式。透過軟體定義的方式就更方便更彈性多了，VM不受硬體的約束，可以隨時的指定VM的備份Policy。</p><p>講完了Object，最後來說說Component。Component在vSAN中分別代表什麼概念呢？</p><p>假如我們在vSAN有一台虛擬機，其中他的VMDK就是一個Object，裡面存放著虛擬硬碟的資料。我們想對他做一份完整的備份，使用RAID 1，也就是FTT=1。RAID 1前面有提過，這裡就不贅述，FTT 1代表可以容忍一個節點失誤。這樣一來，我們總共需要兩個節點放這個Object，Object變成兩份一模一樣的Components，分散在不同主機上，如下圖所示。</p><p><img src="/images/vsan/vsan_object_component_layout.png"></p><p>從上圖可以看到，兩個Components的資料一模一樣，只是被分配在不同的主機上。再加上一個Witness見證節點，Object的metadata就是存在Witness的。我們知道Object的metadata有個重要的功能就是引導Object資料的位置，所以Witness負責當外部Object request過來之後，判斷要從哪個節點拿Component，以免發生腦裂現象或是兩台主機連不上線的時候。</p><p>順帶一提，在vSAN中，預設的Object儲存方式就是RAID 1，FTT-1，所以最小的vSAN Cluster配置是三台主機。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>vSAN是一種軟體定義儲存的產品，使用Object作為儲存單位。</li><li>傳統硬體RAID卡有管理成本高、資源浪費等缺點。</li><li>vSAN的軟體定義儲存讓User可以更靈活地定義備份Policy。</li><li>Component在vSAN中代表Object的複製品，分散在不同的主機上。</li><li>預設的Object儲存方式是RAID 1，FTT-1，最小的vSAN Cluster配置需要三台主機。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> object </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]儲存最速的Protocol - NVMe</title>
      <link href="/2023/07/16/vsan/ssd_nvme_overview/"/>
      <url>/2023/07/16/vsan/ssd_nvme_overview/</url>
      
        <content type="html"><![CDATA[<p>Disk 由於晶圓問題、 firmware 問題、 driver 問題等等會造成一定機率上的故障。如果一塊硬碟每天的故障機率是 1%，那麼一座資料中心假如有一萬個 disk，代表每天有一百塊硬碟損壞。當然， vSAN 對於部分類型損壞會嘗試自動修復，這樣能夠大幅減少許多人力成本，畢竟大部分的問題重開機就能解決。</p><p>LSOM 是最底層與硬碟打交道的 component。他的 DDH (Degraded Device Handling) service 可以幫忙監控硬碟狀態，當 DDH 偵測到 disk 即將要故障或損壞事件時，就會把 disk 標記為有問題的裝置，讓它不再參與資料的 I/O 流程。更多細節可以參考 VMware KB：<a href="https://kb.vmware.com/s/article/2148358">https://kb.vmware.com/s/article/2148358</a></p><p>NVMe 是一種主機與 SSD 之間溝通的協議。前面說到 PCIe 有三層， NVMe 屬於第四層，是協議中的最高層，如下圖所示。</p><p><img src="/images/vsan/nvme_structure.png"></p><span id="more"></span><p>NVMe 作為應用層協議，理論上可以配所有物理接口協議。但是 NVMe 起初的設計是根據 PCIe，因此後面都是基於 NVMe+PCIe 進行探討。</p><p>NVMe 協議是為 SSD 所生，就像古代的軍師，運籌帷幄，決勝千里，將設計好的計謀交給手下大將執行，也就是 PCIe。 NVMe+PCIe 這兩個天作之合無疑在 SSD 領域中是最強的組合。</p><h3 id="NVMe-over-Fabrics"><a href="#NVMe-over-Fabrics" class="headerlink" title="NVMe over Fabrics"></a>NVMe over Fabrics</h3><p>在傳統的儲存伺服器中，我們利用 iSCSI 透過網路連結遠端的硬碟，形成一個儲存池，如下圖所示。</p><p><img src="/images/vsan/storage_overall_structure.png"></p><p>這樣做的好處是非常節省成本，只需要使用 Ethernet 和成熟的 iSCSI 協議即可。然而，這樣的方式會帶來一個問題： NVMe+PCIe 的速度非常快， throughput 可以達到 10us，而 iSCSI 的極限則是 100us。這就像是把一台法拉利跑車放在台北市上班時段的建國高架橋上，縱使引擎再快，也發揮不出來。</p><p>NVMe over Fabrics 就是為了解決這個問題。它指定了 Transaction Layer 的協議，例如 RDMA 和 PCIe Fabrics 的技術，不過需要專用的硬體網路設備。在眾多的 Transaction Layer 協議中，值得介紹的是 RDMA。 RDMA 是遠端 DMA，它透過網路將資料直接傳入主機的儲存區，不需要 CPU 一個個編碼和解析協議，進而降低了 CPU 的工作量。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>Disk 故障可能由多種原因造成， vSAN 會自動修復部分損壞。</li><li>LSOM 的 DDH 服務能監控硬碟狀態，避免故障 disk 參與 I/O 流程。</li><li>NVMe 作為 SSD 專屬協議，與 PCIe 搭配是最強組合。</li><li>NVMe over Fabrics 解決了傳統 iSCSI 的性能瓶頸問題。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
            <tag> nvme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]SSD PCIe接口</title>
      <link href="/2023/07/09/vsan/ssd_pcie_overview/"/>
      <url>/2023/07/09/vsan/ssd_pcie_overview/</url>
      
        <content type="html"><![CDATA[<p>PCIe 是 SSD 一項重要和主流的接口技術，所以我們有必要對 PCIe 有深入的了解。</p><p>PCIe 從第一代到最近 2022 年第六代的規格問世，速度越來越快。相比於 SAS/SATA，PCIe 資料傳輸的「高速公路」更多，最多可以有 32 個 Lane，而 SAS/SATA 只能有一個 Lane。所以我們可以說，PCIe 的速度就是 Lane 的數量 x 單條 Lane 的速度。</p><h3 id="PCIe-拓樸結構"><a href="#PCIe-拓樸結構" class="headerlink" title="PCIe 拓樸結構"></a>PCIe 拓樸結構</h3><p>PCIe 採用的是樹形拓樸結構，如下圖所示：</p><p><img src="/images/vsan/pci_topology.png"></p><p>Root Complex 是樹的根，服務於 CPU。Root Complex 能存取 PCIe 設備，也能存取記憶體。</p><span id="more"></span><p>所以具體來說，Root Complex 的 spec 是什麼呢？其內部結構很複雜，PCIe Spec 並沒有規定 Root Complex 應該具備什麼功能或不應該具備什麼功能。我們可以把 Root Complex 想像成一台筆記型電腦，外部的 PCIe 設備就像 USB 插槽。如果插槽不夠用，我們需要擴充更多設備，就需要一個 Switch，這就像是一個 USB Hub。</p><h3 id="PCIe-分層結構"><a href="#PCIe-分層結構" class="headerlink" title="PCIe 分層結構"></a>PCIe 分層結構</h3><p>PCIe 作為一個資料通訊接口，某種意義上與跨主機的網路接口類似，都需要分層處理各種複雜的問題。網路有 TCP/IP 五層協議，而 PCIe 則定義了三層：Physical Layer、Data Link Layer 和 Transaction Layer，如下圖所示：</p><p><img src="/images/vsan/pci_layer.png"></p><p>和網路通信一樣，PCIe 也是以 Packet 的形式傳輸，每一層都有固定的格式。</p><p><strong>Physical Layer</strong></p><p>負責處理 Packet 的物理傳輸，包含如何分配到各個 Lane 傳輸以及匯總。</p><p><strong>Data Link Layer</strong></p><p>主要負責 Data 的檢錯和糾錯，以及電源管理等功能。</p><p><strong>Transaction Layer</strong></p><p>主要負責創建 Packet、流量控制、QOS 和事務排序等工作。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>PCIe 是 SSD 的主流接口技術，速度隨著代數提升而增加。</li><li>PCIe 採用樹形拓樸結構，Root Complex 是其核心。</li><li>PCIe 分為三層結構，分別處理物理傳輸、資料連結和事務處理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]電子儲存介質 - SSD的介紹</title>
      <link href="/2023/06/30/vsan/ssd_overview/"/>
      <url>/2023/06/30/vsan/ssd_overview/</url>
      
        <content type="html"><![CDATA[<p>科技日新月異，第一款商用SSD固態硬碟於1991年問世，當時大小只有20MB，然而由於價格太貴，一直到2007年，才開始產生主流需求。在SSD大行其道之前，主要是HDD的天下。到了2022年，SSD單位容量的成本越來越低，所有有興趣想涉略儲存領域的人都必須了解SSD。</p><p>SSD和HDD最大的差別就是「介質」的不同。HDD使用「磁」的正負極記錄0和1的資料，而SSD使用的是「電子」正負極代表0和1，這間接影響了尋址的速度。HDD需要一個磁碟頭在磁盤上逐一掃描，而SSD利用電子，能快速定位目標地址，這也說明了為何SSD相較於HDD有這麼大的I/O速度差異。</p><span id="more"></span><table><thead><tr><th>比較項目</th><th>SATA HDD</th><th>SATA SSD</th><th>差別</th></tr></thead><tbody><tr><td>平均開機時間</td><td>27秒</td><td>8秒</td><td>x3.5</td></tr><tr><td>連續讀/寫(MB/s)</td><td>160 / 60</td><td>540 / 330</td><td>x3 / x6</td></tr><tr><td>隨機讀/寫時間(IOPS)</td><td>450/400</td><td>98000 / 70000</td><td>x217 / x175</td></tr><tr><td>讀寫功耗(W)</td><td>6</td><td>5</td><td>x1</td></tr><tr><td>重量</td><td>120g</td><td>80g</td><td>x1.5</td></tr><tr><td>每GB成本(NTD$)</td><td>1.3$</td><td>2.3$</td><td>x2</td></tr><tr><td>介質</td><td>磁性介質</td><td>電子介質</td><td></td></tr><tr><td>讀取寫入</td><td>磁頭+馬達</td><td>SSD控制器</td><td></td></tr><tr><td>耐震程度</td><td>低</td><td>高</td><td></td></tr></tbody></table><p>如今HDD已經非常成熟，但SSD還有巨大的進步空間。製程的進步使得晶片密度越來越高，相同尺寸能容納更多容量。另外，SSD裡面有controller，也就是FTL (Flash Translation Layer)，軟體的迭代升級也能加速SSD的I/O速度。</p><p>SSD使用的半導體元件是NAND Flash，是一種非易失性儲存技術，即使斷電資料也會保存。NAND Flash在SSD的排列最小單元為多個bits，根據有幾個bits目前主流有1個至4個，分別為SLC、MLC、TLC和QLC。每次對資料進行I/O，只能對最小單元的所有bits同時操作，這也造就了SLC的I/O速度最快但單位容量最貴，而QLC的速度最慢但單位容量最便宜。</p><p>SSD有個致命的缺點，就是NAND Flash有一定的讀寫數量限制。對同一塊NAND Flash有過多頻繁寫入，會影響SSD的使用壽命。因此在SSD內，假如500GB好了，會預留一小塊空間作為SSD的firmware，當有I/O過來時，依靠演算法負責「均勻」地對每一塊NAND Flash進行寫入和擦除。</p><p>有了上述基本知識後，簡單介紹一下電腦上的一次I/O是如何與SSD固態硬碟交互的，如下圖所示：</p><p><img src="/images/vsan/ssd_structure.png"></p><ol><li>使用者使用鍵盤滑鼠在電腦上對資料進行讀取/寫入。</li><li>電腦的作業系統上的檔案系統會將使用者的操作翻譯成與硬碟交互的Block storage I/O指令。</li><li>藉由Interface協議，將I/O指令傳遞給SSD的Controller。<ol><li>目前SSD有三種Interface協議，分別為SAS，SATA和PCIe。SAS和SATA比較舊，無法發揮NAND的極速。目前PCIe搭配NVMe的SSD越來越主流，能發揮NAND的性能。</li><li>PCIe是接口，NVMe是傳輸協議。</li><li>SATA是接口也是傳輸協議，SATA一般是家用，目前可以達到6GB/s。</li><li>SAS是接口，用的是SCSI傳輸協議，SAS一般是企業用。</li></ol></li><li>SSD Controller (FTL)根據要寫入的I/O，判斷寫入或讀取哪個Block。<ol><li>SSD Controller對NAND Flash的操作有讀取、寫入和擦除。注意，如果要對該NAND Flash上的資料進行「更新」，必須要先擦除後才能寫入。</li><li>影響NAND Flash壽命的就是擦除次數。</li><li>Controller的工作就是讓擦除次數盡量減少，並均勻分配在每一塊NAND Flash上。</li></ol></li><li>透過Interface協議，將資料一路返回到電腦作業系統。</li></ol><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>SSD與HDD最大的差別在於介質的不同，導致了速度上的巨大差異。</li><li>SSD的成本逐年下降，逐漸成為主流儲存設備。</li><li>SSD的NAND Flash技術雖然有讀寫次數限制，但透過Controller的優化，能有效延長壽命。</li><li>PCIe搭配NVMe的SSD成為主流，能最大限度發揮NAND Flash的性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssd </tag>
            
            <tag> disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN的硬碟如何擺放達到讀寫最佳化？</title>
      <link href="/2023/06/17/vsan/vsan_diskgroup_overview/"/>
      <url>/2023/06/17/vsan/vsan_diskgroup_overview/</url>
      
        <content type="html"><![CDATA[<p>VMware於2014年發表了vSAN，在當時HDD仍然是主流，SSD雖然速度快但是成本高昂。為了達到速度快並且節省成本的目的，vSAN cluster採用了雙層儲存架構，如下圖所示：</p><span id="more"></span><p><img src="/images/vsan/diskgroup_twolayer.png"></p><p>磁碟群組的入口是SSD，SSD只存放HDD的Cache資料，其中70%的容量用作Read Cache，30%的容量用作Write Cache。每個磁碟群組最多可以放7個HDD device，每個Host最多支持5個磁碟群組，所以一個Host最多可以有49個容量磁碟。</p><p>當然，我們也可以在維持相同的雙層儲存架構下，把所有HDD替換成SSD，也就是All Flash，全閃存模式。啟用了全閃存模式後，vSAN Cluster可以支援更多功能，例如Compression、deduplication、RAID-5/6等等功能。</p><p>這種雙層架構的缺點是如果唯一入口SSD掛了，後面的HDD容量層都不能使用。另外，Hybrid和All Flash模式下的cache演算法和角色也不完全相同。</p><ul><li><p><strong>Hybrid模式</strong>：</p><ul><li>快取演算法著重於「暫時資料」</li><li>外部的I/O會先寫入SSD，然後立即回傳I/O成功，再透過非同步方式把資料寫入容量層</li><li>快取層同時擔任「讀取快取」和「寫入緩衝」的角色</li></ul></li><li><p><strong>All Flash模式</strong>：</p><ul><li>快取演算法著重於「熱資料」</li><li>快取層全部負責寫入緩衝，讀取快取則放在容量層</li><li>由於全部都是SSD，讀取速度非常快</li></ul></li></ul><p>寫入緩衝的意思是資料不會直接寫進容量層，而是會在快取層停留一段時間，這樣做的目的是維持vSAN物件的可用性。當vSAN對一個物件寫入資料時，通常會在FTT&gt;1的情況下，對至少兩個host寫入，當寫入兩個host的SSD時，才會真正寫入容量層。</p><h3 id="總結："><a href="#總結：" class="headerlink" title="總結："></a>總結：</h3><ul><li>vSAN採用雙層儲存架構，以SSD作為Cache層，HDD作為容量層</li><li>支援Hybrid和All Flash模式，兩種模式下cache演算法不同</li><li>SSD掛了會影響HDD容量層的使用</li><li>All Flash模式下支援更多進階功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的存取形式? DAS、NAS和SAN</title>
      <link href="/2023/06/04/vsan/storage_protocol_overview/"/>
      <url>/2023/06/04/vsan/storage_protocol_overview/</url>
      
        <content type="html"><![CDATA[<p>前面分別講了資料儲存的最小單元、硬碟陣列怎麼做備份以及提高可用性，接下來安迪想講的是儲存系統架構 - DAS、NAS和SAN</p><h3 id="DAS"><a href="#DAS" class="headerlink" title="DAS"></a>DAS</h3><blockquote><p>DAS(Direct Attach Storage) - 本地的檔案系統</p></blockquote><p>DAS可以理解為就是本地的磁碟陣列，透過USB，你的個人電腦或伺服器就可以連結到這個磁碟陣列，根據RAID卡，進行相應的備份，當然，他的缺點就是需要有一條實體USB線，且擴充容量等比較麻煩。</p><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><span id="more"></span><blockquote><p>NAS - 網路上的檔案系統</p></blockquote><p>接下來會分享兩個常用的雲端基礎架構NAS和SAN的原理和不同之處，NAS和SAN都是利用網路來連接的，簡單來說NAS適合在家裡使用或小範圍同個網段下使用，而SAN適合大範圍甚至外網使用。</p><p>從NAS說起，NAS的原理就是之前提到的File storage，只是我們一般在使用Windows的時候，硬碟都在電腦裡的，不透過網路就可以直連，NAS就是一個把硬碟抽離出來，放在網路上，透過網路存取硬碟的技術架構。</p><p>下圖是NAS的架構</p><p><img src="/images/vsan/nas_overview.png"></p><p>我們可以看到，是什麼東西在網路上傳遞呢？是檔案系統的指令，我們雖然只需要告訴檔案系統路徑+檔案名稱即可，但是檔案open需要讀吧，所以傳遞了open指令、read指令等，這些都需要網路傳輸，相比於SAN(下一篇會講)把這些都做在主機上，記憶體的傳輸效率一定比網路高。</p><p>用人話說就是 - 程式跟自己的電腦說，幫我把/mnt/nas.txt傳到電腦的記憶體，這些話都透過TCP/IP傳輸，然後NAS上的檔案系統根據這個檔案找到佔用了哪個扇區，從本身的server的硬碟找檔案。</p><p><strong>優點</strong></p><ol><li>成本低 - NAS只需要一般的Ethernet，好擴增，只要有IP的地方就可以提供服務。</li><li>資源獨立 - 檔案讀寫都需要記憶體和CPU資源，有了NAS可以把這些資源抽離出來集中管理。</li><li>易共享 - 可以理解為大家都能連上你的D槽，不怕難分享。</li><li>協議多元 - 舉凡是FTP或是HTTP等都可以使用。</li></ol><p><strong>缺點</strong></p><ol><li>速度慢 - 因為文件系統的指令複雜，可能使用者的一個操作代表很多個指令，不過最大的瓶頸還是底層的Ethernet通常比較慢，NAS一般也不會使用光纖網路。</li><li>不支持遠距離 - 由於上述原因，如果遠距離傳輸會更慢，另外，文件系統on the fly傳輸本身就不安全。</li><li>不可靠 - 文件系統難以做到多機器保護。</li></ol><h3 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h3><blockquote><p>SAN - 網路上的硬碟</p></blockquote><p>安迪的工作就是開發公司的SAN產品，所以安迪對他比較了解。</p><p>SAN就是空出一個網路區域，讓硬碟機櫃互相連接，網絡專給I/O使用的一塊區域網絡，外部的伺服器或個人電腦可以透過網路的方式連進去存取資料。</p><p>下圖是SAN的架構</p><p><img src="/images/vsan/san_overview.png"></p><p>從上圖可以看出，有別於NAS，SAN就是個block storage，接受block storage的指令，回傳資料，檔案系統的指令和演算法是在前端主機完成的。</p><p>用白話文說就是 - 程式跟自己的電腦說，幫我把/mnt/san.txt傳到電腦的記憶體，檔案系統會計算這個檔案的LBA地址和長度，然後把這個資訊傳給SAN。</p><p>我們可以看到SAN有別於NAS，他在網路傳遞的是I/O指令，透過iSCSI或是NVMe包裝，所以速度較NAS快。</p><p><strong>優點</strong></p><ol><li>支持遠距離 - iSCSI等協議已經非常成熟。</li><li>速度快 - 伺服器與儲存設備傳遞的是I/O指令，較為簡潔。</li><li>可靠性高 - 容易做多機器備份、儲存共享。</li></ol><p><strong>缺點</strong></p><ol><li>貴 - 通常要做SAN了，代表要買很多台機器、好的網路線等等，通常只有大公司才會使用，不過最近iSCSI逐漸流行，以往SAN都透過光纖，現在也能透過Ethernet傳輸了。</li><li>複雜度高 - 要用RAID0 1 5 6呢？要用雙主結點還是主從結點還是一主一備呢？這些都要根據實際場景需求決定。</li><li>不好管理 - 前端要裝專門的SAN管理系統才能使用。</li><li>協議單一 - 只有SCSI協議。</li></ol><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>DAS：本地磁碟陣列，連接簡單但擴充困難。</li><li>NAS：網路上的檔案系統，成本低但速度慢。</li><li>SAN：網路上的硬碟，速度快但成本高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
            <tag> nas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的備份形式? RAID</title>
      <link href="/2023/05/10/vsan/storage_raid_overview/"/>
      <url>/2023/05/10/vsan/storage_raid_overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果資料儲存只是把資料存進去硬碟裡，那就有點單調了，不如我們來加點把戲吧！</p></blockquote><p>資料要存，就要把它存好，萬一硬碟不小心壞了怎麼辦？</p><p>於是有了RAID卡。RAID中文是容錯式硬碟陣列，RAID卡是一個硬體設備，可以理解為它能將多個硬碟組合在一起，利用虛擬儲存技術，形成一個硬碟陣列，用來提升儲存空間和製造冗余。</p><p>分散式儲存很多idea就是從RAID來的，只是RAID是提升機櫃與機櫃之間的可靠性，而一般來說的分散式儲存是透過網路串連不同的儲存裝置，更加靈活。</p><p>常見的RAID層級有RAID 0、RAID 1、RAID 5、RAID 6，本篇只介紹上述幾個基礎的RAID架構，架構圖都是來源於維基百科。</p><span id="more"></span><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>下圖我們可以看到兩個大圓柱，其中一個大圓柱，例如Disk0，就是一塊硬碟，一個小圓柱，例如A1，就是硬碟中的一個Block，我們可以把多個Disk串連，從上層系統來看就是一塊超大硬碟。</p><p><img src="/images/vsan/raid0.png"></p><p>對於RAID 0，資料寫入的方式會把資料分割然後同時寫入A1、A2，寫完換A3、A4同時寫。所以當一塊硬碟壞了，全部都壞了。所以RAID 0最簡單，最快，但是也最不安全，因為它不會做任何備份。</p><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p>RAID 1和RAID 0類似，但是寫入會一次寫入兩份，一段資料過來，先寫兩份到各自左右兩邊的A1，A1寫完再寫A2。所以RAID 1的資料寫入性能是RAID 0的一半，不過只要一個硬碟活著資料都還在。RAID 1可以並聯更多硬碟以增加可靠性，只是相應的寫入效能會更慢。</p><p><img src="/images/vsan/raid1.png"></p><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>RAID 0速度快但不可靠，RAID 1可靠但是硬碟利用率和效能差。所以RAID 1往後都在找一種儲存效能、可靠性和成本兼顧的方式，直到RAID 5才漸漸被市場所接受。</p><p><img src="/images/vsan/raid5.png"></p><p>如上圖所示，RAID 5至少需要三塊硬碟，上圖是四塊硬碟的架構。那RAID 5怎麼存資料呢？從第一排開始，資料來了，一樣先存進去A1、A2、A3，然後我們看到了A_p，他是A1、A2、A3的奇偶校驗資料，這樣當一塊硬碟掛了，可以透過奇偶校驗復原資料。</p><p>我們假設A1, A2, A3上的資料分別為1, 3, 5，透過奇偶校驗，1 XOR 3 XOR 5 = 7，A_p設置為7。</p><p>如果A2不小心壞了，要復原資料，只需要把剩餘的都做XOR計算就能復原資料，1 XOR 5 XOR 7 = 3。</p><p>和RAID 0相比，寫入速度較慢，讀取速度差不多，可靠性好很多。</p><p>和RAID 1相比，需要更多硬碟才能保證可靠度，但是硬碟的利用率高很多，寫入速度也較快。</p><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p>RAID 6和RAID 5非常相似，唯一的差別就是需要比RAID 5多一塊硬碟存放第二個奇偶校驗資料，如下圖所示。</p><p><img src="/images/vsan/raid6.png"></p><p>兩個的奇偶校驗演算法不同，所以RAID 6至少需要四塊硬碟，可以容許兩塊硬碟損壞。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ol><li><strong>RAID 0</strong>：速度最快，但不安全，沒有備份。</li><li><strong>RAID 1</strong>：可靠性高，寫入效能是RAID 0的一半。</li><li><strong>RAID 5</strong>：兼顧效能、可靠性和成本，至少需要三塊硬碟。</li><li><strong>RAID 6</strong>：比RAID 5多一塊硬碟存放第二個奇偶校驗資料，至少需要四塊硬碟。</li></ol>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]資料的儲存形式? Block、File、Object Storage</title>
      <link href="/2023/04/27/vsan/storage_overview/"/>
      <url>/2023/04/27/vsan/storage_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚和安迪説，我大概是明白資料中心的組成了，你能不能再多說說vSAN是怎麼儲存資料呢？他是如何能把我的重要檔案自動備份又能同時取用呢？</p><p>安迪說，當然沒問題！儲存是一個很大的領域，我們只能先從最基本的基礎開始，我會先從三個資料儲存系統 - 區塊儲存系統、檔案儲存系統和物件儲存系統說起，這裡說的系統都是軟體層面上的邏輯，不會深入探討到硬碟。</p><h2 id="Block-storage-區塊儲存系統"><a href="#Block-storage-區塊儲存系統" class="headerlink" title="Block storage(區塊儲存系統)"></a>Block storage(區塊儲存系統)</h2><span id="more"></span><blockquote><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p></blockquote><p>資料在電腦裡是以1和0儲存在某個”介質”上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，也有用光的CD，而Block storage簡單來說就是我們能看到的一塊塊的硬碟和儲存裝置，我們把儲存裝置與我們的電腦連接，我們的電腦透過Block storage的API對裡面的資料進行增刪改查。</p><p>接下來，我們有了作業系統，作業系統他方便了我們把資料存進去Block storage裝置，可以說，作業系統是上層應用與Block storage裝置溝通的橋樑，那麼回答一個問題，作業系統是如何與硬碟打交道呢？</p><p>首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？</p><p>例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也就是說多台主機能共享一個儲存設備，不過一般不會這麼用，因為Block storage的資料隔離沒有做得這麼好，若是同時寫入資料容易被混淆。</p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>那麼block的由來是什麼呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，常見為4096 bytes，這樣的設定的用意是提升資料讀寫的速度，如果一個個byte寫，一來一往速度非常慢。</p><p>對於HDD來說，連續讀寫可以大幅提升I/O速度，然而我們的資料會需要經常性的寫入和刪除，例如我們寫了十筆連續的Block，過一段時間，想把第五個Block資料給刪除，這樣中間就會有空餘的浪費，這樣該怎麼辦呢？</p><p>如果我們時常要求連續讀寫，會造成巨大的資源浪費，所以上層的作業系統會利用Linked-List資料結構把碎片化的Block記錄下來，把整段資料拼湊出來</p><p>一個block對應一個或多個硬體的扇區(sector)，常見的一個sector大小為512 bytes，所以block是給作業系統看的邏輯地址，sector是Block storage上的實體地址。Block大小可以透過作業系統設定，查詢藉由指令<code>stat /boot/ |grep &quot;IO Block&quot;</code> 查詢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat /boot/ |grep &quot;IO Block&quot;</span></span><br><span class="line">Size: 4096          Blocks: 8          IO Block: 4096   directory</span><br></pre></td></tr></table></figure><h3 id="Sector-扇區"><a href="#Sector-扇區" class="headerlink" title="Sector(扇區)"></a>Sector(扇區)</h3><p>sector是Block storage上的實體地址，他也是把多個bytes分組成一個sector，我們拿機械式硬碟HDD舉例，HDD有個針頭會去掃描磁碟，掃描的部分就是一個個扇區，如下圖所示</p><p><img src="/images/vsan/magnectic_disk.png"></p><p>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的”扇區”就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點</p><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><p>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><p><strong>高性能:</strong><br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作公司的database server或數據中心</p></li><li><p><strong>易於修改:</strong><br>如果想改變block裡的一個小部分資料，直接改那個block就可以，如果是檔案系統或object system，需要整個檔案或object都改</p></li><li><p><strong>擴充容易</strong><br>擴充非常簡單，一個LUN ID就可以接上系統了，適合用在SAN(儲存區域網路)裡</p></li></ul><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ul><li><p><strong>不能同時讀寫</strong><br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</p></li><li><p><strong>Metadata</strong><br>Block storage沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</p></li></ul><h2 id="File-storage-檔案系統"><a href="#File-storage-檔案系統" class="headerlink" title="File storage(檔案系統)"></a>File storage(檔案系統)</h2><blockquote><p>有了File storage，就能方便我們寫程式去操作資料！</p></blockquote><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我怎麼知道我的資料的Block存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好，如果是分散存，需要一個Linked-List資料結構去紀錄。</p><p>任何資訊界的難題只需要加一層就可以解決，如果不行，那就兩層，所以我們就加個一層吧！為了讓使用者能夠輕鬆的操作儲存資料，作業系統在Block storage上面加了一層File system。</p><p>我們平常用的Windows為了讓使用者方便存取資料，就是使用File system，這大家應該很熟悉，用滑鼠鍵盤敲一敲點一點就可以對檔案進行存取，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，檔案的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的地方就叫做inode。</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat demo.txt</span></span><br><span class="line">File: ‘demo.txt’</span><br><span class="line">Size: 12            Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770d    Inode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存資料，一個存inode，並且指定inode分區的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><h3 id="作業系統是如何讀取檔案資料？"><a href="#作業系統是如何讀取檔案資料？" class="headerlink" title="作業系統是如何讀取檔案資料？"></a>作業系統是如何讀取檔案資料？</h3><p>首先，不是透過檔案名字，檔案名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，例如上面的<code>demo.txt</code>就是238749826，根據使用者點開的文件找到inode號碼。</p><p>第二，根據inode號碼去資料分區根據inode找到對應的data。</p><p>最後，根據indoe的data，找到檔案裡的資料存在哪個block。</p><h3 id="優點-1"><a href="#優點-1" class="headerlink" title="優點"></a>優點</h3><p>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><p><strong>方便共享</strong><br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</p></li><li><p><strong>安全</strong><br>如上述所示，Linux有三種權限控制 - 自己、組和其他</p></li><li><p><strong>成本低</strong><br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</p></li></ul><h3 id="缺點-1"><a href="#缺點-1" class="headerlink" title="缺點"></a>缺點</h3><ul><li><p><strong>資料讀寫慢</strong><br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</p></li><li><p><strong>難以遷移</strong><br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</p></li><li><p><strong>權限控制</strong><br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</p></li></ul><h3 id="Object-storage-物件儲存"><a href="#Object-storage-物件儲存" class="headerlink" title="Object storage(物件儲存)"></a>Object storage(物件儲存)</h3><blockquote><p>Object Storage - 雲端系統上最流行的儲存方式</p></blockquote><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合，所以Object storage沒有inode這種方式變得更容易索引和訪問。</p><p>Object storage的Metadata就像是File system的inode，用作索引對應的data位置，Object storage可以隨意定義自己的metadata資料結構，幫助快速檢索目標object，甚至是分散在不同主機的data。</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務。</p><p>從high level講，也就是使用方式講，Object storage主要是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用。這些Object實際上可以是任何類型的資料：PDF、影片、音檔、文本、網站資料或任何其他檔案類型。</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要資料分散且「容易」伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個「資料夾」加大了空間。</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的「可靠性」，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如RAID-5這種空間使用率只要150%，但是保護力也有1。</p><h3 id="優點-2"><a href="#優點-2" class="headerlink" title="優點"></a>優點</h3><ul><li><p><strong>方便擴增</strong><br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</p></li><li><p><strong>成本低</strong><br>公有雲端上的Object storage都特別便宜，例如Amazon S3</p></li><li><p><strong>API 簡單</strong><br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</p></li></ul><h3 id="缺點-2"><a href="#缺點-2" class="headerlink" title="缺點"></a>缺點</h3><ul><li><p><strong>不能修改</strong><br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</p></li><li><p><strong>無法和database整合</strong><br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</p></li><li><p><strong>無法與一般作業系統整合</strong><br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]虛擬機？我摸的到嗎？</title>
      <link href="/2023/04/12/vsan/vm_overview/"/>
      <url>/2023/04/12/vsan/vm_overview/</url>
      
        <content type="html"><![CDATA[<p>我的電腦是Windows 10系統，然而有一天，我想懷舊一下玩一個只能在Windows XP的遊戲，該怎麼辦呢？</p><p>抑或是公司有50位員工，所以只好每人派發一台電腦，不可能每台電腦都能把硬碟和計算資源無時無刻用滿，但是我想節省成本，該怎麼辦呢？</p><p>虛擬機就是一個實體電腦的數位版本，讓你可以在作業系統上執行一個不同且獨立的作業系統，這麼一來，就能在Windows 10上運行Windows XP，公司也能透過買一台資源豐富的伺服器，在上面透過虛擬機的方式達到資源最大利用率。</p><p>個人用的虛擬機軟體最有名的當數付費的VMware Workstation和開源版本的VirtualBox。</p><span id="more"></span><p>公司用的虛擬機軟體 (hypervisor) 則多了，有付費的VMware vSphere、Microsoft的Hyper-V等等，還有開源的KVM、Xen等等。</p><p>如今雲端技術非常流行，三大公有雲廠商Amazon AWS、Microsoft Azure以及Google GCP，他們三個其實就是建置了大量的數據中心，把裡面的伺服器裝上虛擬機軟體，讓外部的開發人員或公司虛擬出「多個實體電腦」，按需使用，像是家家戶戶的水電一樣，不用維護高昂的IT成本。</p><p>上述是公有雲的範疇，若公司有資料隱私的要求，例如銀行、醫院、公家機關等等，也可以自己建置數據中心，把資料和計算留在本地，這時需要一套虛擬機管理軟體，也能透過VMware vSphere、Microsoft的Hyper-V等等來建立自己的數據中心。</p><h2 id="虛擬機原理"><a href="#虛擬機原理" class="headerlink" title="虛擬機原理"></a>虛擬機原理</h2><p><img src="/images/vsan/vm_structure.png"></p><p>虛擬機架構示意圖，如上所示，VMM (Virtual Machine Monitor) 是一個軟體，運行在Ring0，也就是CPU上的特權級別，負責給上面的Guest OS提供虛擬化的環境 (CPU, 記憶體和 I/O虛擬化)，VMM會根據Guest OS提供的指令，做出相應的資源分配措施。</p><h3 id="CPU虛擬化"><a href="#CPU虛擬化" class="headerlink" title="CPU虛擬化"></a>CPU虛擬化</h3><p>目的是利用硬件輔助虛擬化技術（以前是用Binary Translator）攔截敏感指令，也就是那些會對整個系統造成影響的指令。有了硬件輔助虛擬化技術，實體CPU會自動攔截敏感指令並交給VMM處理。</p><h3 id="記憶體虛擬化"><a href="#記憶體虛擬化" class="headerlink" title="記憶體虛擬化"></a>記憶體虛擬化</h3><p>主機使用段頁機制，虛擬機有兩層轉換：Guest Virtual Memory -&gt; Guest Physical Memory -&gt; Machine Memory。當然，這部分也有硬體虛擬化輔助技術支持。</p><p><img src="/images/vsan/vm_memory_mapping.png"></p><h3 id="I-O虛擬化"><a href="#I-O虛擬化" class="headerlink" title="I/O虛擬化"></a><strong>I/O虛擬化</strong></h3><p>虛擬各種外接設備（純軟體虛擬化、硬體輔助虛擬化）。硬體輔助虛擬化能讓虛擬機直接使用硬體設備，但具有獨佔性，例如滑鼠和鍵盤就是一種I/O設備，當一台實體電腦只接上一個鍵盤，那它只能在一台虛擬機或是實體機器上進行輸入。</p><h3 id="網路虛擬化"><a href="#網路虛擬化" class="headerlink" title="網路虛擬化"></a><strong>網路虛擬化</strong></h3><p>讓虛擬機同時使用同個網卡，虛擬交換機可以製造虛擬網絡環境，讓一台實體機器上的所有虛擬機共享同個區域網路。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>虛擬機讓多個作業系統同時運行在一台實體電腦上，提升資源利用率。</li><li>常見個人用虛擬機軟體包括VMware Workstation和VirtualBox。</li><li>公司用虛擬機軟體如VMware vSphere和Microsoft Hyper-V則提供更強大的管理功能。</li><li>雲端技術利用虛擬機實現資源的按需使用，降低IT成本。</li><li>虛擬機的技術原理包括CPU虛擬化、記憶體虛擬化、I/O虛擬化及網路虛擬化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]vSAN簡介-VMware產品中的儲存利器</title>
      <link href="/2023/03/25/vsan/vsan_overview/"/>
      <url>/2023/03/25/vsan/vsan_overview/</url>
      
        <content type="html"><![CDATA[<p>VMware擁有自己一套的軟體定義資料中心（SDDC）解決方案，以vSphere作為核心的Hypervisor，提供虛擬儲存和網路服務，其中儲存的部分包含以下幾種：</p><ul><li>Local - VMFS</li><li>NAS - NFS</li><li>iSCSI</li><li>VMware Virtual Volume (VVOL) - 將SAN和NAS虛擬化</li><li>vSAN</li></ul><p>vSAN全名是Virtual SAN，顧名思義，它不是像NAS這樣的遠端檔案系統。這裡我們先介紹SAN是什麼。</p><span id="more"></span><h3 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h3><p>一般來說，我們會把主機上的資料存在主機上的硬碟裡，可能主機A只用了20%的容量，主機B用了50%的容量，這樣主機A和主機B都浪費了很多儲存空間。如果突然有一個主機C需要200%的容量，該怎麼辦呢？</p><p>於是就有了SAN這類的儲存架構。SAN在遠端建立了一個儲存池，讓各個主機共享。儲存池裡面的各個主機透過網路或是光纖連接，是專門用作儲存的網絡區域。SAN和NAS最大的差別在於SAN的檔案系統是保留在主機端，而NAS的檔案系統是在遠端，所以兩者在網路上的傳遞協議會不同。</p><h3 id="vSAN"><a href="#vSAN" class="headerlink" title="vSAN"></a>vSAN</h3><p>vSAN會把所有主機上的硬碟整合成一個儲存池，如下所示：</p><p><img src="/images/vsan/vsan_overall_structure.png"></p><p>我們可以看到，每個vSAN Host（也就是物理機）裡面有若干塊硬碟，只要主機被加入vSAN Cluster，裡面的硬碟資源就會貢獻給vSAN。所以在vSAN上的主機要存取資料，可能是來自主機本身的，也有可能是其他主機的。</p><p>由於vSAN是軟體定義儲存系統，我們能想到的儲存備份、冗余、延伸集群等等都可以透過vSAN軟體實現，而不需要動到硬體，甚至RAID卡也不用。其關鍵技術就是Storage Policy。透過對主機上的虛擬機設定Storage Policy，我們可以指定該虛擬機要做幾份備份，可以容忍多少台主機故障等。此外，由於它是軟體定義儲存，對於主機的擴充非常方便，只要在vCenter（主機叢集的控制面板）「新增主機」，即可為這個叢集增加儲存容量。</p><p>vSAN是採用物件（Object）作為儲存系統。物件儲存系統簡單來說就是沒有資料夾的檔案系統，所以查詢非常快且容易共享及備份。vSAN作為服務vSphere上虛擬機的儲存系統，上面的虛擬機就是一個個物件。除此之外，由於深度和vSphere整合，vSAN同時也支持vSphere HA（High Availability）、vSphere DRS（Distributed Resource Scheduler）和vSphere vMotion（虛擬機不掉電遷移）。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>VMware的vSAN是一種軟體定義的儲存解決方案，整合所有主機的硬碟資源。</strong></li><li><strong>SAN是一種在遠端建立儲存池，讓主機共享的儲存架構。</strong></li><li><strong>vSAN透過Storage Policy實現儲存備份、冗余等功能，擴充方便。</strong></li><li><strong>vSAN採用物件儲存系統，查詢快速，易於共享及備份。</strong></li><li><strong>vSAN與vSphere深度整合，支持多種vSphere功能。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]雲端? 雲端就是資料中心嗎？</title>
      <link href="/2023/01/20/vsan/cloud_storage_overview/"/>
      <url>/2023/01/20/vsan/cloud_storage_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚一聽到資料中心，突然頭暈目眩，因為在他的腦海裡，資料中心就是一個冰冷的屋子裡放滿了各種機器。</p><p><img src="/images/vsan/datacenter.png"></p><p>這些機器就是硬體設備，我們已經可以透過虛擬機的方式，把計算部分軟體化，但是資料中心還有「儲存」需求，要怎麼把它也軟體化呢？</p><p>軟體定義資料中心（Software-Defined Data Center, SDDC）顧名思義，就是利用軟體，把資料中心裡的計算、儲存、網路資源「抽象化」和「虛擬化」。當資源都被虛擬化後，IT管理團隊變得更加靈活了。IT人員可以根據使用者需求，提供更細緻的資源，例如一台CPU 1GHz，20GB容量的電腦，並且這個電腦還能隨時備份。不但提高了服務和應用的「可用性」及「彈性」，同時也降低了對運維的「複雜度」和「預算」，並簡化服務上線的工作流程和應用的推出時間。接下來的重點將會圍繞在「儲存資源」的部分，也就是VMware vSAN產品相關的技術結構。</p><p>一般的常見解決方案大致分為兩類 - 公有雲和私有雲。</p><span id="more"></span><h3 id="公有雲"><a href="#公有雲" class="headerlink" title="公有雲"></a>公有雲</h3><p>常見的如Amazon、Azure、Google Cloud，阿里雲等等，公有雲的好處是資料中心的「硬體設備」可以透過專門的公有雲提供商維護，這樣使用者，也就是工程師們可以專心的開發軟體或應用，不用擔心資料中心遇到水災、斷電或地震等自然災害。</p><p>更重要的是，對於新創公司來說，服務的使用量波動大，若事先買了硬體設備，可能會造成大量的浪費。公有雲的按需使用能滿足小型創業公司的需求。</p><h3 id="私有雲"><a href="#私有雲" class="headerlink" title="私有雲"></a>私有雲</h3><p>常見的如VMware vSAN、Nutanix ADSF、HPE StoreVirtual VSA等等，私有雲的好處是資料幾乎100%安全且存取速度快。不過硬體的選配和維護需要公司內部的人力去處理。一般來說，是銀行、政府等對資料安全性較敏感的單位才會使用私有雲服務。</p><p>其中又能細分「融合式解決方案」和「純軟體式解決方案」。</p><h3 id="融合式解決方案"><a href="#融合式解決方案" class="headerlink" title="融合式解決方案"></a>融合式解決方案</h3><p>購買硬體設備的同時，軟體也已經安裝好，例如Dell VxRail、HPE SimpliVity，這樣省去了安裝和硬體選配的麻煩，直接購買，直接使用。</p><h3 id="純軟體式解決方案"><a href="#純軟體式解決方案" class="headerlink" title="純軟體式解決方案"></a>純軟體式解決方案</h3><p>此方案對於硬體的配置更有彈性，只要符合「硬體相容性清單」，就能在自己的硬體設備上搭建軟體定義儲存的伺服器。</p><h3 id="混合雲"><a href="#混合雲" class="headerlink" title="混合雲"></a>混合雲</h3><p>混合雲的意思就是一部分的應用在公有雲，一部分在私有雲，但是操作介面是同一個。例如VMware與各大公有雲合作 - Amazon, Google, Microsoft, 阿里巴巴。在他們的硬體上安裝VMware的產品，這樣使用者就能在地端和雲端上自由遷移虛擬機和儲存空間。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>SDDC可以使IT管理更靈活，減少運維複雜度和預算。</li><li>公有雲適合新創公司，提供彈性資源使用。</li><li>私有雲適合對資料安全性要求高的單位。</li><li>融合式解決方案方便安裝和使用。</li><li>純軟體式解決方案提供硬體配置彈性。</li><li>混合雲結合公有雲和私有雲的優點，提供一致的操作介面。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[vSAN]雲端，什麼是雲端？</title>
      <link href="/2022/12/05/vsan/vsan_cloud_overview/"/>
      <url>/2022/12/05/vsan/vsan_cloud_overview/</url>
      
        <content type="html"><![CDATA[<p>小羚是一位老師，有一天小羚費盡了功夫，寫好了本學期的教案，她想要備份在安全的地方。小羚想著想著，要存哪好呢？存行動硬碟不太安全，萬一丟了怎麼辦？存自己的電腦，也沒安全感，萬一中毒了怎麼辦？她的男友安迪跟她說，可以買三個行動硬碟，都分別存在裡面呀。小羚回說，這樣子好麻煩，如果我想更新教案裡的某段內容，這樣還要一個個打開來更新。安迪又說，可以存雲端呀！存雲端既不用擔心硬碟損壞，也不用擔心突然有靈感的時候沒辦法隨時修改。</p><p>小羚問安迪，有什麼常見的雲端儲存服務嗎？</p><p>有的，儲存是一個很大的領域，服務的對象也千差萬別，安迪會用兩篇的篇幅介紹，首先會先介紹什麼是「雲」，再來介紹雲端儲存系統。</p><h3 id="那麼，什麼是「雲」呢？"><a href="#那麼，什麼是「雲」呢？" class="headerlink" title="那麼，什麼是「雲」呢？"></a>那麼，什麼是「雲」呢？</h3><span id="more"></span><p>「雲」就是一個大池子，這個池子裡面裝著豐沛的電腦「計算」資源和「儲存」資源，然後透過「網路」的方式，拿到遠端池子裡幫我們運算好或儲存的結果。</p><p>假如我們只想做個簡單的計算，不需要買一台電腦另外算，只需要短暫的租用一下CPU即可。假如我們只想暫時性存個文件，不需要額外買行動硬碟浪費空間，只需要短暫的租用一下硬碟即可。</p><p>雲主要可以分為以下三種服務：</p><ol><li>SaaS</li><li>PaaS</li><li>IaaS</li></ol><p>雲端儲存給使用者使用的「介面」可以區分為以上三個，下面依依來介紹。</p><h3 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h3><p>SaaS（Software as a Service）是雲端中最外層的服務，直接讓使用者能使用的服務，讓使用者能打開瀏覽器透過UI操作，例如Dropbox、Google Doc等等。所以，這也是小羚適合使用的服務。雖然找到了最適合的服務，但是秉持著刨根問底的精神，小羚還是很好奇我在雲端上存的檔案是怎麼儲存和備份的呢？那讓我們接著繼續看下去。</p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p>PaaS（Platform as a Service），通常SaaS下面這一層就是PaaS，它的目的是給最外層的服務提供一個平台，讓網路應用可以部署在上面，例如Amazon S3等等。使用者一般為工程師，工程師把寫好的服務部署在上面，他不需要管分散式架構、備份等問題，其中，最有名的當數Amazon S3了，這裡容我簡單介紹一下。</p><p><strong>Amazon S3</strong></p><p>Amazon S3（Simple Storage Service）是亞馬遜公司提供的一個Object Storage儲存服務，可以透過Restful API、SOAP等方式，把你的檔案儲存在網路伺服器上。目前每個月收費3元台幣/GB，與iCloud比似乎還是有點貴，iCloud月付30元就有50GB了。</p><p>Amazon S3有個關鍵的概念，叫做「Bucket」，Bucket有點像是你的名稱唯一個人資料夾，裡面只能存放檔案，不能再新建資料夾，存取檔案只能透過你的資料夾裡面的檔案名字去讀取或是更新。我們通常說的Object儲存系統，就是把檔案存在一個沒有資料夾的大平面。</p><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p>IaaS（Infrastructure as a Service），PaaS下面那一層就是IaaS。我們知道，一台電腦或伺服器，它是由「計算/CPU」和「儲存/Disk」構成，缺一不可。IaaS的目的是讓工程師可以直接使用這些硬體設備，透過虛擬化的方式，切割成獨立的計算資源，透過iSCSI等方式，切割獨立的儲存資源，例如vSphere、vSAN等等，而這也是資料中心提供的Service方式。下一篇，我們將會介紹vSAN的核心思想以及要解決的問題——軟體定義資料中心。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li><strong>雲端儲存</strong> 提供靈活、安全的備份方案。</li><li><strong>SaaS</strong> 讓一般使用者能輕鬆使用雲端服務，例如Google Doc。</li><li><strong>PaaS</strong> 提供平台讓工程師部署應用程式，例如Amazon EKS。</li><li><strong>IaaS</strong> 提供基礎設施資源，讓工程師直接使用硬體設備，例如Amazon EC2。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vSAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> vsan </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]刻意練習</title>
      <link href="/2022/02/03/proative_practice_book/"/>
      <url>/2022/02/03/proative_practice_book/</url>
      
        <content type="html"><![CDATA[<h3 id="刻意練習"><a href="#刻意練習" class="headerlink" title="刻意練習"></a>刻意練習</h3><p><img src="/images/proactive_practice.jpeg"><br>我們或許有聽過一萬小時定律: 任何人做一件事，只要經過一萬小時的錘煉，都能從普通人變為某一領域的頂級人才 - 格拉德威爾《異類》<br>1萬小時的錘煉是任何人從平凡變成超凡的必要條件，雖然是必要條件，但是也不是唯一條件，更不一定需要一萬小時，而是足夠多的練習<br>讀了這本書《刻意練習》，除了練習之外，我們更應該考慮外部環境跟內部誘因，並且兩者是相輔相成的，讓我更了解怎麼有效率的「學習」，下面是我讀完後的總結，我會從外部和內部視角提出實操性強的步驟:</p><h3 id="開頭"><a href="#開頭" class="headerlink" title="開頭"></a>開頭</h3><ul><li><strong>要成為一個領域的佼佼者，靠的不是天賦，而是刻意並且足夠多的練習</strong><br>  沒有一個人是靠天賦成為頂尖人才的，即便是莫札特也是如此，頂尖人才之所以能持續練主要習並不是因為興趣，而是持續練習</li><li><strong>建立目標</strong> - 你能「做」到什麼，而不是你能「學」到什麼</li><li><strong>刻意練習就是</strong> - 做跳脫舒適圈的事、獲得反饋、改進並回到第一步</li></ul><span id="more"></span><h3 id="建立良好的外部環境"><a href="#建立良好的外部環境" class="headerlink" title="建立良好的外部環境"></a>建立良好的外部環境</h3><ol><li><strong>想要練習的目標最好是高度發展的領域</strong><br> 高度發展的領域除了已經有成熟的訓練方法之外，能建立內部誘因，向強者看齊</li><li><strong>訂立明確的目標</strong></li><li><strong>找個好老師</strong><br> 好的老師能給你正確的訓練方法和回饋，如果因為現實問題沒有老師，可以自己找模仿對象加以模仿，以培養「心智表徵」<ul><li>心智表徵<br>  心智表徵就是做事時心裡能有一個大致上思考的方向，在未知情況下能夠做出下一步的判斷力，我們能夠透過「老師」或「模仿對象」學習對方的心智表徵</li></ul></li><li><strong>製造回饋機制</strong><br> 最好能有個量化的回饋機制，回饋機制能防止自己在學習的道路上偏離，回到正確的方向</li></ol><h3 id="建立內部誘因"><a href="#建立內部誘因" class="headerlink" title="建立內部誘因"></a>建立內部誘因</h3><ol><li><strong>產生興趣</strong><br> 產生興趣受外部環境影響較深，例如親近的人的讚美和鼓勵，在這個階段，練習感覺像是遊戲</li><li><strong>將練習融入工作中</strong><br> 現代人時間都不太夠，若是能在工作中同時對專業進行練習將節省很多時間</li><li><strong>變得認真</strong><br> 到了這個階段，練習不再等於遊戲，而是功課，要靠自我意志力和動機堅持下去，還有一部分的外部讚美和鼓勵，這時應該有了基本的「心智表徵」</li><li><strong>全心投入</strong><br> 在這個階段，動機完全來自於自己本身，外部頂多只能進行支持，這一步是最枯燥無聊的，也是最難的，這裡我列出了幾個方法讓自己能夠保持全心投入<ul><li>找出可能受干擾的因素，並盡量減低影響</li><li>不要假設某些事情是「天生的」</li><li>製造出幾個「小成功」，持續讓自己有正反饋</li><li>社會動機 - 得到他人的認可和欽佩</li><li>製造好的外部環境 - 讓自己身邊圍繞著你努力時會給予你鼓勵、支持和挑戰的人</li><li>相信自己能成功</li></ul></li></ol><p><strong>上述步驟必須「有意識」的行動且全神貫注</strong></p><h3 id="運用刻意練習的教學方法"><a href="#運用刻意練習的教學方法" class="headerlink" title="運用刻意練習的教學方法"></a>運用刻意練習的教學方法</h3><ol><li><strong>定目標 - 決定學生具備哪些能力，遠比決定應該具備哪些知識有效</strong><br> 學生在培養能力的同時，自然會獲得知識</li><li><strong>清單化一系列具體的學習目標</strong><br> 將課程分解為一系列小的好做的步驟</li><li><strong>鼓勵學生踏出舒適圈</strong></li><li><strong>即時點出學生的錯誤，給予回饋，並指導如何改正</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 刻意練習 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]人性的弱點</title>
      <link href="/2021/11/30/influence_people_book/"/>
      <url>/2021/11/30/influence_people_book/</url>
      
        <content type="html"><![CDATA[<h3 id="人性的弱點"><a href="#人性的弱點" class="headerlink" title="人性的弱點"></a>人性的弱點</h3><p><img src="/images/influence_people.jpeg"><br>人性的弱點，這本書的英文原名是”How to Win Friends and Influence People”，如何贏得朋友並影響他人，和”人性的優點”同個作者 - 戴爾・卡內基，人性的優點書評我寫在<a href="/2021/11/11/stop_worrying_book">這裡</a>。</p><span id="more"></span><p>全書通過栩栩如生的故事和通俗易懂的原則，從人性本質的角度，挖掘出潛藏在人心裡影響他人的方法和原則，只有認識自己並理解他改進自己的弱點才會有所進步，本書的一大優點是他的架構非常的有邏輯及有條理，做筆記也非常的方便，我把各個章節也用一行行條理的方式羅列出來，方便內化進去自己的原則</p><ol><li>不要批評他人，不要抱怨、責怪他人<ul><li>對他人的批評，都是關係惡化的導火線</li><li>如果我是他，我也會做同樣的事，他會做這樣的事，一定有他的理由</li></ul></li><li>與人相處的秘訣<ul><li>讓人心甘情願的做某件事情的唯一方法 - 給他需要的東西</li><li>我們做任何事情只有兩個動機 - 性衝動(來自佛洛依德)和渴望成為偉人(獲得別人的重視)</li></ul></li><li>如何左右逢源<ul><li>魚餌的選擇，是釣魚成功的最大關鍵</li><li>談論對方需要的，並且提出建議，是世界上唯一能影響他人的方法(站在對方立場想)</li></ul></li></ol><h4 id="使人喜歡的六個方法"><a href="#使人喜歡的六個方法" class="headerlink" title="使人喜歡的六個方法"></a>使人喜歡的六個方法</h4><ol><li>如果這樣做，將到處受到歡迎<ul><li>時刻關心周圍的人，發自內心的關心他們</li><li>發自內心的對他人及他從事的事情感興趣</li><li>一個人在生活中不懂的關心他人，對他人不感興趣的人，他的生活必將受到嚴重阻礙和困難</li></ul></li><li>如何給別人留下好印象<ul><li>保持微笑，大部分人的意念決定了他們是否快樂</li></ul></li><li>想要避免發生麻煩，就請這樣做<ul><li>記住他人的名字，所有人對自己的名字，比對任何人有興趣</li><li>example，鋼鐵大王-安德魯卡內基推銷投資者投資建廠，承諾如果投資，就把投資者的名字作為工廠名字</li></ul></li><li>如何養成贏的他人好感的優美談吐習慣<ul><li>善於並專心傾聽對方、在別人說話的時候鼓勵他們</li></ul></li><li>怎麼讓他人對你的話題感興趣<ul><li>接見前，預備好他們感興趣的話題，和對方講他們感興趣的事</li></ul></li><li>如何使人很快地喜歡你<ul><li>讚美一個小細節<ul><li>真希望我也能夠擁有你這樣漂亮的頭髮</li><li>你回答問題的方式很漂亮，清晰又準確</li></ul></li><li>要讓他人覺得他自己很重要，並且還要很真誠</li></ul></li></ol><h4 id="在生活中贏得他人同意的十二條規則"><a href="#在生活中贏得他人同意的十二條規則" class="headerlink" title="在生活中贏得他人同意的十二條規則"></a>在生活中贏得他人同意的十二條規則</h4><ol><li>你不可能在爭辯中獲勝<ul><li>永遠避免與他人發生正面衝突，發生爭執的時候，唯一獲得最大的利益方式，就是避免與他人爭執</li><li>要讓自己的客戶、朋友、妻子，在細小的問題的爭論上經常勝過我們</li></ul></li><li>怎麼減少樹敵<ul><li>不要直接指出對方的錯誤，我們樂意將我們認爲“正確”的事進行到底</li><li>尊重他人的意見，永遠也不要指責對方“你錯了”</li></ul></li><li>犯了錯誤就要承認<ul><li>如果犯了錯，就要迅速且認真地承認錯誤</li></ul></li><li>從友善待人開始<ul><li>以友好善良的方式與人交往</li></ul></li><li>蘇格拉底讓人說”是”的秘密<ul><li>讓談話中減少對方說不的機會，多說是</li></ul></li><li>盡量多給對方說話的機會</li><li>如何讓別人與你合作<ul><li>自己提出建議，讓別人得出結論</li></ul></li><li>怎麼創造奇蹟的公式<ul><li>當對方不承認自己的錯誤時，嘗試著了解，原諒對方</li><li>不要用命令的語氣</li><li>在處理問題時，真誠地以他人的立場看待問題</li></ul></li><li>了解每一個人所需要的<ul><li>停止爭論的神奇句子 - 我不會責怪你所做的一切，如果換作是我，我也會做出同樣的決定</li><li>同情對方的意念和慾望</li></ul></li><li>激起對方高尚的動機<ul><li>想改變一個人，就需要把他高尚的動機激發出來</li></ul></li><li>把你的想法戲劇化<ul><li>類似二次吸引？讓對方看到你的大改變</li></ul></li><li>當你無計可施時，不妨試試這個<ul><li>假如我們要完成一件事情，要鼓勵競爭</li><li>好勝的意志與勇於挑戰的心理，是效果最好的激勵</li><li>所以要提出一項好的挑戰</li></ul></li></ol><h4 id="讓人同意你的九種方法"><a href="#讓人同意你的九種方法" class="headerlink" title="讓人同意你的九種方法"></a>讓人同意你的九種方法</h4><ol><li>假如你必須批評，這就是開始的方法<ul><li>先褒後貶</li><li>發自內心的讚賞他人的成就作為開始</li></ul></li><li>怎麼批評才不招致抱怨<ul><li>避免正面批評，這樣毀損傷對方的自尊心</li></ul></li><li>先說出你的錯誤<ul><li>先談論自己的錯誤，再談論別人的錯誤</li></ul></li><li>沒有人喜歡被指使<ul><li>不要做出直接或祈使句的命令</li></ul></li><li>顧全對方的面子<ul><li>表示對別人的做法和想法感到諒解</li><li>每個領導者都要懂的顧全別人的面子</li></ul></li><li>如何鼓勵別人成功<ul><li>哪怕極小的進步都要給予真誠的讚美</li></ul></li><li>給他人一個美好的名聲<ul><li>想讓一個人的缺點有所改善，就要讓他知道，他已經具備一些優點了</li></ul></li><li>讓錯誤看起來容易改正<ul><li>鼓勵可以讓你更容易改正錯誤，也讓別人更容易達到你的期望</li></ul></li><li>讓人們樂意去做你所要做的事<ul><li>賦予特殊榮譽，例如在台灣，很多小公司的工程師都掛名資深工程師</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 人性的弱點 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]人性的優點</title>
      <link href="/2021/11/11/stop_worrying_book/"/>
      <url>/2021/11/11/stop_worrying_book/</url>
      
        <content type="html"><![CDATA[<h3 id="人性的優點"><a href="#人性的優點" class="headerlink" title="人性的優點"></a>人性的優點</h3><p><img src="/images/notworry.jpg"><br>人性的優點，這本書的英文原名是”How to stop worrying &amp; start living”，老實說，我也不知道為何中文會翻譯成”人性的優點”，不過總之，他是一本在講如何消除憂慮的書，和”人性的弱點”同個作者 - 戴爾・卡內基。</p><span id="more"></span><p>生活的快樂與否，完全是由思想造成的。憂慮會使人一文不值，挫折是整個事情的一部分 - 是你要爬到最高峰所必須經過的有益的訓練，不要讓憂慮阻礙你的步伐，要善於利用思想的力量，發現人生的美好，通過改變心情自救，事情會在你快樂中變得簡單。對於消除憂慮，本書有五大步驟，從憂慮的本質，然後進而剖析他，消除他，最後是維持快樂與幸福的一些準則。<br>當然，我也是個平凡人，一定會有經常面對憂慮的時候，本書的一大優點是他的架構非常的有邏輯及有條理，做筆記也非常的方便，我把各個章節也用一行行條理的方式羅列出來，方便內化進去自己的原則</p><h4 id="憂慮的真相"><a href="#憂慮的真相" class="headerlink" title="憂慮的真相"></a>憂慮的真相</h4><ol><li>讓自己生活在獨立的隔艙裡<ol><li>愚蠢的人才會為昨天流淚，為明天擔憂</li><li>把全部的心智投入在今天的工作中去</li></ol></li><li>消除憂慮的萬能公式<ol><li>想到最壞的可能性 - 除死無大事</li><li>然後去接受最壞的可能性</li></ol></li><li>過多的憂慮會危及生命<ol><li>要對自己充滿信心</li><li>欣賞美妙的音樂</li><li>樂觀態度看待生活</li></ol></li></ol><h4 id="剖析憂慮的方法"><a href="#剖析憂慮的方法" class="headerlink" title="剖析憂慮的方法"></a>剖析憂慮的方法</h4><ol><li>怎麼分析憂慮並從中把他解脫出來<ol><li>查清憂慮真相-困惑是導致憂慮的主要原因，列出正反兩方因素，能夠找出事實的真相</li><li>列出該怎麼做的Plan A B C D…選一個可以接受的，然後不要猶豫地實施決定</li></ol></li><li>怎麼消除工作中的煩惱<ol><li>回答四個問題<ol><li>問題出在哪裡</li><li>為什麼會有這樣的問題出現</li><li>該怎麼解決這個問題</li><li>能否提出解決問題的建議</li></ol></li></ol></li></ol><h4 id="如何消除憂慮"><a href="#如何消除憂慮" class="headerlink" title="如何消除憂慮"></a>如何消除憂慮</h4><ol><li>把你的憂慮從心中驅逐出去<ol><li>做事，讓自己忙得沒空憂慮</li></ol></li><li>不因瑣事而煩惱<ol><li>把看法和重點轉移一下，不要當完美主義者</li></ol></li><li>戰勝憂慮的幾個法則<ol><li>不要過度擔心，算好機率，發現他們都是小機率事件</li></ol></li><li>勇敢面對事實<ol><li>不愉快的事情發生了，他們已經如此了</li><li>心甘情願地接受事實，是戰勝之後困難的第一步</li><li>勇於面對那些不可避免的事實</li></ol></li><li>讓憂慮到此為止<ol><li>設定一個底線，和股票投資一樣</li><li>問自己兩個問題<ol><li>我遇到的問題和我有多大的關係？我需要這麼擔憂嗎？</li><li>我如何設定底線？然後把他忘掉</li></ol></li></ol></li><li>不要試著去鋸已經碎掉的木屑<ol><li>我們可以努力改變180秒前發生事情帶來的後果，但我們沒有辦法改變當時的狀況</li></ol></li></ol><h4 id="讓自己平安快樂的七種方式"><a href="#讓自己平安快樂的七種方式" class="headerlink" title="讓自己平安快樂的七種方式"></a>讓自己平安快樂的七種方式</h4><ol><li>憧憬生活的美好<ol><li>改變對事物的看法，往好的方面想</li><li>只要下定決心就能快樂</li></ol></li><li>不要報復你的敵人<ol><li>報復會損害健康，憤怒不能控制好，會導致高血壓和心臟病</li></ol></li><li>給予，但不求回報</li><li>細數幸福的事</li><li>保持自我本色<ol><li>一個人打算擁有別人的全部優點，那簡直是荒謬</li></ol></li><li>把不利因素轉為有利因素</li><li>忘掉自己，關心他人<ol><li>最無私的人最會享受生活</li><li>多做善事</li><li>多對別人感興趣，多向他人表示關心</li></ol></li></ol><h4 id="如何直面批評帶來的煩惱"><a href="#如何直面批評帶來的煩惱" class="headerlink" title="如何直面批評帶來的煩惱"></a>如何直面批評帶來的煩惱</h4><ol><li>批評他人是一種自我膨脹的表現<ol><li>對你刻薄的斥責往往能從另一面表現出人們對你的重視</li></ol></li><li>不要讓批評之箭射中你<ol><li>普通人根本不會想到我們</li><li>只不理會不公正的批評</li></ol></li><li>自省，再自省<ol><li>在工作和生活中的缺點積極說”不”</li></ol></li><li>怎麼消除疲勞<ol><li>休息是消除疲勞的首要途徑</li><li>休息放空真的很重要！！！</li></ol></li><li>是什麼讓你疲勞<ol><li>腦力工作者不會因為用腦而疲倦</li><li>用腦的疲倦是因為精神和情緒因素引起的</li></ol></li><li>讓疲憊永遠消失<ol><li>找知心朋友傾訴，是治療煩惱最有效的方法</li><li>讀一些愉悅的文字</li><li>不要過分計較別人的過失</li></ol></li><li>四個良好的工作習慣<ol><li>生活環境井然有序</li><li>處理事情要有重點</li><li>當機立斷，趕快行動</li><li>學會領導、權力下放和監督</li></ol></li><li>怎麼消除煩悶心裡<ol><li>心理上的厭煩比工作中的勞累更容易感到疲倦</li><li>要對工作有熱情</li></ol></li><li>不再為失眠而憂慮<ol><li>安全感是安穩睡覺的第一關鍵</li><li>讓自己身體疲憊</li><li>失眠的時候可以起來做點事</li><li>失眠不會導致死亡，導致死亡的是緊張情緒和精神壓力</li><li>經常鍛鍊身體，使心情放鬆</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 人性的優點 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]解析第二層及第三層的網路封包結構</title>
      <link href="/2021/10/29/eth_and_ip_network/"/>
      <url>/2021/10/29/eth_and_ip_network/</url>
      
        <content type="html"><![CDATA[<p><strong>網路的IP位址讓我們路由到LAN(區域網路)，而MAC位址讓我們找到了目標電腦</strong><br>MAC作用在第二層 - 資料連結層，而IP作用在第三層 - 網路層，關於MAC和IP位址的詳細解說請參考<a href="/2021/09/23/ipbasic-network">這一篇</a></p><p>那麼，讓我們從第二層 - 資料連結層 開始吧！</p><span id="more"></span><h3 id="資料連結層"><a href="#資料連結層" class="headerlink" title="資料連結層"></a>資料連結層</h3><p>資料連結層透過MAC位址進行溝通，所以它的Header包含了固定長度的來源MAC位址和目的地MAC位址，結構如下所示：<br><img src="/images/eth_header.png"><br>我們可以看到資料連結層的header總共有三項資料，除了MAC位址之外還有<code>type</code>，它是一個2 bytes的unsigned short int，具體對應的type可以參考<a href="https://en.wikipedia.org/wiki/EtherType#Values">維基百科</a>，比較常見的有：</p><ul><li>0x0800 - IPv4</li><li>0x86DD - IPv6</li><li>0x0806 - ARP</li></ul><p>我們一直都沒說到IP位址和MAC位址怎麼做mapping對應，用的就是ARP協議，它通知路由器IP和MAC位址的對應關係。</p><p>整個header有14個bytes，而這14個bytes後面接的就是網路層的header。</p><h3 id="網路層"><a href="#網路層" class="headerlink" title="網路層"></a>網路層</h3><p>網路層提供了路由和尋址的功能，幫助封包導向兩端的最佳路徑，並具有一定的擁塞控制和流量控制的功能。和資料連結層一樣，我們來看看網路層header結構：<br><img src="/images/ip_header.png"><br>這裡列出比較重要的欄位：</p><ul><li><p>Total Length：封包總長度</p></li><li><p>Identification：識別碼，通常是為了校驗checksum</p></li><li><p>Fragmentation: 如果要傳輸大封包，能進行切割標記</p></li><li><p>Time To Live(TTL)：經過幾個路由器，如果為0則傳輸失敗</p></li><li><p>Protocol：協定，例如tcp協定、icmp協定等，這和應用層的http、DNS等不同，應用層協定屬於這層協定的一部分。Protocol以數字表示，這裡列舉比較常見的：</p><ul><li>1 -&gt; ICMP</li><li>6 -&gt; TCP</li><li>17 -&gt; UDP</li></ul><p>  由於不同的Protocol後續的header長度內容也會不同，故需要加以區分</p></li><li><p>Checksum：用來檢錯用的</p></li><li><p>Source IP Address：來源IP位址</p></li><li><p>Destination IP Address：目的地IP位址</p></li></ul><p>其header長度總共有20個bytes。</p><hr><h3 id="總結："><a href="#總結：" class="headerlink" title="總結："></a>總結：</h3><p>我們透過MAC位址在資料連結層找到目標電腦，並使用IP位址在網路層進行路由。MAC和IP位址各自在不同層次發揮重要作用，共同協助封包在網路中的傳輸。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]Socket - 網路程式的大門</title>
      <link href="/2021/10/25/socket_usage_network/"/>
      <url>/2021/10/25/socket_usage_network/</url>
      
        <content type="html"><![CDATA[<p>我們在寫網路相關的程式時，最底層就是與 socket 交互。socket 是專用於網路通訊的 system call。什麼是 system call 呢？我們知道作業系統有分 kernel 和 user space，從 user space 要進行 I/O 操作需要透過 system call 去呼叫 kernel space，因為只有 kernel space 才有權限進行 I/O 的操作。</p><p>在 Linux 中，使用 socket 宣告一個 object 會回傳一個 file descriptor。在 Linux 中，一切都是文件，連 socket object 也不例外，file descriptor 在這裡的作用就是指向那個文件的 descriptor。</p><span id="more"></span><p>下面簡單介紹本專案會用到的 socket 基本 API 的使用，首先開啟 socket 就是宣告了一個 socket 的 object：</p><p><code>sock = Socket(family, type, proto)</code></p><ul><li><p><strong>family</strong><br>family 指的是某個通訊協定，例如 IPv4、IPv6 等等。如果指定 IPv4 則只對 IPv4 的通訊協定的封包進行處理，例如 AF_PACKET，它能直接從網卡讀取和寫入數據。</p></li><li><p><strong>type</strong><br>type 則是封包數據的格式，主要有 SOCK_STREAM 和 SOCK_DGRAM，分別代表 TCP 和 UDP。還有更原始的格式 SOCK_RAW，能自行組裝數據包。由於我們想監聽所有封包，所以會使用 SOCK_RAW。</p></li><li><p><strong>proto</strong><br>proto 則是 protocol 的意思，通常預設為 0。我們的應用要監聽所有封包，所以設定為 0x0003 來監聽所有 Ethernet 上的封包。</p></li></ul><p>定義好 socket file descriptor 後，下面是 socket object 常用的 API。</p><ul><li><p><strong>bind((addr, port))</strong><br>需監聽和發送的地址和 port，地址若為 0.0.0.0 則代表所有，也能監聽所有網卡。</p></li><li><p><strong>recv(1024)</strong><br>如果有封包進來，kernel space 會響應這個函數，讓我們的應用程式可以對封包進行處理。若沒有封包，則會被 block 在這裡。函數回傳的是小於等於 1024 長度的 string，看封包大小而定。</p></li><li><p><strong>send(packet)</strong><br>packet 就是我們做成的封包，在後續的課程會教大家怎麼製作自己的封包，怎麼計算 checksum。socket 會根據封包裡的 MAC address 和 IP address 進行路由。</p></li></ul><p>除了上述這些 API，還有很多其他功能，有興趣的讀者可以深入研究。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>最後，我們試著用 socket API 來獲取封包的來源 MAC 地址。首先，我們需要監聽所有封包，所以 <code>family</code>、<code>type</code> 和 <code>proto</code> 分別為 <code>AF_PACKET</code>、<code>SOCK_RAW</code> 和 <code>0x0003</code>，完整如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(<span class="number">0x0003</span>))</span><br></pre></td></tr></table></figure><p>接下來，我們需要綁定一個 network interface，可以透過指令 <code>ifconfig</code> 來查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02</span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3496 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1692 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:4623164 (4.6 MB)  TX bytes:93240 (93.2 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:36 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:36 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1800 (1.8 KB)  TX bytes:1800 (1.8 KB)</span><br></pre></td></tr></table></figure><p>在我的環境裡，有 <code>eth0</code> 這個 network interface，所以我決定監聽它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.bind((<span class="string">&quot;eth0&quot;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>監聽的方式如下，需要一個無限循環去監測，如果沒有新封包則會被 block 在 <code>sock.recvfrom</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    packet, _ = sock.recvfrom(<span class="number">65565</span>)</span><br></pre></td></tr></table></figure><p>一個封包的來源 MAC 地址會在封包的前六個 bytes，我們需要用到 Python 自帶的 struct library 來解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_mac_header = packet[:<span class="number">6</span>]</span><br><span class="line">struct.unpack(<span class="string">&#x27;!6s&#x27;</span>, src_mac_header)</span><br></pre></td></tr></table></figure><p>驚嘆號代表的是 bytes 順序是 big endian，6s 代表解包 6 個 char，也能解包 integer 等等，具體代表的意思可以參考<a href="https://docs.python.org/3/library/struct.html#format-characters">這裡</a>。所以解包之後，我們就能取得來源的 MAC 地址，完整的程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, struct</span><br><span class="line"></span><br><span class="line"><span class="comment">#define ETH_P_ALL    0x0003          /* Every packet (be careful!!!) */</span></span><br><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(<span class="number">0x0003</span>))</span><br><span class="line">sock.bind((<span class="string">&quot;eth0&quot;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    packet, _ = sock.recvfrom(<span class="number">65565</span>)</span><br><span class="line">    src_mac_header = packet[:<span class="number">6</span>]</span><br><span class="line">    src_mac = struct.unpack(<span class="string">&#x27;!6s&#x27;</span>, src_mac_header)[<span class="number">0</span>]</span><br><span class="line">    mac = <span class="built_in">map</span>(<span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>, src_mac)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>.join(mac))</span><br></pre></td></tr></table></figure><p>實驗方式：可以跑這個程式的電腦發送 curl 請求，可以看到在我的環境裡，eth0 的 MAC address 為 <code>02:42:ac:11:00:02</code>，然後我們下指令對自己的電腦產生封包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&gt; curl --interface eth0 127.0.0.1</span><br></pre></td></tr></table></figure><p>在另外一個 terminal 視窗，就可以看到自己的 MAC address 被 print 出來了！</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>Socket 是網路通訊的基礎工具，常用 API 包括 bind、recv 和 send</li><li>範例程式展示如何監聽封包並取得來源 MAC 地址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的記憶體垃圾回收機制</title>
      <link href="/2021/10/20/garbage-collection-python/"/>
      <url>/2021/10/20/garbage-collection-python/</url>
      
        <content type="html"><![CDATA[<p>我們知道，Python 應用在執行時，需要從記憶體中劃出一段空間來存放臨時變數，計算完後再將結果存放到永久儲存介質。如果臨時變數所需的空間過大，會導致 OOM (Out of Memory) 記憶體錯誤，程式可能會被作業系統終止。</p><p>對於伺服器應用來說，為了設計永遠不中斷的系統，記憶體管理變得非常重要，否則容易引發記憶體洩漏 (Memory Leak)。</p><h3 id="什麼是記憶體洩漏？"><a href="#什麼是記憶體洩漏？" class="headerlink" title="什麼是記憶體洩漏？"></a>什麼是記憶體洩漏？</h3><p>我們的應用程式在執行過程中會不斷向作業系統申請記憶體並釋放記憶體。記憶體洩漏指的是程式沒有釋放已不再使用的記憶體，導致記憶體的浪費，而非被攻擊。</p><h3 id="Python-的記憶體管理"><a href="#Python-的記憶體管理" class="headerlink" title="Python 的記憶體管理"></a>Python 的記憶體管理</h3><p>那麼 Python 是怎麼處理的呢？需要工程師們手動申請變數記憶體並清除嗎？答案是：不需要，Python 會自動找出不再使用的變數並釋放記憶體。</p><span id="more"></span><h3 id="Reference-Count（引用計數）"><a href="#Reference-Count（引用計數）" class="headerlink" title="Reference Count（引用計數）"></a>Reference Count（引用計數）</h3><p>在 Python 中，一切皆為物件，每個物件都有多個pointer指向它。那麼如何知道這個物件不會再被使用呢？Python 使用引用計數（Reference Count），當引用計數為 0 時，代表這個物件不可達，不會再被使用了，這時需要被回收。</p><h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_memory_info</span>(<span class="params">hint</span>):</span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.30859375 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.09765625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 11.61328125 MB</span></span><br></pre></td></tr></table></figure><p><code>show_memory_info</code> 使用了 <code>psutil</code> library 來取得 process 所消耗的記憶體。程式剛開始執行時，佔用了約 7MB 的記憶體；當我們宣告了一個長度為一千萬的 list 之後，記憶體飆升至 404MB。然而在 main 函數結束後，變數 a 不再使用，所以引用計數變為 0，記憶體被回收，最後記憶體消耗降至 11MB。</p><h4 id="另一個範例：全域變數"><a href="#另一個範例：全域變數" class="headerlink" title="另一個範例：全域變數"></a>另一個範例：全域變數</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a= []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.0859375 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 404.0859375 MB</span></span><br></pre></td></tr></table></figure><p>即使程式運行結束，記憶體使用量仍然很高。這顯示 Python 的記憶體垃圾回收機制並非萬無一失，在程式設計上仍需謹慎。</p><h3 id="循環引用"><a href="#循環引用" class="headerlink" title="循環引用"></a>循環引用</h3><p>還有一種情況是變數不再使用，但其引用計數並不為 0。這種情況就是循環引用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.2890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.67578125 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 790.67578125 MB</span></span><br></pre></td></tr></table></figure><p>在此範例中，變數 a 和 b 互相引用，導致程式運行結束後記憶體未被回收。這只是簡單明顯的狀況，很多循環引用是很難被發現的。那麼我們應該怎麼做呢？我們可以手動調用垃圾回收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.37890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.03515625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 12.12890625 MB</span></span><br></pre></td></tr></table></figure><h3 id="Python-垃圾回收機制"><a href="#Python-垃圾回收機制" class="headerlink" title="Python 垃圾回收機制"></a>Python 垃圾回收機制</h3><p>針對循環引用，Python 使用標記清除 (mark-sweep) 和分代收集 (generational) 兩種演算法。以下簡單介紹一下：</p><h4 id="標記清除演算法"><a href="#標記清除演算法" class="headerlink" title="標記清除演算法"></a>標記清除演算法</h4><p>我們可以用圖論來表達不可達概念。對於一個有向圖，從任意節點出發遍歷，若遍歷結束後有節點未被標記，則視為不可達，需要回收。然而每次遍歷全圖是巨大浪費，所以 Python 維護了一個雙向 linked-list，並且只維護 Container 類變數。</p><h4 id="分代收集演算法"><a href="#分代收集演算法" class="headerlink" title="分代收集演算法"></a>分代收集演算法</h4><p>Python 將所有變數分為三代。剛創立的變數為第一代，垃圾回收後仍存在的變數會移到下一代。當某代變數超過某個閥值時，執行垃圾回收。</p><h3 id="記憶體洩漏-debug"><a href="#記憶體洩漏-debug" class="headerlink" title="記憶體洩漏 debug"></a>記憶體洩漏 debug</h3><p>即使 Python 有強大的記憶體管理機制，難免仍有漏網之魚。Python 有個 library <code>objgraph</code>，可用於 debug：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"></span><br><span class="line">objgraph.show_refs([a])</span><br><span class="line">objgraph.show_backrefs([a])</span><br></pre></td></tr></table></figure><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>今天我們深入瞭解了 Python 垃圾回收機制，重點如下：</p><ul><li>垃圾回收在 Python 中用於釋放不再使用的記憶體給作業系統</li><li>Reference count 是常見方式，但不是唯一條件</li><li>Python 垃圾回收包含標記清除和分代收集演算法，主要針對循環引用</li><li>Debug 記憶體洩漏方面，<code>objgraph</code> 是個好工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]金錢超思考</title>
      <link href="/2021/10/15/think_money_book/"/>
      <url>/2021/10/15/think_money_book/</url>
      
        <content type="html"><![CDATA[<h3 id="金錢超思考-5大金錢迷思-x-25道創造財富的關鍵思考"><a href="#金錢超思考-5大金錢迷思-x-25道創造財富的關鍵思考" class="headerlink" title="金錢超思考 - 5大金錢迷思 x 25道創造財富的關鍵思考"></a>金錢超思考 - 5大金錢迷思 x 25道創造財富的關鍵思考</h3><p><img src="/images/think_money.jpg"><br><strong>金錢超思考</strong>這本書不是一本教你投資致富的書，而是<strong>「如何思考金錢？」</strong>，這一個問題的背後，作者娓娓道來背後蘊藏的智慧<br>從出社會開始，邁入職場後都在比誰賺的多，然而我們對於金錢的追求與渴望到底是為了什麼？這又衍伸出更多的問題：我到底該把錢花在哪些地方？如何正確看待金錢？擁有很多金錢的意義是什麼？即使財務自由之後又如何？<br>讀完這本書後，我覺得在我們有限的時間及精力裡，賺更多的錢不是唯一，我們需要懂的如何花錢、賺錢和存錢，三者缺一不可，下面我將用條列式的方式，把書中的精華做一個摘要</p><span id="more"></span><h5 id="如何用錢買到快樂"><a href="#如何用錢買到快樂" class="headerlink" title="如何用錢買到快樂?"></a>如何用錢買到快樂?</h5><p>似乎從小到大，我們的學歷越來越好，賺的錢越來越多，職位越爬越高，但我們仍然沒有感覺更快樂，為什麼會這樣？這是因為我們的「與他人比較」心態，例如我們有錢了，就搬到豪宅區置產，但看到鄰居們更富有，車更豪華，你又開心不起來了。<br>第二個是，我們東西總會越買越好，讓我們陷入無止盡的物質追逐，然而這種快樂是暫時的，作者給出的建議是，<strong>屏除與外界的比較，回歸自己的內心。</strong><br>那麼要如何用錢買到長久的快樂呢？第一個，把錢花在別人身上比花在自己更快樂，當自己有閒錢的時候，幫助弱勢族群所帶來的快樂是無與倫比的</p><ol><li>不要追逐物質，改為追求體驗</li><li>錢可以買到自由</li><li>有錢不一定會快樂，但是沒有錢肯定不快樂</li><li>錢能解決生活中80%的問題，剩下20%可以用錢來緩解</li></ol><h5 id="把退休當成永遠的財務目標"><a href="#把退休當成永遠的財務目標" class="headerlink" title="把退休當成永遠的財務目標"></a>把退休當成永遠的財務目標</h5><p>我們可能在年輕時努力存錢買房買車、關注小孩的教育資源，直到五十歲後才驚覺退休的問題，但時常為時已晚。我們投資的目的並不是要變得大富大貴，而是避免年老得過著窮困潦倒的生活。以退休為首要的財務規劃，可以奉行這三個理財策略:</p><ol><li>長期投資</li><li>減少舉債</li><li>習慣儲蓄</li></ol><h5 id="長期投資，減少債務"><a href="#長期投資，減少債務" class="headerlink" title="長期投資，減少債務"></a>長期投資，減少債務</h5><p>除了長期投資之外，短期要盡可能減少舉債，例如：優先償還學貸、提高繳納房貸的月付額、不要動用信用卡的現金借貸。債務纏身的最大隱憂，就是你會在不知不覺間，離財務自由的目標越來越遠。</p><h5 id="愛上儲蓄"><a href="#愛上儲蓄" class="headerlink" title="愛上儲蓄"></a>愛上儲蓄</h5><p>現在花少一點錢其實算不上犧牲，因為大部分的消費（尤其是物質上的）並不會帶來更多的快樂。反而，為了將來的消費而進行儲蓄，這種對未來產生的期待的「延遲享樂」心態，反而能為心靈帶來更多的富足。只要意識到以下三個儲蓄能帶來的效益:</p><ol><li>降低固定成本，不僅可以存更多錢，手頭上也可以有更多金錢用於自主性消費。</li><li>如果我們習慣了生活成本遠低於收入的日子，等到退休時，不需要太多的積蓄也能過得很舒適。</li><li>如果在二十幾歲時就過著節儉的生活，日後便能享受到生活水準逐步提高所帶來的快樂感受。</li></ol><h5 id="賺錢的同時請思考風險"><a href="#賺錢的同時請思考風險" class="headerlink" title="賺錢的同時請思考風險"></a>賺錢的同時請思考風險</h5><p>對於投資，首重「分散持有」與「股債搭配」，避免金融海嘯或單一市場的巨幅崩跌，對資產帶來的鉅額損失。對於仍是家庭經濟支柱的個人，首重「壽險」、「重大疾病險」，避免人身意外對家庭財務帶來巨大的衝擊。</p><p>最後，這是書中一字不漏總結的12點建議，我覺得能納入人生原則，善加運用我們的金錢:</p><ol><li><p><strong>我們偏愛物品的使用價值，但是把錢花費在體驗上會比較快樂</strong>。不要再想著買新車，不如來一場橫跨歐洲的旅行。</p></li><li><p><strong>我們應該運用金錢與朋友和家人共度特別的時光</strong>。帶小孩參加運動比賽，帶你的另一半去看戲，和朋友吃頓晚餐，預訂好行程去探望你的孫子。</p></li><li><p><strong>當我們有時間可以做自己熱愛的工作時，應該好好為自己規劃生活</strong>。為了達到這個目標，我們應該在二十幾歲時盡可能地存錢，才能買到某種程度的財務自由。等到我們四十或五十多歲，就可以運用財務自由轉換到收入不是那麼優渥、但卻能讓我們感到心滿意足的工作。</p></li><li><p><strong>我們不應該擔心退休後會早死，而是要有心理準備，我們的壽命可能會比預期要長</strong>。面對這樣的風險，多數人應該要延遲領取政府退休金福利，以換取每個月能夠獲得較高的固定收入。你也可考慮購買即期年金，如此一來終身都能擁有固定的收入來源。</p></li><li><p><strong>我們的投資期限不是以月或是年，而是以數十年來計算</strong>。我們應該擺脫市場短期下跌的影響，而是像那些分散投資全球股票，並長抱三十、甚至五十年的投資人一樣，才能累積驚人的報酬。確實，對於債券持有或是現金投資不足的退休人士來說，長期的熊市可能會嚴重衝擊他們的報酬，但是對於善於存錢的年輕人來說，卻是一份寶貴的禮物，因為他們可以趁機逢低買進。</p></li><li><p><strong>我們應該盡可能降低每月的固定成本，例如房貸或租金、水電費、雜費、保費等</strong>。降低固定成本才能擁有更大的財務空間，降低財務壓力，可以因此有更多的錢自由地投入「有趣」的消費，同時更積極地存錢。</p></li><li><p><strong>良好的儲蓄習慣並非是自然而然形成，我們必須盡可能讓存錢的過程少一些痛苦</strong>。我們可以固定提撥一定比例的薪資，投入雇主的退休計畫。或是設下定期定額投資計畫，也就是每個月從銀行帳戶中扣除一筆資金，直接投資我們選定的基金。此外，你可以選擇較容易執行的財務策略，例如每個月的房貸還款金額增加兩、三千元，有任何意外之財都應該好好存起來，例如退稅或是兼差的收入。</p></li><li><p><strong>愈是努力想要打敗股市大盤，就愈可能失敗，因為會產生投資成本</strong>。為了避免這樣的結果，我們不應該再認為自己比其他投資人聰明，而是要抱持謹慎的態度，作法是購買分散投資全球的低成本指數型基金。</p></li><li><p><strong>永遠不要忘了股票的基本價值</strong>。如果你的股票投資組合足夠分散，整體基本價值的變動會比市場價格要緩慢。我們應該抱持務實的心態，把重點放在我們投資的金錢能創造多少的股息和盈餘；有效掌握市場可能的長期報酬率；我們應該像購物者一樣思考，看到市場走跌就像是看到地方上的百貨公司推出促銷活動時一樣的興奮。</p></li><li><p><strong>長期而言，退休可能是我們這一生最後一個財務目標，但是我們必須把它放在第一位</strong>。退休是成本最高昂的目標，需要花費數十年的時間儲蓄和累積投資所得，才能存夠需要的金錢。退休的目標也和其他目標很不一樣，不像是買房或是支付小孩教育費用。有什麼不一樣？對多數人來說，退休並非是選擇性的，退休後我們便沒有薪水，因此沒有固定的收入可花用。</p></li><li><p><strong>我們應該採取宏觀的視角，依據我們能夠創造的收入來整合規劃我們的財務</strong>。我們賺取的固定收入就好比是債券，能創造長達四十年的穩定收入來源。擁有了這筆穩定收入，我們可以讓投資組合分散投資全球股票，累積退休之後需要的積蓄；我們可以在二十幾歲時舉債，然後在退休之前還清債務。我們必須保障自己賺錢的本事，因此應該要購買適合的健康保險以及足額的失能與人壽保險。</p></li><li><p><strong>我們的目標不是變有錢。我們的目標是擁有足夠的金錢，去過我們想要的生活</strong>。我們不應該產生過高的投資成本、過度遠離追蹤全球指數的投資策略，或忽略可預防重大財務風險的保險，唯有如此才有可能達成我們希望的目標。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 金錢超思考 </tag>
            
            <tag> 理財 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的GIL</title>
      <link href="/2021/10/10/gil-python/"/>
      <url>/2021/10/10/gil-python/</url>
      
        <content type="html"><![CDATA[<h3 id="GIL（Global-Interpreter-Lock"><a href="#GIL（Global-Interpreter-Lock" class="headerlink" title="GIL（Global Interpreter Lock)"></a>GIL（Global Interpreter Lock)</h3><p>Python 的 multi thread 讓人不明所以，為什麼我的電腦明明有四個 CPU，用 multi thread 性能卻沒有增長呢？我們先看一個例子</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CountDown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 單一執行緒</span></span><br><span class="line">start = time.time()</span><br><span class="line">CountDown(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;耗時: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 兩個執行緒</span></span><br><span class="line">start = time.time()</span><br><span class="line">t1 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t2 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;耗時: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"><span class="comment"># 輸出</span></span><br><span class="line"><span class="comment"># 耗時: 4.894810676574707</span></span><br><span class="line"><span class="comment"># 耗時: 4.441636085510254</span></span><br></pre></td></tr></table></figure><p><code>CountDown</code> 是個 CPU heavy 的函數，但是奇怪的是，明明用了兩個 Threads，耗時卻差不多，都是 4 秒左右。這是怎麼回事？難道我的電腦只有一顆 CPU 在工作嗎？其實不是。如果換成 C++ 寫，速度提升馬上有感。所以問題不是出在電腦，而是 Python 的 multi thread 沒有真正進行併行運算。</p><p>然而，Python 的 Thread 確實是實實在在的 Thread。在 Linux 系統中，它封裝了 Pthread (POSIX Thread)；在 Windows 系統中，它封裝了 Windows Thread。由於 Python 的 Thread 只是做封裝，所以完全受作業系統管理，包括協調執行時間、資源管理等等。</p><p>Python 用了 multi thread 卻沒有性能提升的原因正是因為 GIL。在整個 Python 的 Process 中，只允許同時跑一個 Thread，其他的會被 Lock。因此，本質上，Python 的 Thread 只是“輪流”執行。</p><h3 id="為什麼有-GIL？"><a href="#為什麼有-GIL？" class="headerlink" title="為什麼有 GIL？"></a>為什麼有 GIL？</h3><p>我們知道 Python 是基於 C 實現的，之所以有 GIL 就和 CPython 有關。CPython 使用 Reference Count 管理記憶體，這用來記錄有多少pointer指向這塊記憶體。當 Reference Count = 0 時，就會釋放記憶體。我們來看個例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>這裡的 3 是因為 a, b 和 sys.getrefcount(a) 的參數都指向同一塊記憶體，所以總共是 3。</p><p>如果兩個 Python 的 Threads 同時引用了 a，同時進行 reference count += 1，就會觸發 race condition，最終 reference count 只會加 1。因此，為了避免這樣的風險，Python 設定了一個 GIL。但是，這並不意味著 Python 是天然不用擔心 race condition 的語言。Python 的一行程式可能代表著多行的 bytecode，例如 Python 的 <code>n += 1</code>，其 bytecode 表示為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD_CONST <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">INPLACE_ADD</span><br></pre></td></tr></table></figure><p>若在 <code>INPLACE_ADD</code> 前，GIL 被釋放了，而其他 Thread 跑了 <code>LOAD_CONST 1 (1)</code>，同樣會造成 race condition。我們來看個例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>所以說，GIL 的目的是<strong>為了方便 CPython 的開發者，不用顧慮變數記憶體的分配，而不是為了 Python 應用的開發者</strong>。我們還是需要使用 lock 等工具，例如下面這個例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="可以繞過-GIL-嗎？"><a href="#可以繞過-GIL-嗎？" class="headerlink" title="可以繞過 GIL 嗎？"></a>可以繞過 GIL 嗎？</h3><ul><li>Python 的 GIL 是 CPython 上的限制，如果要繞過，可以透過 JPython（Java 實現的 Python）等其他實現。</li><li>把 CPU heavy 的程式碼放在別的語言（例如 C++）實現，然後提供 Python 調用的 API。</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>我們探究了 Python GIL 的原理，它的目的是為了避免記憶體回收的 race condition。</li><li>雖然 GIL 使得 CPython 更容易開發，但卻沒有真正的 multi threads。不過，我們可以透過其他語言的實作，把 CPU heavy 的程式碼交給 Python 去呼叫，這樣依然可以充分利用 CPU 性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Asyncio的Event loop</title>
      <link href="/2021/10/08/eventloop-python/"/>
      <url>/2021/10/08/eventloop-python/</url>
      
        <content type="html"><![CDATA[<p>之前我們講過了 Python 的 Coroutine，提到了我們用的是 asyncio library。不同於 Coroutine 那一篇，這一篇我們注重於原理的理解。</p><p>我們知道，multi-threading 能夠使得效率及 CPU 使用率大大提高，那為什麼我們還需要 Asyncio (Coroutine) 呢？</p><ul><li>因為在 multi-threading 下，程式碼容易被作業系統打斷，因此可能會出現 race condition。</li><li>另外，context switch 會造成性能損耗。如果 I/O 過多，不停的 context switch 會損失很多性能。</li></ul><p>於是就有了 Asyncio。</p><span id="more"></span><h3 id="Asyncio-原理"><a href="#Asyncio-原理" class="headerlink" title="Asyncio 原理"></a>Asyncio 原理</h3><p>Asyncio 和 Python 的程式一樣，實際上是 single thread 的，不過可以不停地切換。只要拿到 GIL 就可以進行任務。這裡的任務是一種特殊的 future object，並且被 Event loop 所控制。</p><p>我們可以把任務分成兩個狀態 - 預備狀態和完成狀態。預備狀態指的是任務目前空閒，隨時可以執行；而等待狀態則是任務已經執行，但是被掛著等待某個操作完成，例如 I/O。</p><p>Event loop 有兩個 job list，分別對應兩種狀態，並且選取一個預備狀態的任務執行它，一直到它被交還給 Event loop。當任務被交還給 Event loop 時，Event loop 會根據其是否完成，把任務放進預備或完成狀態的 list：</p><ul><li>如果完成，則放進預備狀態；</li><li>如果未完成，則放進等待狀態。</li></ul><p>然後再遍歷等待狀態 list，看他們是否完成。如果完成再放進預備狀態。如此週而復始，直到所有任務完成。由於 Asyncio 的任務不會被外部因素打斷，所以 Asyncio 裡面的操作不會出現 race condition 的問題。</p><h3 id="例子程式碼"><a href="#例子程式碼" class="headerlink" title="例子程式碼"></a>例子程式碼</h3><p>讓我們複習一下這段程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">sec</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">secs</span>):</span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>在這段程式碼中，<code>async/await</code> 是 asyncio 的一種寫法，代表這個函數或這行程式碼是 non-blocking 的。如果這裡很耗時，那我們就把控制權交還給 Event loop，放進等待狀態 list。另外，<code>asyncio.run()</code> 是 Python 3.7 才有的，在舊版本是這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">sec</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">secs</span>):</span><br><span class="line">    loop.run_until_complete(</span><br><span class="line">          asyncio.wait(</span><br><span class="line">             [asyncio.ensure_future(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">main([<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">loop.close()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><h3 id="Asyncio-有缺點嗎？"><a href="#Asyncio-有缺點嗎？" class="headerlink" title="Asyncio 有缺點嗎？"></a>Asyncio 有缺點嗎？</h3><p>當然有。我們知道 Asyncio 的 event loop 藉由 async/await 去把 job 控制權交還給 Event loop。所以相應的第三方 library 也要做調整才能完美地利用 Coroutine 提升性能。例如，著名的 <code>requests</code> library 就沒有支持 Asyncio，而相同功能的 <code>aiohttp</code> 則有兼容 Asyncio。</p><h3 id="multi-processing、multi-threading-還是-coroutine？"><a href="#multi-processing、multi-threading-還是-coroutine？" class="headerlink" title="multi-processing、multi-threading 還是 coroutine？"></a>multi-processing、multi-threading 還是 coroutine？</h3><p>總結來說：</p><ul><li>如果是 CPU heavy 的任務，使用 multi-processing。</li><li>如果 I/O 慢或太多，使用 Coroutine。</li><li>反之，如果 I/O 快，使用 multi-threading。</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這篇文章帶大家過了 Asyncio Event loop 的原理：</p><ul><li>Asyncio 是 single thread 的，但是透過 Event loop，併發地執行不同任務，在程式端享有自主控制權。</li><li>由於打斷是自己控制的，不會出現 race condition 的問題。在 I/O heavy 的情況下，比 multi-threading 的效率更好，因為不用 context switch，且能開啟的任務數量更多。</li><li>不過 Asyncio 的缺點是，需要第三方 library 的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> eventloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的並行計算 - Futures</title>
      <link href="/2021/10/05/futures-python/"/>
      <url>/2021/10/05/futures-python/</url>
      
        <content type="html"><![CDATA[<p>無論是哪門程式語言，併發(Concurrent)和並行(Parallel)都是很常用且重要的知識點。舉個例子，像是爬蟲技術被廣泛運用在工業界的資料收集領域，其中的核心技術就是併發並行程式設計。</p><p>正確合理地使用併發和並行，無疑會讓我們的程式性能大幅提升。之前我們聊到過Python Coroutine，今天我們來聊聊Python的Futures。</p><span id="more"></span><h3 id="併發-Concurrent-和並行-Parallel-的差別"><a href="#併發-Concurrent-和並行-Parallel-的差別" class="headerlink" title="併發(Concurrent)和並行(Parallel)的差別"></a>併發(Concurrent)和並行(Parallel)的差別</h3><ol><li><strong>併發</strong>：指的是在同一個CPU下，透過上下文切換(Context switch)，讓使用者覺得不同程式段同時執行。這通常應用在I/O頻繁或耗時的場景，例如下載多個檔案，I/O所消耗的時間會比CPU多。</li><li><strong>並行</strong>：則是真正意義上的多個CPU同時執行，適合CPU heavy的場景，例如MapReduce的計算，為了加快速度，需要更多的CPU來完成。</li></ol><p>需要注意的是，即使電腦有四顆CPU，理論上可以同時並行跑四個Threads，但在Python卻不能這樣。Python的直譯器有race condition的問題，因此同一時刻只能允許一個Thread執行。具體原因在後續講到GIL時會深入探討。</p><h3 id="Python的Futures-Library"><a href="#Python的Futures-Library" class="headerlink" title="Python的Futures Library"></a>Python的Futures Library</h3><p>Python的Futures library提供了方便的併發和並行框架，能夠建立thread pool、process pool等。下面是一個簡單的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loading_one</span>(<span class="params">name</span>):</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Job %s is completed.&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">names</span>):</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.<span class="built_in">map</span>(loading_one, names)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    jobnames = [<span class="string">&#x27;JobA&#x27;</span>, <span class="string">&#x27;JobB&#x27;</span>, <span class="string">&#x27;JobC&#x27;</span>, <span class="string">&#x27;JobD&#x27;</span>]</span><br><span class="line">    start_time = time.perf_counter()</span><br><span class="line">    loading(jobnames)</span><br><span class="line">    end_time = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Load &#123;&#125; jobs in &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(jobnames), end_time - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Job JobB is completed.</span></span><br><span class="line"><span class="comment"># Job JobD is completed.</span></span><br><span class="line"><span class="comment"># Job JobA is completed.</span></span><br><span class="line"><span class="comment"># Job JobC is completed.</span></span><br><span class="line"><span class="comment"># Load 4 jobs in 0.706298665 seconds</span></span><br></pre></td></tr></table></figure><p>執行結果顯示耗時不到一秒，由於<code>random.random()</code>返回介於0和1之間，證明確實是併發執行的。這裡我們建立了thread pool：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>最多可以同時使用五個Threads，而<code>executor.map</code>就像Python裡的map一樣，對每個<code>names</code>的元素呼叫<code>loading_one</code>函數。雖然可以自己設定thread的數量，但不是越多越好，因為thread的創建、維護、刪除都有性能消耗，設定太大可能導致速度更慢。</p><p>當然，我們也可以把上述程式碼改成”併行”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>函數<code>ProcessPoolExecutor</code>代表創建Process pool。有興趣的讀者可以嘗試，通常改成<code>ProcessPoolExecutor</code>後耗時更多，這是因為並行的方式適合CPU heavy的情況。</p><h3 id="Python-Futures和asyncio的比較"><a href="#Python-Futures和asyncio的比較" class="headerlink" title="Python Futures和asyncio的比較"></a>Python Futures和asyncio的比較</h3><p>有沒有發覺Python的Futures library和asyncio非常像？它們都會將等待的job放進list裡，這些job可以隨時查詢。當然，它們的結果和異常(<code>job.result()</code>)也能在結束後拿到。</p><p>再介紹一個Futures常用的方法 - <code>done()</code>，表示該job是否已完成。<code>done()</code>是non-blocking的，呼叫後會立即返回。還有一個方法是<code>add_done_callback(func)</code>，當job完成後，會通知並呼叫callback function。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>我們學習了併發(Concurrent)和並行(Parallel)的差別：<ul><li>併發：通常用於I/O密集的場景</li><li>並行：適合CPU heavy的場景</li></ul></li><li>展示了Python Futures library的例子，透過Thread Pool和Process Pool展示如何利用併發和並行執行程式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> concurrent </tag>
            
            <tag> parallel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]與成功有約：高效能人士的七個習慣</title>
      <link href="/2021/10/03/7habits_book/"/>
      <url>/2021/10/03/7habits_book/</url>
      
        <content type="html"><![CDATA[<h3 id="與成功有約：高效能人士的七個習慣"><a href="#與成功有約：高效能人士的七個習慣" class="headerlink" title="與成功有約：高效能人士的七個習慣"></a>與成功有約：高效能人士的七個習慣</h3><p><img src="/images/7habit.jpg"></p><p>閱讀《高效能人士的七個習慣》讓我獲益匪淺。這本書架構清晰，條列式地列出了不同高效能人士的習慣。我閱讀的是英文版，這類書通常不會用太艱深的詞彙，因此不僅可以學習高效能人士的好習慣，還能提升英文閱讀能力。以下是我讀完後的總結：</p><span id="more"></span><ol><li><p><strong>主動 (Proactive)</strong></p><ul><li>不受環境影響，只根據自己的價值觀做決策。</li><li>不要怪罪外在環境，多思考如何改變自己。</li></ul></li><li><p><strong>以終為始 (Begin with the End in Mind)</strong></p><ul><li>明確最終目標，不被短期的小目標分心。</li><li>任何事物都是先在腦中設計一次，然後在現實中創造一次。</li><li>領導是做對的事，管理是把事做對。</li><li>人生包含安全感、指導、智慧和能力。如果你是原則至上的人，更容易獲得這四個方面。</li><li>原則至上的人不受外在和情緒的影響，會在計算各個選項的價值後再做決定。</li><li>我覺得我現在是一半以自我為中心，一半以原則為中心。</li><li>面對一件可怕的事前，先想像成功的樣子。</li></ul></li><li><p><strong>要事第一 (Put First Things First)</strong></p><ul><li>事情分為四個象限：重要且緊急、重要但不緊急、不重要但緊急、不重要也不緊急。很多人永遠困在重要且緊急的事上，並把剩下的時間花在不重要也不緊急的事上。</li><li>重要和緊急是不同的概念。</li><li>要高效，必須先定義好重要的事，也就是重要且緊急和重要但不緊急的事。</li><li>設定一週的計劃剛剛好，一天則太僵硬。</li></ul></li><li><p><strong>雙贏思維 (Think Win-Win)</strong></p><ul><li>只有雙贏和雙輸，沒有單贏或單輸。</li><li>把「無交易」作為一個選項。</li></ul></li><li><p><strong>知彼解己 (Seek First to Understand, Then to Be Understood)</strong></p><ul><li>幫助他人解決問題前，必須先診斷，而不是把自己的方法強加於對方。</li><li>學會聆聽。</li><li>聆聽的技巧：重複對方的話，或換句話說，讓對方覺得你理解他。</li></ul></li><li><p><strong>統合綜效 (Synergize)</strong></p><ul><li>尋找共享的目標，1 + 1 &gt; 2。</li><li>欣賞不同，換位思考。</li><li>通過看到差異和尋找更好的方案，展示創新及解決問題的能力。</li></ul></li><li><p><strong>不斷更新 (Sharpen the Saw)</strong></p><ul><li>平衡發展四個維度的能力：<ul><li>社會 (Social) - 協同能力</li><li>身體 (Physical) - 身體健康</li><li>心智 (Mental) - 閱讀、寫作、計劃</li><li>靈性 (Spiritual) - 冥想、看清價值</li></ul></li><li>這是一種重要但不緊急的事。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 與成功有約：高效能人士的七個習慣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的coroutine</title>
      <link href="/2021/09/29/coroutine-python/"/>
      <url>/2021/09/29/coroutine-python/</url>
      
        <content type="html"><![CDATA[<p>Coroutine（協程）和我們常聽到的 multithread（多執行緒）、multiprocess（多進程）一樣，都是一種併發（concurrent）方式。需要注意的是，併發和併行（parallel）不同，併發是快速的上下文切換，讓使用者感覺程式同時在執行，而併行是指不同 CPU 同時執行多個任務。</p><span id="more"></span><p>隨著互聯網的快速發展，我們遇到了所謂的 C10k 問題，也就是同時連接到伺服器的客戶端數量達到一萬個，這會造成進程上下文切換佔用了大量資源，即使是執行緒也難以承受如此巨大的壓力。於是 Coroutine 登場了。</p><p>很多人說 Coroutine 是輕量化的 Thread，那麼 Coroutine 和 Thread 有什麼不同呢？最大的差別在於 Thread 是搶佔式多工，而 Coroutine 是協同式多工。</p><h5 id="搶佔式多工"><a href="#搶佔式多工" class="headerlink" title="搶佔式多工"></a>搶佔式多工</h5><p>程式有各自的優先權，作業系統會根據程式的優先權安排當下哪個程式能擁有 CPU 資源去執行，另外作業系統有權中斷任何正在執行中的程式。</p><h5 id="協同式多工"><a href="#協同式多工" class="headerlink" title="協同式多工"></a>協同式多工</h5><p>程式會定時放棄已佔有的執行資源讓其他程式執行。由於是由程式自己讓出執行資源，不需要由底層的作業系統來處理，所以 Coroutine 交替時所產生的上下文切換負擔比 Thread 小。</p><p>接下來，我們給個範例，看看 Python 的 Coroutine 怎麼寫。Python 的 Coroutine library 是 <code>asyncio</code>，需要跑在 Python 3.7 以上的環境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">sec</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loading... needs <span class="subst">&#123;sec&#125;</span> secs to load&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;OK <span class="subst">&#123;sec&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">secs</span>):</span><br><span class="line">    <span class="keyword">for</span> sec <span class="keyword">in</span> secs:</span><br><span class="line">        <span class="keyword">await</span> loading(sec)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br></pre></td></tr></table></figure><p><code>async</code> 代表這個函數是非同步函數，意思是會順序執行的。然後來說說執行的方法，執行有三種方式：</p><ol><li>透過 <code>await</code> 來呼叫<ul><li><code>await</code> 的執行效果和 Python 平常運行程式的效果一樣，會阻塞在這裡，執行完後再繼續。</li></ul></li><li>透過 <code>asyncio.create_task()</code> 來創建任務</li><li>透過 <code>asyncio.run()</code> 來執行，不用去理會 Event loop 怎麼運行的</li></ol><p>上面的程式碼順序的跑了 10 秒是正常的，因為 <code>await</code> 會阻塞。接下來我們要來講 Coroutine 一個重要的概念——Task。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">sec</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loading... needs <span class="subst">&#123;sec&#125;</span> secs to load&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;OK <span class="subst">&#123;sec&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">secs</span>):</span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>我們可以看到，當 Task 被 create 之後就會開始執行，然後我們對每個 Task 加了 <code>await</code>，等所有 Task 都執行完後才能繼續下一步，或是可以看我註解掉的那一行 <code>await asyncio.gather(*tasks)</code>，也能達到同樣的目的。</p><h3 id="Coroutine-runtime"><a href="#Coroutine-runtime" class="headerlink" title="Coroutine runtime"></a>Coroutine runtime</h3><p>接下來我們來解析 Coroutine 的 runtime 和背後的邏輯，我們一樣用上面的例子，步驟有點多，我們慢慢來：</p><ol><li><code>asyncio.run(main())</code>，程式進入 main() 函數，同時也開啟了 Event loop</li><li>兩個 Task 都被創建，進入 Event loop 等待被執行，執行到 <code>print</code>，輸出 <code>loading...</code></li><li>await 五秒的 Task，Event loop 開始調度 worker1</li><li>worker1 開始執行，遇到 <code>await.sleep</code>，從現在的 Task 切出，Event loop 開始調度 worker2</li><li>worker2 開始執行，一樣遇到 <code>await.sleep</code>，從現在的 Task 切出</li><li>以上的時間都非常快，由於兩個都在 sleep，所以 Event loop 暫停調度</li><li>3 秒鐘後 worker2 的 sleep 完成，Event loop 將控制權交給三秒的 Task，<code>print</code> 出 <code>OK 3</code>，Task 完成，從 Event loop 退出</li><li>再兩秒鐘後，同理 worker1 的 sleep 完成，<code>print</code> 完後，從 Event loop 退出</li><li>Coroutine 全部結束</li></ol><p>接下來我們進階一下，如果想給 Coroutine 任務限定執行時間，一但超時就取消，該怎麼做呢？以及如果 runtime 發生錯誤，又該怎麼處理？我們來看看下面的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker1</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker2</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker3</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task_1 = asyncio.create_task(worker1())</span><br><span class="line">    task_2 = asyncio.create_task(worker2())</span><br><span class="line">    task_3 = asyncio.create_task(worker3())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    task_3.cancel()</span><br><span class="line"></span><br><span class="line">    res = <span class="keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), CancelledError()]</span></span><br></pre></td></tr></table></figure><p>我們可以看到，worker1 正常執行，worker2 執行中遇到錯誤，worker3 執行太久被我們取消了。到這裡，其實 Thread 能做的 Coroutine 也能做。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本篇講解了 Python Coroutine 的基本概念和用法，這裡簡單總結一下：</p><ul><li>Coroutine 和 Thread 的差別主要是 Coroutine 只能用一個 CPU core，以及 Coroutine 是程式決定什麼時候要切換任務。</li><li>Coroutine 的寫法更加簡潔清晰，滿足中小級別的併發需求。</li><li>寫 Coroutine 的時候，腦海要有清晰的 Event loop 概念，知道什麼時候需要暫停、等待 I/O，什麼時候可以執行到底。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的iterator和generator</title>
      <link href="/2021/09/25/iterator-generator-python/"/>
      <url>/2021/09/25/iterator-generator-python/</url>
      
        <content type="html"><![CDATA[<p>剛開始寫Python的時候，你可能對於Python的語法<code>for i in [2, 4, 6, 8, 10]</code>感到驚艷，這種簡潔的語法相比C++或Java來說直觀了許多。然而，你有沒有想過Python在處理<code>for in</code>的時候，背後到底發生了什麼？什麼樣的object可以被放進<code>for in</code> loop呢？</p><span id="more"></span><h3 id="Container和Iterator"><a href="#Container和Iterator" class="headerlink" title="Container和Iterator"></a>Container和Iterator</h3><p>Container的概念非常簡單，Python中的一切皆為object，而object的集合就是Container，例如list, set, tuple等等。所有的Container都是iterable（可迭代的）。可迭代是什麼意思呢？你可以想像一下你去水果攤買蘋果，老闆不告訴你庫存情況，每次你只需要跟老闆說「我要一個蘋果」，直到老闆告訴你「蘋果沒了」。Container透過<code>iter()</code>返回一個Iterator，然後我們可以透過<code>next()</code>就像跟老闆要蘋果那樣，一個一個要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_arr = <span class="built_in">iter</span>(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>當老闆說沒有蘋果的時候，就會throw exception出來。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator可以理解為懶人版的Container。生成一個Container很簡單，<code>[i for i in range(100000000)]</code>就可以生成一億個int的array，每個元素都會保存在記憶體當中。當然，轉成Iterator後也是，只是他們取用元素的方式不同而已。Generator的使用方法和Iterator類似，都是需要後再取，只是Iterator會預先把所有元素放進記憶體，而Generator會等到需要拿的時候才會把該元素載入記憶體。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_memory_info</span>(<span class="params">hint</span>):</span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_iterator</span>():</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing iterator&#x27;</span>)</span><br><span class="line">    list_1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after iterator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_1))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_generator</span>():</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing generator&#x27;</span>)</span><br><span class="line">    list_2 = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after generator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_2))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_iterator()</span><br><span class="line">test_generator()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initing iterator memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after iterator initiated memory used: 2015.828125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 3869.05078125 MB</span></span><br><span class="line"><span class="comment"># initing generator memory used: 9.5703125 MB</span></span><br><span class="line"><span class="comment"># after generator initiated memory used: 9.58203125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 9.58203125 MB</span></span><br></pre></td></tr></table></figure><p>我們可以看到記憶體驚人的差異，在Iterator和Generator初始記憶體都差不多的情況下，Iterator需要2GB的記憶體，而Generator只需要9.5MB。如果遇到不需要同時在記憶體保存這麼多東西的場景，例如元素總和，可以使用Generator。由上面的範例可以看到，Generator的初始化寫法是<code>(i for i in range(100000000))</code>。</p><p>那麼Generator還能怎麼玩呢？例如我們想要驗證一個數學公式{(1+2+3+…+n)^2 = 1^3 + 2^3 + 3^3 + … + n^3}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">k</span>):</span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">yield</span> i ** k</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen_1 = generator(<span class="number">1</span>)</span><br><span class="line">gen_3 = generator(<span class="number">3</span>)</span><br><span class="line">sum_1 = <span class="number">0</span></span><br><span class="line">sum_3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   sum_1 += <span class="built_in">next</span>(gen_1)</span><br><span class="line">   sum_2 = sum_1 ** <span class="number">2</span></span><br><span class="line">   sum_3 += <span class="built_in">next</span>(gen_3)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;sum_2: %s, sum_3: %s&quot;</span> % (sum_2, sum_3))</span><br><span class="line">   time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><code>yield</code>是Generator獨有的，你可以理解為在<code>next</code>之前，它會被卡在這裡，呼叫<code>next</code>之後<code>yield</code>就會return值出來。你看，有了Generator，我就能一直無限的驗證下去，不用擔心記憶體爆炸。Iterator是一個有限集合，Generator是一個無限集合！</p><p>除此之外，Generator也能讓程式碼更加簡潔有力！讓我們看下面的例子，輸入一個array和一個數字，找出該數字在array的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iterator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_iter</span>(<span class="params">arr, val</span>):</span><br><span class="line">   res = []</span><br><span class="line">   <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">      <span class="keyword">if</span> v == val:</span><br><span class="line">         res.append(idx)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">   </span><br><span class="line"><span class="comment"># Generator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_gen</span>(<span class="params">arr, val</span>):</span><br><span class="line">   <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">      <span class="keyword">if</span> v == val:</span><br><span class="line">         <span class="keyword">yield</span> idx</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">val = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(find_iter(arr, val))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(find_gen(arr, val)))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [2, 6, 8]</span></span><br><span class="line"><span class="comment"># [2, 6, 8]</span></span><br></pre></td></tr></table></figure><p>顯然的，Generator清爽多了。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本篇講了Container, Iterator和Generator</p><ul><li>Container是Iterable的，代表將Container放進for in裡我們可以一個個迭代</li><li>Generator是一個特殊的Iterator，使用Generator可以寫出更清新，更省資源的程式碼</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]IP&amp;MAC地址 - 網路通訊世界的大門</title>
      <link href="/2021/09/23/ipbasic-network/"/>
      <url>/2021/09/23/ipbasic-network/</url>
      
        <content type="html"><![CDATA[<h3 id="每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼"><a href="#每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼" class="headerlink" title="每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼"></a>每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼</h3><p>警察要找你，他是怎麼透過你的身分證找到你的呢？<br>藉由身分證上的戶籍地址(IP)，找到了你的家，按下你家的門鈴後，大喊了身分證號碼(MAC)，你到了門口，警察就這樣找到你了</p><span id="more"></span><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址就像是電腦網卡裡家家戶戶的門牌號碼。有了IP，資料就能一層層路由到目的地電腦。我們要怎麼查電腦裡的IP門牌號碼呢？</p><p>在Linux，有兩個指令可以查詢，分別為<code>ifconfig</code>和<code>ip addr</code>。</p><p><strong>ifconfig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6251  bytes 9073424 (8.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3111  bytes 170522 (166.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ip addr</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/tunnel6 :: brd ::</span><br><span class="line">13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p><code>ifconfig</code>來自於Linux的net-tools，而<code>ip addr</code>來自於iproute2。net-tools起源於BSD，自2001年起，Linux社群已經對其停止維護，而iproute2旨在取代net-tools，並提供了一些新功能。一些Linux發行版已經停止支援net-tools，只支援iproute2。net-tools通過procfs(/proc)和ioctl system call去訪問和改變kernel網路設定，而iproute2則通過netlink socket interface與kernel通訊。net-tools中工具的名字比較雜亂，而iproute2則相對整齊和直觀，基本是ip command加後面的sub-command。不過這麼多年過去了，net-tool依然還在被廣泛使用，最好還是兩套指令都掌握吧。</p><p>IP地址是門牌號碼，所以不能大家都一樣，不然就會起衝突。舉個例子，<code>132.128.200.32</code>是一個IP地址，由三個”.”分成四個部分，每個部分有8個bit，四個部分加起來總共有32個bit，也就是最多只能產生<code>2**32</code>個門牌號碼。因為不夠用，所以有了IPv6，也就是上面的輸出結果<code>fe80::ca61:d665:1750:e806</code>，總共有128位，看起來應該是夠了。</p><p>現有的32bit IP地址不夠用，於是IP地址分為私人IP(內網IP)和公共IP(任何地方都能連的IP，例如Google)。私人IP地址的目的是為了安全以及讓更多電腦能有自己的IP地址。試想一下，如果大家都能訪問你的電腦，如果你的電腦被植入了惡意程式，某個port被打開，是如此的不安全。下面的IP地址範圍就是私人地址：</p><table><thead><tr><th>地址範圍</th><th>數量</th></tr></thead><tbody><tr><td>10.0.0.0–10.255.255.255</td><td>16,777,216</td></tr><tr><td>172.16.0.0–172.31.255.255</td><td>1,048,576</td></tr><tr><td>192.168.0.0–192.168.255.255</td><td>65,536</td></tr></tbody></table><p>所以下次你跑<code>ip addr</code>看到你的IP是<code>192.168.2.132</code>，不用懷疑，你在私人IP裡，外面的電腦無法和你的電腦連結。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址是一個容易和IP地址誤解的地址，因為MAC地址號稱全世界唯一，那既然唯一了，為何我們還要IP地址呢？其實MAC地址與其說是個地址，不如說它是個網路ID。</p><p>舉個例子，我們要找一個人，他的身分證是A123456789，身分證上面寫的地址是<code>台北市文山區興隆路五段9弄18號4樓</code>。後面的地址就像是電腦的IP，而身分證就是這個人。</p><p>MAC地址其實是可以改的，只要不要在同個內網下有多個相同的MAC地址。就像是同個家庭，不要有重複的”身分證”。從上面的<code>ip addr</code>指令，我們可以看到MAC地址是<code>02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</code>。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本篇文章講述了IP地址和MAC地址的差別，以及怎麼查詢我們的IP和MAC地址：</p><ul><li>IP地址 - 電腦的門牌地址，目的是<strong>路由</strong>，常見於TCP/IP五層的第三層</li><li>MAC地址 - 電腦的唯一ID，目的是<strong>最終指向目的地電腦</strong>，常見於TCP/IP五層的第二層(鏈接層)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> IP </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview-network/"/>
      <url>/2021/09/20/overview-network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成”協議”，巴別塔的計劃就失敗了。</p><p>但是千年以後，有一種叫”程序猿”的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p><img src="/images/overview_internet.png"></p><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議 (TCP/IP stack) 進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的。具體MAC和IP地址的詳細內容和區別可以看<a href="/2021/09/23/ipbasic-network/">這一篇</a></p><h3 id="為何我們常見的TCP-IP要分層呢？"><a href="#為何我們常見的TCP-IP要分層呢？" class="headerlink" title="為何我們常見的TCP/IP要分層呢？"></a>為何我們常見的TCP/IP要分層呢？</h3><p>因為任何複雜的程式或應用都要分層，這是大型程式設計的基本要求。例如，複雜的電商系統還會分成資料庫層、Cache層、Compose層和Controller層等等，每一層專注做本層的事情。</p><p>TCP/IP是一個公認的網路通訊協議，它是OSI七層模型的簡化版，包含五層：物理層、鏈路層、網路層、傳輸層和應用層。下面用簡短的話來分別解釋這五層的功能：</p><p><strong>物理層 (Physical):</strong> 處理網路線、無線傳輸設備，例如光纖。<br><strong>鏈路層 (Link):</strong> 負責乙太網路的傳輸，並具有資料糾錯功能，例如漢明碼。<br><strong>網路層 (Internet):</strong> 確保數據的路由，如何把數據從一個MAC地址傳輸到另一個MAC地址。<br><strong>傳輸層 (Transport):</strong> 包括TCP、UDP，其中TCP保證邏輯上的end-to-end可靠性。<br><strong>應用層 (Application):</strong> 用於網路相關應用的交互，例如HTTP、SSH等等。</p><p>那麼，層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線。Header放在每一層數據包的最前面，如下圖所示：</p><p><img src="/images/tcpiplayer.png"></p><p>所以，網路封包的傳輸過程是從應用層開始，加上Header，一直加到傳輸層，然後路由器會根據Header路由封包到目的地。到了目的地電腦，再根據Header進行逐層解析，最後回到應用層。</p><p>例如，鏈路層的Header固定長度是14 bytes，我們的作業系統在解析封包時，會先取前面14 bytes進行解析，這14 bytes包含了三項數據 - 鏈路層的protocol、起始MAC地址、目的地MAC地址。</p><p>網路應用開發人員主要需要了解第三到第五層，我們常看到的ping、traceroute、HTTP、FTP等等都是後三層的應用。之後我們會偏重解析這三層並基於這三層建構應用。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ol><li>TCP/IP 分層的原因是為了將複雜的任務劃分成易於管理的小部分。</li><li>每層都有自己的專門功能，並通過header來明確區分每層的界線。</li><li>網路應用開發主要關注第三到第五層。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的@Decoractor</title>
      <link href="/2021/09/18/decorector-python/"/>
      <url>/2021/09/18/decorector-python/</url>
      
        <content type="html"><![CDATA[<p>今天這篇文章，我們來學習一下 Python 的 Decorator 裝飾器。</p><p>Decorator 在 Python 是一個非常經典的功能，在工程中應用廣泛，例如日誌 (Log)、快取 (Cache)、多執行緒 (Threading) 等等。</p><span id="more"></span><h3 id="Function-Decorator"><a href="#Function-Decorator" class="headerlink" title="Function Decorator"></a>Function Decorator</h3><p>其實 Decorator 就是對函數的封裝，可以理解為在函數的前後做一點“裝飾”。我們會從 Python 的 <code>lambda</code> 切入講解，介紹 Decorator 的基本概念和用法，最後透過一個實際的例子加深理解。</p><p>前面說過，Python 的一切皆為物件，連函數也不例外。我們來看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">helloworld = func</span><br><span class="line">helloworld()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>從上面的例子，我們把 <code>func</code> 作為一個變數賦值給 <code>helloworld</code>，然後呼叫 <code>helloworld</code>，相當於呼叫了 <code>func</code>。所以我們也可以把函數作為一個參數傳到另一個函數裡面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printer</span>(<span class="params">func</span>):</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>有了這些基礎概念後，我們接下來可以深入挖掘 Decorator。按照 Decorator 的思路，就是對某個函數做前後包裝，例如我們想要計算每個傳進來的函數執行花了多少時間，可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printer</span>(<span class="params">func</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line"></span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.220008850097656e-05 secs</span></span><br></pre></td></tr></table></figure><p>更通用一點，我們可以把 <code>printer</code> 封裝成更通用的函數直接返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_benchmark</span>(<span class="params">func</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">printer = decorator_benchmark(print_hello_world)</span><br><span class="line">printer()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 5.2928924560546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們把原本的 <code>print_hello_world</code> 封裝成 <code>decorator_benchmark</code> 的內部函數，這樣在外面呼叫就會非常簡潔。不過這樣還是有點麻煩，如果我們總是需要對 <code>print_hello_world</code> 測量性能，呼叫之前都需要對它封裝一次，那有沒有更簡潔的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_benchmark</span>(<span class="params">func</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_benchmark</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.38690185546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們在 <code>print_hello_world</code> 上面加了 <code>@decorator_benchmark</code>，其中 <code>@</code> 是 Python 裡的語法糖。我們可以對一些常見的功能，例如效能測量 (benchmark)、日誌 (log) 等等寫成一個 Decorator 函數，然後再對其他函數進行“裝飾”，這樣就大大提高了程式的重複利用性和可讀性。</p><p>當然，Decorator 具有強大的靈活性，我們也可以對其傳入參數，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>不過這樣寫有個副作用是，我們裝飾後的 <code>print_hello_world</code> 的元數據 (metadata) 就被改變了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure><p>它告訴我們函數不再是原來的 <code>print_hello_world</code>，而是被 <code>wrapper</code> 取代了。不過俗話說得好，見招拆招。為了解決這個問題，我們可以使用 Python 已有的 Decorator <code>@functools.wraps</code>，它會保留原本函數的元數據（也就是將原本函數的元數據複製到 Decorator 裡面）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Help on function print_hello_world in module __main__:</span></span><br><span class="line"><span class="comment"># print_hello_world()</span></span><br></pre></td></tr></table></figure><h3 id="Class-Decorator"><a href="#Class-Decorator" class="headerlink" title="Class Decorator"></a>Class Decorator</h3><p>最後來說說 Class Decorator。前面提到的 Decorator 是以函數為形式的，其實 class 也可以作為 Decorator，這樣可以持久化存一些資料。Class Decorator 藉由函數 <code>__call__</code>，每當呼叫一次被裝飾的函數時，就會呼叫一次 <code>__call__</code>。我們以“計算函數被呼叫的次數”作為例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">      self.num_call = <span class="number">0</span></span><br><span class="line">      self.func = func</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">      self.num_call += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Num of call is %s&quot;</span> % self.num_call)</span><br><span class="line">      <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello_world</span>():</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Num of call is 1</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Num of call is 2</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>所謂的 Decorator，就是透過去“裝飾”函數，增加或改變已有函數的功能，使得原有函數不需要修改。有如下優點：</p><ul><li>封裝原有程式碼</li><li>程式碼簡潔</li><li>易讀</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python Object的比較和複製</title>
      <link href="/2021/09/16/object-op-python/"/>
      <url>/2021/09/16/object-op-python/</url>
      
        <content type="html"><![CDATA[<p>Python 的任何 variable 都是 C++ 的 Object，所以我們在對 Python 的 variable 做任何操作時，其實就是在對 Object 做。例如，我們做 variable 比較時：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><span id="more"></span><p>variable 複製：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = <span class="built_in">list</span>(a)</span><br></pre></td></tr></table></figure><p>可是如果只是”賦予”新的 variable，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>b</code> 會影響 <code>a</code>，因為它們共享同個記憶體上的 address。不過透過上面的範例，你可能還是不太清楚：</p><ul><li><code>a == b</code> 是比較兩個 object address 相等呢？還是 value 相等呢？</li><li><code>b = list(a)</code> 是 shallow copy 還是 deep copy 呢？</li></ul><h4 id="比較語法"><a href="#比較語法" class="headerlink" title="比較語法"></a>比較語法</h4><p>在 Python 中你應該遇過下面兩個語法，你能分辨出有什麼不同嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>==</code> 表示兩個 variables 的”值”是否相等，<code>is</code> 表示兩個 variables 是否為同一個 Object，是否 address 也相同。在 Python 中，我們可以透過 <code>id(variable)</code> 去拿 variable 的唯一 ID，所以判斷 <code>a is b</code> 如同 <code>id(a) == id(b)</code>。我們再看一個百思不得其解的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="comment"># Output: True</span></span><br></pre></td></tr></table></figure><p>咦？<code>a</code> 和 <code>b</code> 是兩個不同的變數呀，為何它們的 id 會相同呢？我們說過，Python 的任何 variable 都是 C++ 的 Object，int 也不例外。然而，為了提升性能，C++ 把常用的數字 -5 到 256 先定義好，作為 cache 使用，當 Python 需要時，直接從這個 pool 拿去引用。於是乎：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="comment"># Output: False</span></span><br></pre></td></tr></table></figure><p>有興趣的讀者可以試試。再來，我們來探討 <code>==</code> 和 <code>is</code> 性能的部分。通常，<code>is</code> 會比 <code>==</code> 快很多，因為 <code>is</code> 不會被 overload，這樣 Python 就不需要去尋找 <code>__eq__</code>，<code>a == b</code> 實際上做的事情等同於 <code>a.__eq__(b)</code>。</p><h4 id="copy-語法"><a href="#copy-語法" class="headerlink" title="copy 語法"></a>copy 語法</h4><p>所謂的 copy，指的是重新分配一塊記憶體，創建一個新的 Object，所以它們的 id 肯定是不同的。而 copy 又分 shallow copy 和 deep copy。所謂的 shallow copy，新的 Object 裡面的元素是原本 Object 裡面元素的引用，所以如果 Object 裡面的 Object 被改了，新舊 Object 都會被連動。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">b = <span class="built_in">list</span>(a)</span><br><span class="line">b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">a</span><br><span class="line"><span class="comment"># Output: [1, [1, 2, 3, 4]]</span></span><br></pre></td></tr></table></figure><p>可以看到 variable <code>b</code> append 4 之後，<code>a</code> 裡面的 list 也被影響了。而 deep copy，相對於 shallow copy 來說，會遞迴的方式往裡面一直 copy，所以新的 Object 和舊的 Object 沒有任何關聯。Python 中透過 <code>copy.deepcopy(object)</code> 實現 deep copy，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># Output: [1, [1, 2, 3]]</span></span><br></pre></td></tr></table></figure><p>我們可以看到 <code>a</code> 不受任何影響即使 <code>b</code> append 了 4。最後我們再來探討 mutable (可變) Object 和 immutable (不可變) Object，看一下下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1000</span></span><br><span class="line">b = a</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">b</span><br><span class="line"><span class="comment"># Output: 1000</span></span><br></pre></td></tr></table></figure><p>我們可以看到，<code>a += 1</code> 後竟然沒有影響 <code>b</code>，不是說 Python 一切 variable 皆是 object 嗎？這是因為在 Python 中 int, float, string, tuple 等屬於 immutable object，不能改 object 裡面的值。我們可以看到 <code>a += 1</code> 之後，<code>a</code> 的 id 變了，代表它被重新賦予新的 object：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1000</span></span><br><span class="line"><span class="built_in">id</span>(a)</span><br><span class="line"><span class="comment"># Output: 140628677809328</span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="built_in">id</span>(a)</span><br><span class="line"><span class="comment"># Output: 140628677809168</span></span><br></pre></td></tr></table></figure><p>而 dict, array, set 等等，屬於 mutable object，在 assign 或是當作參數傳進去 function 的時候，會影響該 variable。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這篇文章講了 Python 的 variable 怎麼做比較和複製：</p><ul><li>Python 的一切皆為 Object，所以比較和複製的思維可以參考 C++</li><li>Object 間的比較分成 address 和 value 的比較，分別為 <code>is</code> 和 <code>==</code></li><li>Object 間的複製分成 shallow 和 deep copy，一個只複製了第一層的 value，另一個會遞迴複製。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object-storage/"/>
      <url>/2021/09/13/object-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="Object-Storage-物件儲存"><a href="#Object-Storage-物件儲存" class="headerlink" title="Object Storage(物件儲存)"></a>Object Storage(物件儲存)</h3><p><strong>Object Storage - 雲端系統上最流行的儲存方式</strong></p><p>Object storage和File storage一樣，是基於Block storage的，但有幾個關鍵的不同點。File storage就像是一棵樹，從根開始有多層資料夾（樹枝）和檔案（葉子），是典型的層次結構。而Object storage則是扁平化的結構，所有檔案都存在單一資料夾中，沒有子資料夾，這使得資料索引和訪問變得更加直接和快速。</p><span id="more"></span><h3 id="Metadata-的彈性設計"><a href="#Metadata-的彈性設計" class="headerlink" title="Metadata 的彈性設計"></a>Metadata 的彈性設計</h3><p>Object storage 的 metadata 不是固定的 inode 結構，而是可以自定義的。這種彈性設計讓使用者可以根據需求設計適合自己應用的 metadata，提升檢索效率。</p><h3 id="大數據與非結構化資料的完美搭配"><a href="#大數據與非結構化資料的完美搭配" class="headerlink" title="大數據與非結構化資料的完美搭配"></a>大數據與非結構化資料的完美搭配</h3><p>Object storage 特別適合存放靜態且不常變動的大數據，例如影片、音樂等。它提供大量、安全且低成本的儲存服務，特別適合長期保存。</p><h3 id="HTTP-API-的簡單操作"><a href="#HTTP-API-的簡單操作" class="headerlink" title="HTTP API 的簡單操作"></a>HTTP API 的簡單操作</h3><p>從高層次來看，Object storage 是透過 HTTP API 進行資料的增刪改查，這比 File system API 和 Block storage 的 SCSI 更加簡單易用。不同語言都可以輕鬆使用這些 API 來操作 Object storage，這使得它適合各種應用情境。</p><h3 id="天生適合分散式儲存"><a href="#天生適合分散式儲存" class="headerlink" title="天生適合分散式儲存"></a>天生適合分散式儲存</h3><p>由於其扁平化架構，Object storage 非常適合用於分散式儲存。資料可以輕易地分散到多台機器上，並且可以快速擴展。增加新的機器就像擴大這個”資料夾”的空間，不僅提升儲存容量，也提高了資料的可靠性。例如，一個 object 可以被複製多份，這樣即使一台機器發生故障，資料仍然安全。</p><h3 id="可靠性與成本效益"><a href="#可靠性與成本效益" class="headerlink" title="可靠性與成本效益"></a>可靠性與成本效益</h3><p>雖然直接複製物件簡單易行，但大多數雲端服務提供商會使用更高效的方式來節省空間，例如 RAID5，這種方式只需使用 150% 的空間就能達到相同的可靠性。</p><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只需增加機器就能增加儲存空間，無需額外修改架構。</li><li><strong>成本低</strong>:<br>公有雲上的Object storage非常便宜，例如Amazon S3。</li><li><strong>API 簡單</strong>:<br>使用HTTP進行增刪改查，支持跨國使用。例如你在台灣可以使用位於美國的Amazon S3儲存服務。</li></ul><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ul><li><strong>不能修改</strong>:<br>一個Object不能部分修改，必須整個替換。而File system則可以直接在末尾增加資料。</li><li><strong>無法與database整合</strong>:<br>傳統的database是結構化數據，例如SQL, MySQL，而Object storage主要存放非結構化數據，且讀寫速度較慢。</li><li><strong>無法與一般作業系統整合</strong>:<br>一般的作業系統都是基於File system，下載一個Object就像下載一個檔案，需要整體下載。</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>扁平化結構便於擴展</li><li>彈性的 metadata 設計</li><li>適合存放靜態大數據</li><li>API 簡單易用</li><li>成本效益高</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file-storage/"/>
      <url>/2021/09/12/file-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="File-storage-檔案系統"><a href="#File-storage-檔案系統" class="headerlink" title="File storage(檔案系統)"></a>File storage(檔案系統)</h3><p>有了File storage，就能讓我們輕鬆地寫程式來操作資料！</p><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好。你怎麼知道你的資料存在哪個Block？是連續存還是分散存？如果每筆資料都連續存，那硬碟的利用率會很差；如果分散存，需要用Linked-List資料結構來記錄位置。任何架構的難題只需要加一層就可以解決，如果不行，那就加兩層。為了讓人能夠輕鬆操作儲存資料，作業系統在Block storage上加了一層File system。</p><span id="more"></span><p>我們平常用的Windows系統為了讓使用者方便存取資料，就是使用File system，這大家應該很熟悉。用滑鼠點一點、鍵盤敲一敲，就可以對檔案進行存取。由於File system就是在Block storage上加一層，所以檔案的內容都是存放在一個個的block中。</p><p>除了檔案的內容之外，檔案的metadata，比如創建時間、權限、大小等等，也需要存放在另一個地方，專門存這些metadata的地方就叫做inode。</p><p>一個檔案的inode可以透過stat來查詢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟時，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小。這樣，即使檔案很小，硬碟裡的檔案數量還是有限制的。</p><h3 id="作業系統是如何讀取檔案資料？"><a href="#作業系統是如何讀取檔案資料？" class="headerlink" title="作業系統是如何讀取檔案資料？"></a>作業系統是如何讀取檔案資料？</h3><p>首先，作業系統不是透過檔案名字來讀取資料，檔案名字只是讓使用者方便識別。作業系統是透過inode ID來找到資料的。每個inode都有一個號碼，根據使用者點開的檔案找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼。<br>第二，根據inode號碼找到inode的data。<br>最後，根據inode的data，找到檔案裡的數據存在哪個block。</p><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><p>File system最大的優點就是對人類友好，有目錄結構、容易記住的名字等等，方便UI呈現，除此之外還有以下優點：</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的使用者直接分享檔案，而且有權限控制。</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他。</li><li><strong>成本低</strong>:<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理。</li><li><strong>難以遷移</strong>:<br>如果想把文件搬遷到另一個作業系統會有點困難，如果file storage的格式不同或inode的演算法不同就更糟了。</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求。</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul><li>File storage讓我們能夠輕鬆操作資料</li><li>作業系統透過File system在Block storage上加一層，方便使用</li><li>File system有目錄結構、容易記住的名字，方便共享、安全、成本低</li><li>但也有資料讀寫慢、難以遷移、權限控制不夠細緻等缺點</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 檔案系統 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block-storage/"/>
      <url>/2021/09/05/block-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="區塊儲存-Block-Storage"><a href="#區塊儲存-Block-Storage" class="headerlink" title="區塊儲存 (Block Storage)"></a>區塊儲存 (Block Storage)</h3><p>區塊儲存 (Block Storage) 是最基本的儲存系統，就像電腦的倉庫，用來存放資料。資料在電腦裡是以 1 和 0 的形式儲存在某個「介質」上，例如：</p><ul><li>機械式硬碟 (HDD) 利用磁性來儲存資料</li><li>固態硬碟 (SSD) 利用電子來儲存資料</li><li>光碟則是用光來儲存資料</li></ul><p>區塊儲存就像是我們能看到的一塊塊硬碟和儲存裝置。我們把儲存裝置連接電腦後，就能透過區塊儲存的 API 對裡面的資料進行增刪改查。</p><span id="more"></span><p>接下來，我們有了作業系統，它方便我們把資料存進去 Block Storage 裝置，可以說，作業系統是上層應用與 Block Storage 裝置溝通的橋樑。那麼，作業系統是如何與硬碟打交道呢？首先，作業系統利用 LUN ID 識別硬碟。LUN 是一個或一組或半個硬碟的邏輯代號。為什麼有半個呢？例如我們的 Windows 有一個硬碟，把它分成 C 槽和 D 槽，那麼它們就是各半個。LUN 不是獨佔式的，也就是說多台主機能共享一個儲存設備，不過一般不會這麼用，因為 Block Storage 的資料隔離沒有做得這麼好，若是同時寫入資料容易被混淆。</p><h3 id="Block-區塊"><a href="#Block-區塊" class="headerlink" title="Block (區塊)"></a>Block (區塊)</h3><p>為什麼叫做 Block 呢？從作業系統的角度，資料的讀取和寫入都是以 Block 為最小單位。一個 Block 是一段固定長度的 bytes，常見為 4096 bytes。這樣的設定用意是提升資料讀寫的速度。如果一個個 byte 寫，一來一往速度非常慢。我們也不需要連續的儲存這些 Block，上層的作業系統會利用 Linked-List 資料結構把碎片化的 Block 記錄下來，把整段資料拼湊出來。一個 Block 對應一個或多個硬體的扇區 (Sector)，常見的一個 Sector 大小為 512 bytes。所以 Block 是給作業系統看的邏輯地址，Sector 是 Block Storage 上的實體地址。Block 大小可以透過作業系統設定，查詢指令為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; stat /boot/ |grep &quot;IO Block&quot;</span></span><br><span class="line">  Size: <span class="number">4096</span>      Blocks: <span class="number">8</span>          IO Block: <span class="number">4096</span>   directory</span><br></pre></td></tr></table></figure><h3 id="扇區-Sector"><a href="#扇區-Sector" class="headerlink" title="扇區 (Sector)"></a>扇區 (Sector)</h3><p>Sector 是 Block Storage 上的實體地址，也是把多個 bytes 分組成一個 Sector。我們以機械式硬碟 (HDD) 為例，HDD 有個針頭會去掃描磁碟，掃描的部分就是一個個扇區，如下圖所示：<br><img src="/images/sector.png"><br>HDD 就是用類似光碟的圓盤一個個堆疊出來的。剛剛提到的 “扇區” 就是上圖的 Sector，代表同個半徑下一小塊長度。</p><p>最後總結一下 Block Storage 的優缺點：</p><h4 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h4><p>Block Storage 最大的優點就是它使得計算與儲存分離，我們能輕易地透過 LUN ID 外接一個硬碟或硬碟組。</p><ul><li><strong>高性能</strong>:<br>IOPS (Inputs Outputs per Seconds) 高，延遲低，適合用作公司的 Database Server 或數據中心。</li><li><strong>易於修改</strong>:<br>如果想改變 Block 裡的一小部分資料，直接改那個 Block 就可以。如果是檔案系統或 Object System，需要整個檔案或 Object 都改。</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個 LUN ID 就可以接上系統了，適合用在 SAN (儲存區域網路) 裡。</li></ul><h4 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h4><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但會造成性能下降。</li><li><strong>Metadata</strong>:<br>Block Storage 沒有什麼 Metadata，File System 有檔案路徑、名字、大小等等快速定位資料，Block Storage 只有地址起始位置 (LBA)、長度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
