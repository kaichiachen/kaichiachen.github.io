<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Python進階]Python的iterator和generator</title>
      <link href="/2021/09/25/iterator-generator-python/"/>
      <url>/2021/09/25/iterator-generator-python/</url>
      
        <content type="html"><![CDATA[<p>剛寫Python的時候，你可能對於Python的語法<code>for i in [2, 4, 6, 8, 10]</code>嘆為觀止，理解起來也非常直觀，比起C++或java的語法，簡潔了不少<br>可是你有想過，Python在處理for in的時候，發生了什麼嗎？什麼樣的object可以被放進for in loop呢？</p><span id="more"></span><h3 id="container和iterator">Container和Iterator</h3><p>Container非常好理解，Python一切皆為object，object的集合就是Container，例如list, set, tuple等等的<br>所有的Container都是iterable(可迭代的)，可迭代是什麼意思呢？你可以想像一下你去水果攤買蘋果，老闆不跟你說庫存，然後你每次都只需要跟老闆說，我要一個蘋果，直到老闆跟你說蘋果沒了<br>Container透過<code>iter()</code>返回一個Iterator，然後我們可以透過<code>next()</code>就能像和老闆要蘋果那樣，一個個要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_arr = <span class="built_in">iter</span>(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>當老闆說沒有蘋果的時候，就會throw exception出來</p><h3 id="generator">Generator</h3><p>Generator可以理解為懶人版的Container<br>生成一個Container很簡單，<code>[i for i in range(100000000)]</code>就可以生成一億個int的array，每個元素都會保存在記憶體當中，當然，轉成Iterator後也是，只是他們取用元素的方式不同而已<br>而Generator的使用方法和Iterator比較類似，都是需要後再取，只是Iterator會預先把所有元素放進記憶體，而Generator會等有需要拿的時候才會把該元素載入記憶體</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span>(<span class="params">hint</span>):</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_iterator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing iterator&#x27;</span>)</span><br><span class="line">    list_1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after iterator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_1))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_generator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing generator&#x27;</span>)</span><br><span class="line">    list_2 = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after generator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_2))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_iterator()</span><br><span class="line">test_generator()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initing iterator memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after iterator initiated memory used: 2015.828125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 3869.05078125 MB</span></span><br><span class="line"><span class="comment"># initing generator memory used: 9.5703125 MB</span></span><br><span class="line"><span class="comment"># after generator initiated memory used: 9.58203125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 9.58203125 MB</span></span><br></pre></td></tr></table></figure><p>我們可以看到記憶體驚人的差異，在Iterator和Generator初始記憶體都差不多的情況下，Iterator需要2GB的記憶體，而Generator只需要9.5MB，如果遇到不需要同時在記憶體保存這麼多東西的場景，例如元素總和，可以使用Generator<br>由上面的範例可以看到，Generator的初始化寫法是<code>(i for i in range(100000000))</code><br>那麼Generator還能怎麼玩呢？例如我們想要驗證一個數學公式{(1+2+3+…+n)^2 = 1^3 + 2^3 + 3^3 + … + n^3}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">k</span>):</span></span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">yield</span> i ** k</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen_1 = generator(<span class="number">1</span>)</span><br><span class="line">gen_3 = generator(<span class="number">3</span>)</span><br><span class="line">sum_1 = <span class="number">0</span></span><br><span class="line">sum_3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   sum_1 += <span class="built_in">next</span>(gen_1)</span><br><span class="line">   sum_2 = sum_1 ** <span class="number">2</span></span><br><span class="line">   sum_3 += <span class="built_in">next</span>(gen_3)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;sum_2: %s, sum_3: %s&quot;</span> % (sum_2, sum_3))</span><br><span class="line">   time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>yield是Generator獨有的，你可以理解為，在next之前，他就會被卡在這裡，call next之後yield就會return值出來<br>你看，有了Generator，我就能一直無限的驗證下去，不用擔心記憶體爆炸，Iterator是一個有限集合，Generator是一個無限集合！</p><p>除此之外，Generator也能讓程式碼更加簡潔有力！讓我們看下面的例子，輸入一個array和一個數字，找出該數字在array的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Iterator</span><br><span class="line">def find_iter(arr, val):</span><br><span class="line">   res = []</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         res.append(idx)</span><br><span class="line">   return res</span><br><span class="line">   </span><br><span class="line"># Generator</span><br><span class="line">def find_gen(arr, val):</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         yield idx</span><br><span class="line"></span><br><span class="line">arr = [1, 5, 2, 9, 1, 7, 2, 1, 2]</span><br><span class="line">val = 2</span><br><span class="line">print(find_iter(arr, val))</span><br><span class="line">print(list(find_gen(arr, val)))</span><br><span class="line"># Output</span><br><span class="line"># [2, 6, 8]</span><br><span class="line"># [2, 6, 8]</span><br></pre></td></tr></table></figure><p>顯然的，Generator清爽多了</p><h3 id="總結">總結</h3><p>本篇講了Container, Iterator和Generator</p><ul><li>Container是Iterable的，代表將Container放進for in裡我們可以一個個迭代</li><li>Generator是一個特殊的Iterator，使用Generator可以寫出更清新，更省資源的程式碼</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]IP&amp;MAC地址 - 網路通訊世界的大門</title>
      <link href="/2021/09/23/ipbasic-network/"/>
      <url>/2021/09/23/ipbasic-network/</url>
      
        <content type="html"><![CDATA[<h3 id="每一個網卡都有一個ip和mac，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼">每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼</h3><p>警察撿到了你的身分證，看了上面的戶籍地址，想把身分證歸還給你，他是怎麼找到你的呢？<br>透過了地址(IP)，找到了你的家，按下你家的門鈴後，大喊了身分證號碼(MAC)，歸還給了對的人</p><span id="more"></span><h3 id="ip地址">IP地址</h3><p>那麼，在你的電腦裡，我們要怎麼查我們電腦裡的IP門牌號碼呢？</p><p>在Linux，有兩個指令可以查詢，分別為<code>ifconfig</code>和<code>ip addr</code><br><strong>ifconfig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6251  bytes 9073424 (8.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3111  bytes 170522 (166.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ip addr</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>ifconfig來自於Linux的net-tools而ip addr來自於iproute2．net-tools起源於BSD，自2001年起，Linux社群已經對其停止維護，而iproute2旨在取代net-tools，並提供了一些新功能。一些Linux發行版已經停止支援net-tools，只支援iproute2。 net-tools通過procfs(/proc)和ioctl system call去訪問和改變kernel網路設定，而iproute2則通過netlink socket interface與kernel通訊。 net-tools中工具的名字比較雜亂，而iproute2則相對整齊和直觀，基本是ip command加後面的sub-command。不過這麼多年過去了，net-tool依然還在被廣泛使用，最好還是兩套指令都掌握吧。</p></blockquote><p>IP地址是門牌號碼，所以不能大家都一樣，不然就會起衝突．舉個例子，<code>132.128.200.32</code>是一個IP地址，由三個&quot;.&quot;分成四個部分，每個部分有8個bit，四個部分加起來總共有32個bit，也就是最多只能產生{2**32}個門牌號碼．因為不夠用，所以有了IPv6，也就是上面的輸出結果<code>fe80::ca61:d665:1750:e806</code>，總共有128位，看起來應該是夠了．</p><p>由於現有的32bit ip地址不這麼夠用，其中ip又有分私人ip(自己內網的ip)和公共ip(任何地方都能連的ip，例如Google)，其中，下面的ip地址範圍就是私人地址</p><table><thead><tr><th>地址範圍</th><th>數量</th></tr></thead><tbody><tr><td>10.0.0.0–10.255.255.255</td><td>16,777,216</td></tr><tr><td>172.16.0.0–172.31.255.255</td><td>1,048,576</td></tr><tr><td>192.168.0.0–192.168.255.255</td><td>65,536</td></tr><tr><td>所以說，下次你跑<code>ip addr</code>看到你的ip是<code>192.168.2.132</code>不用懷疑，你在私人ip裡，外面的電腦無法和你的電腦連結</td><td></td></tr></tbody></table><h3 id="mac地址">MAC地址</h3><p>MAC地址是一個容易和IP地址誤解的地址，因為MAC地址號稱全世界唯一，那既然唯一了，為何我們還要IP地址呢？其實MAC地址與其說是個地址，不如說他是個網路ID<br>舉個例子，我們想找的一個人，他的身分證是A123456789，然後他的身分證上面寫的地址是，<code>台北市文山區興隆路五段9弄18號4樓</code>，後面的地址就是像是電腦的IP，而身分證就是這個人．<br>或許你也有聽過，MAC地址其實是可以改的，只要不要在同個內網下有多個MAC地址就好，就像是同個家庭，不要有重複的&quot;身分證&quot;<br>MAC地址從上面的<code>ip addr</code>指令我們可以看到是<code>02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</code></p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> IP </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview-network/"/>
      <url>/2021/09/20/overview-network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成&quot;協議&quot;，巴別塔的計劃就失敗了。<br>但是千年以後，有一種叫&quot;程序猿&quot;的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議(TCP/IP stack)進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的</p><h4 id="為何我們常見的tcp/ip要分層呢？">為何我們常見的TCP/IP要分層呢？</h4><p>因為任何複雜的程式或應用都要分，這是大型程式設計的要求。例如，複雜的電商還會分資料庫層、Cache層、Compose 層和Controller 層等等，每一層專注做本層的事情。</p><p>TCP/IP是一個公認的網路通訊協議，是OSI七層的簡化，五層分別為物理層、鏈結層、網路層、傳輸層和應用層，下面用簡短的話分別解釋這五層是做什麼的</p><p><strong>物理層(Physical):</strong> 處理網路線、無線傳輸設備，例如光纖<br><strong>鏈接層(Link):</strong> 乙太網，由於資料經由網路線傳輸過程中難免會錯誤，這一層具有資料糾錯的功能，例如漢明碼<br><strong>網路層(Internet):</strong> 保證路由，如何把數據從MAC傳輸到另一個MAC<br><strong>傳輸層(Transport):</strong> TCP、UDP，其中TCP保證邏輯上end-to-end的可靠性<br><strong>應用層(Application):</strong> 用於與網路相關應用交互的地方，例如http, ssh等等</p><p>那麼層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線，Header放在每一層數據包的最前面，如下圖所示<br><img src="/images/tcpiplayer.png" alt=""></p><p>所以網路封包的傳輸過程是從應用層開始，加header，一直加到下面傳輸層，然後路由器會根據header路由封包到目的地，到了目的地電腦再根據header進行往上逐層解析，再回到應用層</p><p>網路應用開發人員主要了解第三到第五層就好，之後也會偏重解析這三層並基於這三層建構應用。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的@Decoractor</title>
      <link href="/2021/09/18/decorector-python/"/>
      <url>/2021/09/18/decorector-python/</url>
      
        <content type="html"><![CDATA[<p>今天這篇文章，我們來學習一下Python的Decorator裝飾器</p><p>Decorator在Python是一個非常經典的feature，在工程中也應用廣泛，例如Log, Cache, Threading等等</p><span id="more"></span><h3 id="function-decorator">Function Decorator</h3><p>其實Decorator是對function的封裝，可以理解為對這個function的前後做一點&quot;裝飾&quot;，我們會從python<code>lambda</code>切入講解，引入Decorator的基本概念和用法，最後透過一個實際的例子加深理解</p><p>前面說過，Python的一切皆為Object，連function也不例外，我們看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">helloworld = func</span><br><span class="line">helloworld()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>從上面的例子，我們把func作為一個variable賦予helloworld，然後call helloworld，相當於call了func<br>所以我們也可以把function作為一個參數傳到另外一個function裡面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    func()</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>有了這些基礎概念後，我們接下來可以深入挖掘Decorator<br>按照Decorator的思路，就是對某一個function做前後包裝，例如我們想要計算每個傳進來的function執行花了多少時間，可以這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.220008850097656e-05 secs</span></span><br></pre></td></tr></table></figure><p>更通用一點，我們可以把printer封裝成更generic一點的function直接return</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">printer = decorator_benchmark(print_hello_world)</span><br><span class="line">printer()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 5.2928924560546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們把原本的<code>print_hello_world</code>封裝成<code>decorator_benchmark</code>的內置函數，這樣在外面call就會非常的簡潔，不過這樣還是有點浪費唇舌，如果我們總是需要對<code>print_hello_world</code>測量性能，call之前都需要對他封裝一次，那有沒有一個更簡潔的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.38690185546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們在<code>print_hello_world</code>上面加了<code>@decorator_benchmark</code>，其中<code>@</code>，是Python裡的語法糖，我們可以對一些常見的功能例如benchmark、Log等等寫成一個Decorator function，然後再對其他函數進行&quot;裝飾&quot;，這樣就大大提高了程式的重複利用和可讀性</p><p>當然，Decorator具有強大的靈活性，我們也可以對其傳入參數，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>不過這樣寫有個副作用是，我們裝飾後的<code>print_hello_world</code>的metadata就被改變了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure><p>他告訴了我們function不再是原來的<code>print_hello_world</code>，而是被<code>wrapper</code>取代了<br>不過俗話說的好，見招拆招，為了解決這個問題，我們可以使用Python已有的Decorator <code>@functools.wrap</code>，他會保留原本函數的metadata(也就是將原本函數的metadata copy到Decorator裡面)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function print_hello_world in module __main__:</span></span><br><span class="line"><span class="comment"># print_hello_world()</span></span><br></pre></td></tr></table></figure><h4 id="class-decorator">Class Decorator</h4><p>最後來說說Class Decorator，前面提到的Decorator是以function為形式的，其實class也可以做為Decorator，這樣可以持久化存一些資料．Class Decorator藉由函數<code>__call__</code>，每當call一次被裝飾的function時，就會call一次<code>__call__</code>，我們以&quot;計算函數被call的次數&quot;作為例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">      self.num_call = <span class="number">0</span></span><br><span class="line">      self.func = func</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">      self.num_call += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Num of call is %s&quot;</span> % self.num_call)</span><br><span class="line">      <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Num of call is 1</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Num of call is 2</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><h3 id="總結">總結</h3><p>所謂的Decorator，就是透過去&quot;裝飾&quot;函數，增加或改變已有函數的功能，使得原有函數不需要修改，有如下優點</p><ul><li>封裝原有程式碼</li><li>程式碼簡潔</li><li>易讀</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python Object的比較和複製</title>
      <link href="/2021/09/16/object-op-python/"/>
      <url>/2021/09/16/object-op-python/</url>
      
        <content type="html"><![CDATA[<p>Python的任何variable都是C++的Object<br>所以我們在對Python的variable做任何操作時，其實就是在對Object做，例如我們做variable比較</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><span id="more"></span><p>variable複製</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = <span class="built_in">list</span>(a)</span><br></pre></td></tr></table></figure><p>可是如果只是&quot;賦予&quot;新的variable，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = a</span><br><span class="line">&gt;&gt; b.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt; a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>b會影響a，因為他們共享同個記憶體上的address<br>不過透過上面的範例，你可能還是不太清楚</p><ul><li><code>a==b</code>是比較兩個object address相等呢？還是value相等呢?</li><li><code>b = list(a)</code>是shallow copy還是deep copy呢？</li></ul><h4 id="比較語法">比較語法</h4><p>在Python中你應該遇過下面兩個語法，你能分辨出有什麼不同嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>==</code>表示兩個varaibles的&quot;值&quot;是否相等，<code>is</code>表示兩個varaibles是否為同一個Object，是否address也相同<br>在Python中，我們可以透過<code>id(variable)</code>去拿variable的唯一ID，所以判斷<code>a is b</code>如同<code>id(a) == id(b)</code><br>我們再看一個百思不得其解的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">10</span></span><br><span class="line">&gt;&gt; b = <span class="number">10</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>咦？a和b是兩個不同的變數呀，為何他們的id會相同呢？<br>我們說過，Python的任何variable都是C++的Object，int也不例外，然而為了提升性能，C++把常用的數字-5到256是先定義好，作為cache使用，當Python需要時，直接從這個pool拿去引用，於是乎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">257</span></span><br><span class="line">&gt;&gt; b = <span class="number">257</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>有興趣的讀者可以試試<br>再來，我們來探討<code>==</code>和<code>is</code>性能的部分<br>通常，<code>is</code>會比<code>==</code>快很多，因為<code>is</code>不會被overload，這樣Python就不需要去尋找<code>__eq__</code>，<code>a == b</code>實際上做的事情等同於<code>a.__eq__(b)</code></p><h4 id="copy語法">copy語法</h4><p>所謂的copy，指的是重新分配一塊記憶體，創建一個新的Object，所以他們的id肯定是不同的，而copy又分shallow copy和deep copy<br>所謂的shallow copy，新的Object裡面的元素是原本Object裡面元素的引用，所以如果Object裡面的Object被改了，新舊Object都會被連動，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>可以看到variable b append 4之後，a裡面的list也被影響了<br>而deep copy，相對於shadow copy來說，會遞迴的方式往裡面一直copy，所以新的Object和舊的Object沒有任何關聯<br>Python中透過copy.deepcopy(object)實現deep copy，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>我們可以看到a不受任何影響即使b append了4<br>最後我們再來探討mutable(可變) Object和unmutable(不可變) object，看一下下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>我們可以看到，a+=1後竟然沒有影響b，不是說Python一切variable皆是object嗎？<br>這是因為在Python中int, float, string, tuple等等屬於unmutable object，不能改object裡面的值，我們可以看到a+=1之後，a的id變了，代表他被重新賦予新的object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809328</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809168</span></span><br></pre></td></tr></table></figure><p>而dict, array, set等等，屬於mutable object，在assign或是當作參數傳進去function的時候，會影響該variable</p><h3 id="總結">總結</h3><p>這篇文章講了Python的variable怎麼做比較和複製</p><ul><li>Python的一切皆為Object，所以比較和複製的思維可以參考C++</li><li>Object間的比較分成address和value的比較，分別為<code>is</code>和<code>==</code></li><li>Object間的複製分成shallow和deep copy，一個只複製了第一層的value，另一個會遞迴複製</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object-storage/"/>
      <url>/2021/09/13/object-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="object-storage(物件儲存)">Object storage(物件儲存)</h3><p>Object Storage - 雲端系統上最流行的儲存方式</p><span id="more"></span><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合</p><p>Metadata的部分，他不像File system是固定的inode資料結構，Object storage可以隨意自己定義metadata的資料結構，可以非常詳細以幫助快速檢索目標object</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務</p><p>從high level講，也就是使用方式講，Object storage是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要“方便”分散且&quot;容易&quot;伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個“資料夾”加大了空間</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的”安全性“，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如Raid5這種空間使用率只要150%，但是保護力也有1</p><p><strong>優點</strong></p><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</li><li><strong>成本低</strong>：<br>公有雲端上的Object storage都特別便宜，例如Amazon S3</li><li><strong>API 簡單</strong>:<br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能修改</strong>:<br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</li><li><strong>無法和database整合</strong>:<br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</li><li><strong>無法與一般作業系統整合</strong>:<br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file-storage/"/>
      <url>/2021/09/12/file-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="file-storage(檔案系統)">File storage(檔案系統)</h3><p>有了File storage，我們用滑鼠鍵盤就能操控資料</p><span id="more"></span><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我們怎麼知道我的資料存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好</p><p>任何架構的難題只需要加一層就可以解決，如果不行，那就兩層，為了讓人能夠輕鬆的操作儲存資料，我們在Block storage上面加了一層File system</p><p>我們平常用的Windows就File system，這大家應該很熟悉，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，文件的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的就叫做inode</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><p>那作業系統是如何讀取檔案資料呢？</p><p>首先，不是透過檔案名字，文件名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，根據使用者點開的文件找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼</p><p>第二，根據inode號碼找到inode的data</p><p>最後，根據indoe的data，找到檔案裡的數據存在哪個block</p><p><strong>優點</strong><br>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他</li><li><strong>成本低</strong>：<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</li></ul><p><strong>缺點</strong></p><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</li><li><strong>難以遷移</strong>:<br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 檔案系統 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block-storage/"/>
      <url>/2021/09/05/block-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="block-storage(塊儲存)">Block storage(塊儲存)</h3><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p><span id="more"></span><p>我們都知道資料是以1和0儲存在某個&quot;介質&quot;上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，而Block storage簡單來說就是我們能看到的一塊塊的硬碟</p><p>接下來，我們有了作業系統，才能把資料存進去硬碟了，那麼回答一個問題，作業系統是如何與硬碟打交道呢？首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也方便了多台主機共享一個儲存設備</p><p>為什麼叫做block呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，大約是512，這樣的設定能提升資料讀寫的速度，一個block對應一個或多個硬體的扇區(sector)，所以block是邏輯地址，sector是實體地址</p><p>我們拿機械式硬碟HDD舉例，如下圖所示<br><img src="/images/sector.png" alt=""><br>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的&quot;扇區&quot;就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點<br><strong>優點</strong><br>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><strong>高性能</strong>:<br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作database server</li><li><strong>易於修改</strong>:<br>如果想改變文件裡的一個小部分資料，直接改那個block就可以，如果是文件系統或object system，需要整個file或object都改</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個LUN ID就可以接上系統了，較沒有性能瓶頸</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</li><li><strong>Metadata</strong>:<br>沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2013/11/06/hello-world/"/>
      <url>/2013/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a new post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to remote sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> aCategory </category>
          
          <category> anotherCategory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aTag </tag>
            
            <tag> anotherTag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
