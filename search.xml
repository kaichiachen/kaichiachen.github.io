<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Python進階]Python的記憶體垃圾回收機制</title>
      <link href="/2021/10/14/garbage-collection-python/"/>
      <url>/2021/10/14/garbage-collection-python/</url>
      
        <content type="html"><![CDATA[<p>我們知道，Python應用在執行的時候，需要從記憶體規劃出一段空間，用於存放臨時產生的變數，計算完後再放進永久儲存介質，如果所需要存放的臨時變數過大，則會造成OOM(Out of Memory)記憶體錯誤，程式可能會被作業系統終止<br>對於伺服器應用來說，為了設計永遠不中斷的系統，記憶體管理會變得非常重要，不然容易引發記憶體洩漏(Memory Leak)</p><p>什麼是記憶體洩漏呢？我們的應用一般都是執行過程中不停的對作業系統申請記憶體、釋放記憶體，這裡的洩漏不是指被攻擊，而是程式沒有釋放已不再使用的記憶體，造成記憶體的浪費</p><p>那麼Python是怎麼處理的呢？需要工程師們有意識的申請變數記憶體，用完再手動清除嗎？答案是: NO，Python會幫你自動找出不再使用的變數，然後釋放歸還給作業系統</p><span id="more"></span><h3 id="Reference-Count-引用計數"><a href="#Reference-Count-引用計數" class="headerlink" title="Reference Count(引用計數)"></a>Reference Count(引用計數)</h3><p>Python中一切皆為Object，每個Object都有多個pointer指向它<br>那麼怎麼知道這個Object之後永遠都不會被使用呢？Python使用的是Reference Count(pointer指向數量)，當它為0的時候，代表這個Object不可達，不會再被使用了，需要被回收<br>我們來舉個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span>(<span class="params">hint</span>):</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.30859375 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.09765625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 11.61328125 MB</span></span><br></pre></td></tr></table></figure><p><code>show_memory_info</code>裡面用到了python裡面的library <code>psutil</code>，能夠取得process所消耗的memory bytes，程式剛執行的時候，佔用了7MB左右的記憶體，在我們宣告了長度為一千萬的list之後，記憶體飆漲到了404MB，然而在離開main函數後，變數a不會被用到了，所以reference count=0，就被Python給回收了，所以最後的記憶體消耗又降回來，變成11MB</p><p>再給大家一個例子，如果我們把變數a改成global呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a= []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 404.0859375 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 404.0859375 MB</span></span><br></pre></td></tr></table></figure><p>即使程式跑到最後一刻，記憶體使用量還是高的誇張，所以Python的記憶體垃圾回收機制並不是一勞永逸的做法，在程式設計上也要謹慎<br>最後，面試官問你，Reference count=0是Python執行垃圾回收的必備條件嗎？還有沒有其他可能性會導致垃圾回收？</p><h3 id="循環引用"><a href="#循環引用" class="headerlink" title="循環引用"></a>循環引用</h3><p>還有一種情況是，變數往後都不會再被用到了，但是他的Reference count不是0，會是什麼樣的情況呢？就是循環引用，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.2890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.67578125 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 790.67578125 MB</span></span><br></pre></td></tr></table></figure><p>承接上個範例，變數a和b都是個長度為一千萬的list，然後互相append，我們發現程式運行結束時，記憶體還是沒有被回收<br>這還只是比較簡單明顯的狀況，很多循環引用是很難被發現的，那麼我們應該要怎麼做呢？<br>遇到這種情況，我們可以手動的call垃圾回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initial memory used: 7.37890625 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 790.03515625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 12.12890625 MB</span></span><br></pre></td></tr></table></figure><p>針對循環引用的垃圾回收，Python使用標記清除(mark-sweep)和分代收集(generational)，這裡來簡單介紹一下</p><h4 id="標記清除演算法"><a href="#標記清除演算法" class="headerlink" title="標記清除演算法"></a>標記清除演算法</h4><p>我們先用圖論來表達不可達概念，對於一個有向圖，從任意一個節點出發進行遍歷，遍歷結束後發現有節點沒有被標記，則為不可達，不可達節點我們就能視為循環引用，需要對其回收<br>然而每次都要遍歷全圖，對Python來說是一個巨大了浪費，所以在Python裡面維護了一個雙向linked-list，並且只維護Container類的變數(只有Container類的變數才會循環引用)</p><h4 id="分代收集演算法"><a href="#分代收集演算法" class="headerlink" title="分代收集演算法"></a>分代收集演算法</h4><p>Python將所有變數分為三代，剛創立的變數為第一代，垃圾回收過一次還存在的變數會從上一代移到下一代，例如第一代到第二代，當垃圾回收中，新增的變數減去刪去的變數超過某個閥值，就對這一代執行垃圾回收</p><h3 id="記憶體洩漏debug"><a href="#記憶體洩漏debug" class="headerlink" title="記憶體洩漏debug"></a>記憶體洩漏debug</h3><p>即使Python有了強大的記憶體管理機制，但是難免還是有漏網之魚，那有沒有什麼好的Debug手段呢？<br>Python有個Library <code>objgraph</code>，使用方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"></span><br><span class="line">objgraph.show_refs([a])</span><br><span class="line">objgraph.show_backrefs([a])</span><br></pre></td></tr></table></figure><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>今天我們深入了瞭解了Python垃圾回收機制，主要有下面幾點</p><ul><li>垃圾回收在Python用於釋放不會再用到的記憶體給作業系統</li><li>Reference count是最常見的方式，不過不是回收的唯一條件</li><li>Python的垃圾回收還包含了標記清除和分代收集演算法，主要針對防循環引用</li><li>Debug記憶體洩漏方面，objgraph是個好工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的GIL</title>
      <link href="/2021/10/10/gil-python/"/>
      <url>/2021/10/10/gil-python/</url>
      
        <content type="html"><![CDATA[<h3 id="GIL（Global-Interpreter-Lock"><a href="#GIL（Global-Interpreter-Lock" class="headerlink" title="GIL（Global Interpreter Lock)"></a>GIL（Global Interpreter Lock)</h3><p>Python的multi thread讓人不明所以，為何我的電腦明明有四個CPU，用multi thread性能卻沒有增長呢？我們先看一個例子</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountDown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Single Thread</span></span><br><span class="line">start = time.time()</span><br><span class="line">CountDown(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two Threads</span></span><br><span class="line">start = time.time()</span><br><span class="line">t1 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t2 = Thread(target=CountDown, args=[n // <span class="number">2</span>])</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s&#x27;</span> % (time.time() - start))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Time consumed: 4.894810676574707</span></span><br><span class="line"><span class="comment"># Time consumed: 4.441636085510254</span></span><br></pre></td></tr></table></figure><p><code>CountDown</code>是個CPU heavy的函數，但是神奇的事情發生了，明明用了兩個Threads，耗時卻差不多，都是4秒左右<br>這是怎麼回事？難道我買的電腦只有一顆CPU有在工作？不對呀，如果換成C++寫，速度提升馬上有感<br>看起來不是電腦的問題，而是Python的multi thread失效了，沒有執行真正的併行運算<br>然而Python的Thread是實實在在的Thread，在Linux，他封裝了Pthread(POSIX Thread)，在Windows，是Windows Thread，由於只是做封裝，所以Python的Thread完全受作業系統管理，例如協調何時執行、資源管理等等</p><p>Python之所以用了multi thread起不到性能提升的作用，正是因為GIL，在整個Python的Process，只允許同時跑一個Thread，其他的會被Lock，所以本質來說，Python的Thread只是”輪流”執行</p><h3 id="為什麼有GIL"><a href="#為什麼有GIL" class="headerlink" title="為什麼有GIL?"></a>為什麼有GIL?</h3><p>我們知道Python是基於C，也就是CPython實現的，之所以有GIL就是和CPython有關<br>CPython使用Reference Count管理記憶體，用來記錄多少pointer指向這塊記憶體，當Reference Count=0時，就會釋放記憶體，看個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>3的由來是a, b和sys.getrefcount傳進a所引發的reference，所以總共是3<br>所以說，如果兩個Python的Threads同時引用了a，同時reference count += 1，觸發了race condition，最終reference count只會加1而已<br>由於有這樣的風險，Python就乾脆的設定了一個GIL，但也不能說Python是天然不用擔心race condition的語言，畢竟Python的一行程式，可能代表著多行的bytescode，例如Python的<code>n+=1</code>，他代表的bytecode是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD_CONST <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">INPLACE_ADD</span><br></pre></td></tr></table></figure><p>若我們在<code>INPLACE_ADD</code>前，GIL被釋放了，而其他Thread跑了<code>LOAD_CONST 1 (1)</code>一樣會造成race condition!<br>我們舉個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>所以說，GIL的目的是<strong>為了方便CPython的編寫者，不用顧慮變數記憶體的分配，而不是為了Python應用的開發者</strong>，所以我們還是需要lock等工具，例如下面這個例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="可以繞過GIL嗎？"><a href="#可以繞過GIL嗎？" class="headerlink" title="可以繞過GIL嗎？"></a>可以繞過GIL嗎？</h3><ul><li>Python的GIL是CPython上的限制，如果要繞過，可以透過JPython(Java實現的Python)等</li><li>把CPU heavy的程式碼放在別的語言實現(C++)，然後提供Python調用的API</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>我們探究了Python GIL的原理，他的目的是為了避免記憶體回收的race condition設計出來的一套機制，雖然使得CPython更容易開發，但是卻沒有真正意義上的multi threads<br>不過我們也不用太過於糾結GIL的影響，對於CPU heavy的程式碼，我們還是可以透過其他語言的實作，讓Python去call，進而利用好CPU性能</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Asyncio的Event loop</title>
      <link href="/2021/10/08/eventloop-python/"/>
      <url>/2021/10/08/eventloop-python/</url>
      
        <content type="html"><![CDATA[<p>之前我們講過了Python的Coroutine，提到了我們用的是asyncio library，不同於Coroutine那一篇，我們這一篇注重於原理的理解</p><p>我們知道，multi threading能夠使得效率及CPU使用率大大提高，那為什麼我們需要Asyncio(Coroutine)呢？</p><ul><li>因為在multi threading下，程式碼容易被作業系統打斷，因此可能會出現race condition</li><li>以及，context switch會造成性能損耗，如果I/O過多，不停的context switch，會損失很多性能</li></ul><p>於是乎有了Asyncio</p><span id="more"></span><h3 id="Asyncio原理"><a href="#Asyncio原理" class="headerlink" title="Asyncio原理"></a>Asyncio原理</h3><p>Asyncio和Python的程式一樣，實際上是single thread的，不過可以不停地切換，只要拿到GIL就可以進行任務，這裡的任務，就是特殊的future object，並且被Event loop所控制<br>我們可以假設任務只有兩個狀態 - 預備狀態和完成狀態，預備狀態指的是任務目前空閒，隨時可以執行，而等待狀態就是任務已經執行，但是被掛著等待某個操作完成，例如I/O<br>於是乎，Event loop有兩個job list，分別對應兩種狀態，並且選取一個預備狀態的任務，執行它，一直到他被交還給Event loop<br>當任務被交還給Event loop時，Event loop會根據其是否完成，把任務放進預備或完成狀態的list</p><ul><li>如果完成，則放進去預備狀態</li><li>如果未完成，則放進去等待狀態</li></ul><p>然後再遍歷等待狀態list，看他們是否完成，如果完成再放進去預備狀態</p><p>然後週而復始，直到所有任務完成，由於Asyncio的任務不會被外部的因素打斷，所以Asyncio裡面的操作不會出現race condition的問題，再讓我們複習一下這段程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>async/await是aysncio的一種寫法，代表這個函數或這行程式碼是non-blocking的，如果這裡很耗時，那們就把控制權交還給Event loop，放進等待狀態list<br>另外，<code>asyncio.run()</code>是Python3.7才有的，在舊版本是這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    loop.run_until_complete(</span><br><span class="line">          asyncio.wait(</span><br><span class="line">             [asyncio.ensure_future(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">main([<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">loop.close()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><h3 id="Asyncio有缺點嗎？"><a href="#Asyncio有缺點嗎？" class="headerlink" title="Asyncio有缺點嗎？"></a>Asyncio有缺點嗎？</h3><p>當然有，我們知道Asyncio的eventloop藉由async/await去把job控制權交還給Event loop，所以相應的第三方library也要做調整才能完美地利用Coroutine提升性能，例如，著名的<code>requests</code>library就沒有支持Asyncio，而相同功能的<code>aiohttp</code>有兼容Asyncio</p><h3 id="multli-processing-multi-threading-or-coroutine"><a href="#multli-processing-multi-threading-or-coroutine" class="headerlink" title="multli-processing? multi-threading? or coroutine?"></a>multli-processing? multi-threading? or coroutine?</h3><p>總結來說</p><ul><li>CPU heavy -&gt; 使用multli-processing</li><li>如果I/O慢或太多 -&gt; 使用Coroutine</li><li>反之，如果I/O快 -&gt; 使用multi-threading</li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這篇文章帶大家過了Asyncio Event loop的原理</p><ul><li>Asyncio是single thread的，但是透過Event loop，併發的執行不同任務，在程式端享有自主控制權</li><li>由於打斷是自己控制的，不會出現race condition的問題，在I/O heavy的情況下，比multi-threading的效率更好，因為不用context switch，且能開啟的任務數量更多</li><li>不過Asyncio的缺點是，需要第三方library的支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> eventloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的並行計算 - Futures</title>
      <link href="/2021/10/05/futures-python/"/>
      <url>/2021/10/05/futures-python/</url>
      
        <content type="html"><![CDATA[<p>無論是哪門程式語言，併發(Concurrent)和並行(Parallel)都是很常用且重要的知識點．例如爬蟲，被廣泛運用在工業界資料收集領域，其用的核心技術，就是併發並行程式<br>正確合理的使用併發並行，無疑會給我們的程式帶來巨大的性能提升，之前我們聊到Python Coroutine，今天我們來聊聊Python的Futures</p><span id="more"></span><p>再稍微複習一下併發(Concurrent)和並行(Parallel)的差別，併發指的是在同一個CPU下，透過上下文切換(Context switch)，讓使用者覺得不同程式段同時執行，並行則是真正意義上的多個CPU同時執行，所以說</p><ul><li>併發 - 通常應用在I/O頻繁或耗時的場景，例如要下載多個檔案，I/O所消耗的時間會比CPU還要多</li><li>並行 - 適合CPU heavy的場景，例如MapReduce的計算，為了加快速度，會需要更多的CPU去完成</li></ul><p>不過需要提到的一點是，如果電腦有四顆CPU，照理說可以同時並行的跑四個Threads，然而在Python卻不能這樣，Python的直譯器天生有race condition的問題，所以同一時刻只能允許一個Thread執行，具體原因後面有機會聊到GIL的時候會提到</p><p>Python的Futures library提供了我們方便建立併發併行的框架，也能夠建立threading pool, process pool等等，我們來看下面簡單的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loading_one</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="comment"># Return value of random.random will be 0 ~ 1</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Job %s is completed.&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">names</span>):</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.<span class="built_in">map</span>(loading_one, names)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    jobnames = [</span><br><span class="line">        <span class="string">&#x27;JobA&#x27;</span>, <span class="string">&#x27;JobB&#x27;</span>, <span class="string">&#x27;JobC&#x27;</span>, <span class="string">&#x27;JobD&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    start_time = time.perf_counter()</span><br><span class="line">    loading(jobnames)</span><br><span class="line">    end_time = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Load &#123;&#125; jobs in &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(jobnames), end_time - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Job JobB is completed.</span></span><br><span class="line"><span class="comment"># Job JobD is completed.</span></span><br><span class="line"><span class="comment"># Job JobA is completed.</span></span><br><span class="line"><span class="comment"># Job JobC is completed.</span></span><br><span class="line"><span class="comment"># Load 4 jobs in 0.706298665 seconds</span></span><br></pre></td></tr></table></figure><p>耗時不到一秒，由於<code>random.random()</code> return介於0和1之間，代表確實是併發執行的<br>這裡我們建立的threading pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>最多可以同時使用五個Threads，而<code>executor.map</code>就像python裡的map一樣，對每個names的元素去call loading_one fucntion<br>另外，雖然我們可以自己設定thread的數量，但是不是越多越好，因為thread的創建、維護、刪除也有一定的性能消耗，設定很大可能會導致速度更慢<br>當然，我們也可以把上述程式碼改成”併行”，併行就是多個CPU一起跑，只要做出下面的變化即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    executor.<span class="built_in">map</span>(loading_one, names)</span><br></pre></td></tr></table></figure><p>函數<code>ProcessPoolExecutor</code>代表創建Process pool，有興趣的讀者可以嘗試，一般會遇到改成<code>ProcessPoolExecutor</code>後，耗時更多了，這是因為並行的方式適合在CPU heavy的情況中</p><p>有沒有發覺Python的Futures library和asyncio非常像？，他們都會將處於等待的job放進去list裡，這些job隨時都可以查詢，當然，他們的結果和異常(<code>job.result()</code>)也能在結束之後拿到</p><p>再介紹一個Futures常用的方法 - <code>done()</code>，表示該job是否已經完成，done()是non-blocking的，代表call了他之後會立即返回，還有一個方法是<code>add_done_callback(func)</code>，當job完成後，會被通知並call callback function</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>首先，我們學習了併發(Concurrent)和並行(Parallel)的差別<br>併發通常用於I/O密集的場景，並行則適合CPU heavy的場景</p><p>隨後，我們展示了Python Futures library的例子，透過Thread Pool和Process Pool展示如何優雅的利用併發和並行執行程式</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> concurrent </tag>
            
            <tag> parallel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[閱讀]與成功有約：高效能人士的七個習慣</title>
      <link href="/2021/10/03/7habits_book/"/>
      <url>/2021/10/03/7habits_book/</url>
      
        <content type="html"><![CDATA[<h3 id="與成功有約：高效能人士的七個習慣"><a href="#與成功有約：高效能人士的七個習慣" class="headerlink" title="與成功有約：高效能人士的七個習慣"></a>與成功有約：高效能人士的七個習慣</h3><p><img src="/images/7habit.jpg"></p><span id="more"></span><p>讀了《高效能人士的七個習慣》，學到了不少．喜歡這一種條列式的框架，一點點的歸類不同的高效能人士的不同習慣．這本書我讀的是英文版，一般來說這種書不會像英文小說一樣使用艱深的詞彙，所以想說透過這個機會可以學到我沒有但高效能人士有的好習慣，同時還能提升英文閱讀力，下面是我讀完後的總結:</p><ol><li>主動 Proactive<ul><li>不受周遭环境影响，只受目前的價值做决策</li><li>不要怪外部環境，多想想改變自己</li></ul></li><li>最終目標導向 Begin with the end in mind<ul><li>想清楚最終的目標，而不要被短暫的小目標打斷</li><li>任何事情都被創造兩次，一次是設計藍圖的時候，一次是真正被創造的時候</li><li>領導是做對的事，管理是把事做對</li><li>人生就是由安全感、指導、智慧、能力，如果你是原則至上的人，容易獲得上述四個</li><li>原則至上的人不受外在和情緒的影響，會計算各個選項的價值，再做決定</li><li>我覺得我現在是一半self-center，一半principle-centre</li><li>在做一个可怕的事情前，先想像成功的樣子</li></ul></li><li>把最重要的事擺第一<ul><li>事情分四個維度，重要且緊急、重要但不緊急、不重要但緊急、不重要也不緊急，很多人永遠都困在重要且緊急的事，並把剩下的時間花在不重要也不緊急的事上</li><li>重要和緊急是不相關的</li><li>要高效，必須先定義好重要的事，也就是重要且緊急和重要但不緊急</li><li>設定一周的pricinple剛剛好，一天則太inflexible</li></ul></li><li>Win/Win<ul><li>只有win/win和lose/lose，沒有win/lose和lose/win</li><li>把no deal作為一個option</li></ul></li><li>尋求被理解前，先理解他人<ul><li>幫人解決問題前，必須先診斷，而不是把自己套用在對方的情境，說自己怎麼解決的</li><li>學會聆聽</li><li>聆聽的技巧 - 重複他說的話，或是換句話說，讓對方覺得你懂他</li></ul></li><li>協同效應<ul><li>1 + 1 &gt; 2</li><li>Value the difference 在賞不同</li><li>換位思考</li><li>透過看見差異和尋找更好的方案，展示創新及解決問題的能力</li></ul></li><li>發展自己的能力<ol><li>平衡的發展四個維度的能力<ol><li>social - 協同能力</li><li>physical - 身體健康</li><li>Mental - 閱讀、寫作、計劃</li><li>spiritual - 冥想、看清價值</li></ol></li><li>是一種重要但不緊急的事</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 閱讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 閱讀 </tag>
            
            <tag> 與成功有約：高效能人士的七個習慣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的coroutine</title>
      <link href="/2021/09/29/coroutine-python/"/>
      <url>/2021/09/29/coroutine-python/</url>
      
        <content type="html"><![CDATA[<p>Coroutine(協程)和我們常聽到的multithread, multiprocess一樣，是一种併發(councurrent)的一種方式，注意的是，併發和併行的不同在於，併發是快速的context switch讓user覺得程式同時執行，而併行是指不同CPU同時執行</p><span id="more"></span><p>隨著互聯網快速發展，我們逐漸遇到了C10k的瓶頸，也就是同時連接到Server的數量到達一萬個，這會造成process上下文切換佔用了大量的資源，即使是Thread也頂不住這麼大的壓力，於是Coroutine登場了</p><p>很多人說，Coroutine是輕量化的Thread，那麼Coroutine和Thread有什麼不同呢？<br>兩者最大的差別是，Thread的搶佔式多工，Coroutine是協同式多工</p><h5 id="搶佔式多工"><a href="#搶佔式多工" class="headerlink" title="搶佔式多工"></a>搶佔式多工</h5><p>程式有各自的優先權，作業系統會根據程式的優先權安排當下哪個程式能擁有CPU資源去執行，另外作業系統有權中斷任何正在執行中的程式。</p><h5 id="協同式多工"><a href="#協同式多工" class="headerlink" title="協同式多工"></a>協同式多工</h5><p>程式會定時放棄已佔有的執行資源讓其它程式執行。由於是由程式自己讓出執行資源，不需要由底層的作業系統來處理，所以 Coroutine 交替時所產生的Context switch負擔比 Thread 小</p><p>接下來，我們給個範例，看一下Python的Coroutine怎麼寫，Python的Coroutine library是<code>asyncio</code>，需要跑在Python3.7以上的環境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> sec <span class="keyword">in</span> secs:</span><br><span class="line">        <span class="keyword">await</span> loading(sec)</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br></pre></td></tr></table></figure><p>async代表這個函數是非同步函數，意思是會順序執行的<br>然後再來説説執行，執行有三種方法</p><ol><li>透過 await來call<br>await的執行效果，和Python平常運行程式的效果一樣，會阻塞在這裡，執行完後再繼續</li><li>透過asyncio.create_task()來創建任務</li><li>透過asyncio.run()來執行，不用去理會Event loop怎麼運行的</li></ol><p>上面的程式碼順序的跑了10秒是正常的，因為async會阻塞，接下來我們要來講Coroutine一個重要的概念-Task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">loading</span>(<span class="params">sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;loading... needs &#123;&#125; secs to load&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sec))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">secs</span>):</span></span><br><span class="line">    tasks = [asyncio.create_task(loading(sec)) <span class="keyword">for</span> sec <span class="keyword">in</span> secs]</span><br><span class="line">    <span class="comment"># await asyncio.gather(*tasks)</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main([<span class="number">5</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># loading... needs 5 secs to load</span></span><br><span class="line"><span class="comment"># loading... needs 3 secs to load</span></span><br><span class="line"><span class="comment"># OK 3</span></span><br><span class="line"><span class="comment"># OK 5</span></span><br></pre></td></tr></table></figure><p>我們可以看到，當Task被create之後就會把上執行，然後我們對每個task加了await，等所有task都執行完後才能繼續下一步，或是可以看我註解掉的那一行<code>await asyncio.gather(*tasks)</code>，也能達到同樣的目的</p><h3 id="Coroutine-runtime"><a href="#Coroutine-runtime" class="headerlink" title="Coroutine runtime"></a>Coroutine runtime</h3><p>接下來我們來解析Coroutine的runtime和背後的邏輯，我們一樣用上面的例子，步驟有點多，我們慢慢來</p><ol><li>asyncio.run(main())，程式进入 main() 函数，同時也開啟了Event loop</li><li>兩個task都被創建，進入Event loop等待被執行，執行到print，輸出loading…</li><li>await 五秒的task, Event loop開始調度worker1</li><li>worker1開始執行，遇到await.sleep，從現在的Task切出，Event loop開始調度worker2</li><li>worker2開始執行，一樣遇到await.sleep，從現在的Task切出</li><li>以上的時間都非常快，由於兩個都在sleep，所以Event loop暫停調度</li><li>3秒鐘後worker2的sleep完成，Event loop將控制權交給三秒task，print出OK 3，Task完成，從Event loop退出</li><li>再兩秒鐘後，同理worker1的sleep完成，print完後，從Event loop退出</li><li>Coroutine全部結束</li></ol><p>接下來我們進階一下，如果想給Coroutine任務限定執行時間，一但超時就取消，該怎麼做呢？以及如果runtime發生錯誤，又該怎麼處理？我們來看看下面的程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker1</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker2</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker3</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    task_1 = asyncio.create_task(worker1())</span><br><span class="line">    task_2 = asyncio.create_task(worker2())</span><br><span class="line">    task_3 = asyncio.create_task(worker3())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    task_3.cancel()</span><br><span class="line"></span><br><span class="line">    res = <span class="keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), CancelledError()]</span></span><br></pre></td></tr></table></figure><p>我們可以看到，worker1正常執行，worker2執行中遇到錯誤，worker3執行太久被我們cancel了<br>到這裡，其實thread能做的coroutine也能做</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本篇講解了Python Coroutine的基本概念和用法，這裡簡單總結一下</p><ul><li>Coroutine和threading的差別主要是Coroutine只能用一個CPU core，以及Coroutine是程式決定什麼時候要切換任務</li><li>Coroutine的寫法更加簡潔清晰，滿足中小級別的併發需求</li><li>寫Coroutine的時候，腦海要有清晰的Event loop概念，知道什麼時候需要暫停、等待I/O，什麼時候可以執行到底</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的iterator和generator</title>
      <link href="/2021/09/25/iterator-generator-python/"/>
      <url>/2021/09/25/iterator-generator-python/</url>
      
        <content type="html"><![CDATA[<p>剛寫Python的時候，你可能對於Python的語法<code>for i in [2, 4, 6, 8, 10]</code>嘆為觀止，理解起來也非常直觀，比起C++或java的語法，簡潔了不少<br>可是你有想過，Python在處理for in的時候，發生了什麼嗎？什麼樣的object可以被放進for in loop呢？</p><span id="more"></span><h3 id="Container和Iterator"><a href="#Container和Iterator" class="headerlink" title="Container和Iterator"></a>Container和Iterator</h3><p>Container非常好理解，Python一切皆為object，object的集合就是Container，例如list, set, tuple等等的<br>所有的Container都是iterable(可迭代的)，可迭代是什麼意思呢？你可以想像一下你去水果攤買蘋果，老闆不跟你說庫存，然後你每次都只需要跟老闆說，我要一個蘋果，直到老闆跟你說蘋果沒了<br>Container透過<code>iter()</code>返回一個Iterator，然後我們可以透過<code>next()</code>就能像和老闆要蘋果那樣，一個個要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_arr = <span class="built_in">iter</span>(arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(iter_arr)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>當老闆說沒有蘋果的時候，就會throw exception出來</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator可以理解為懶人版的Container<br>生成一個Container很簡單，<code>[i for i in range(100000000)]</code>就可以生成一億個int的array，每個元素都會保存在記憶體當中，當然，轉成Iterator後也是，只是他們取用元素的方式不同而已<br>而Generator的使用方法和Iterator比較類似，都是需要後再取，只是Iterator會預先把所有元素放進記憶體，而Generator會等有需要拿的時候才會把該元素載入記憶體</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory_info</span>(<span class="params">hint</span>):</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_iterator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing iterator&#x27;</span>)</span><br><span class="line">    list_1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after iterator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_1))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_generator</span>():</span></span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing generator&#x27;</span>)</span><br><span class="line">    list_2 = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after generator initiated&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_2))</span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_iterator()</span><br><span class="line">test_generator()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># initing iterator memory used: 7.28125 MB</span></span><br><span class="line"><span class="comment"># after iterator initiated memory used: 2015.828125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 3869.05078125 MB</span></span><br><span class="line"><span class="comment"># initing generator memory used: 9.5703125 MB</span></span><br><span class="line"><span class="comment"># after generator initiated memory used: 9.58203125 MB</span></span><br><span class="line"><span class="comment"># 4999999950000000</span></span><br><span class="line"><span class="comment"># after sum called memory used: 9.58203125 MB</span></span><br></pre></td></tr></table></figure><p>我們可以看到記憶體驚人的差異，在Iterator和Generator初始記憶體都差不多的情況下，Iterator需要2GB的記憶體，而Generator只需要9.5MB，如果遇到不需要同時在記憶體保存這麼多東西的場景，例如元素總和，可以使用Generator<br>由上面的範例可以看到，Generator的初始化寫法是<code>(i for i in range(100000000))</code><br>那麼Generator還能怎麼玩呢？例如我們想要驗證一個數學公式{(1+2+3+…+n)^2 = 1^3 + 2^3 + 3^3 + … + n^3}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">k</span>):</span></span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">yield</span> i ** k</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen_1 = generator(<span class="number">1</span>)</span><br><span class="line">gen_3 = generator(<span class="number">3</span>)</span><br><span class="line">sum_1 = <span class="number">0</span></span><br><span class="line">sum_3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   sum_1 += <span class="built_in">next</span>(gen_1)</span><br><span class="line">   sum_2 = sum_1 ** <span class="number">2</span></span><br><span class="line">   sum_3 += <span class="built_in">next</span>(gen_3)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;sum_2: %s, sum_3: %s&quot;</span> % (sum_2, sum_3))</span><br><span class="line">   time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>yield是Generator獨有的，你可以理解為，在next之前，他就會被卡在這裡，call next之後yield就會return值出來<br>你看，有了Generator，我就能一直無限的驗證下去，不用擔心記憶體爆炸，Iterator是一個有限集合，Generator是一個無限集合！</p><p>除此之外，Generator也能讓程式碼更加簡潔有力！讓我們看下面的例子，輸入一個array和一個數字，找出該數字在array的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Iterator</span><br><span class="line">def find_iter(arr, val):</span><br><span class="line">   res = []</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         res.append(idx)</span><br><span class="line">   return res</span><br><span class="line">   </span><br><span class="line"># Generator</span><br><span class="line">def find_gen(arr, val):</span><br><span class="line">   for idx, v in enumerate(arr):</span><br><span class="line">      if v == val:</span><br><span class="line">         yield idx</span><br><span class="line"></span><br><span class="line">arr = [1, 5, 2, 9, 1, 7, 2, 1, 2]</span><br><span class="line">val = 2</span><br><span class="line">print(find_iter(arr, val))</span><br><span class="line">print(list(find_gen(arr, val)))</span><br><span class="line"># Output</span><br><span class="line"># [2, 6, 8]</span><br><span class="line"># [2, 6, 8]</span><br></pre></td></tr></table></figure><p>顯然的，Generator清爽多了</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本篇講了Container, Iterator和Generator</p><ul><li>Container是Iterable的，代表將Container放進for in裡我們可以一個個迭代</li><li>Generator是一個特殊的Iterator，使用Generator可以寫出更清新，更省資源的程式碼</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]IP&amp;MAC地址 - 網路通訊世界的大門</title>
      <link href="/2021/09/23/ipbasic-network/"/>
      <url>/2021/09/23/ipbasic-network/</url>
      
        <content type="html"><![CDATA[<h3 id="每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼"><a href="#每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼" class="headerlink" title="每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼"></a>每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼</h3><p>警察撿到了你的身分證，看了上面的戶籍地址，想把身分證歸還給你，他是怎麼找到你的呢？<br>透過了地址(IP)，找到了你的家，按下你家的門鈴後，大喊了身分證號碼(MAC)，歸還給了對的人</p><span id="more"></span><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>那麼，在你的電腦裡，我們要怎麼查我們電腦裡的IP門牌號碼呢？</p><p>在Linux，有兩個指令可以查詢，分別為<code>ifconfig</code>和<code>ip addr</code><br><strong>ifconfig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6251  bytes 9073424 (8.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3111  bytes 170522 (166.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ip addr</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>ifconfig來自於Linux的net-tools而ip addr來自於iproute2．net-tools起源於BSD，自2001年起，Linux社群已經對其停止維護，而iproute2旨在取代net-tools，並提供了一些新功能。一些Linux發行版已經停止支援net-tools，只支援iproute2。 net-tools通過procfs(/proc)和ioctl system call去訪問和改變kernel網路設定，而iproute2則通過netlink socket interface與kernel通訊。 net-tools中工具的名字比較雜亂，而iproute2則相對整齊和直觀，基本是ip command加後面的sub-command。不過這麼多年過去了，net-tool依然還在被廣泛使用，最好還是兩套指令都掌握吧。</p></blockquote><p>IP地址是門牌號碼，所以不能大家都一樣，不然就會起衝突．舉個例子，<code>132.128.200.32</code>是一個IP地址，由三個”.”分成四個部分，每個部分有8個bit，四個部分加起來總共有32個bit，也就是最多只能產生<code>2**32</code>個門牌號碼．因為不夠用，所以有了IPv6，也就是上面的輸出結果<code>fe80::ca61:d665:1750:e806</code>，總共有128位，看起來應該是夠了．</p><p>由於現有的32bit ip地址不這麼夠用，其中ip又有分私人ip(自己內網的ip)和公共ip(任何地方都能連的ip，例如Google)，其中，下面的ip地址範圍就是私人地址<br>| 地址範圍                    | 數量       |<br>|—————————–|————|<br>| 10.0.0.0–10.255.255.255     | 16,777,216 |<br>| 172.16.0.0–172.31.255.255   | 1,048,576  |<br>| 192.168.0.0–192.168.255.255 | 65,536     |<br>所以說，下次你跑<code>ip addr</code>看到你的ip是<code>192.168.2.132</code>不用懷疑，你在私人ip裡，外面的電腦無法和你的電腦連結</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址是一個容易和IP地址誤解的地址，因為MAC地址號稱全世界唯一，那既然唯一了，為何我們還要IP地址呢？其實MAC地址與其說是個地址，不如說他是個網路ID<br>舉個例子，我們想找的一個人，他的身分證是A123456789，然後他的身分證上面寫的地址是，<code>台北市文山區興隆路五段9弄18號4樓</code>，後面的地址就是像是電腦的IP，而身分證就是這個人．<br>或許你也有聽過，MAC地址其實是可以改的，只要不要在同個內網下有多個MAC地址就好，就像是同個家庭，不要有重複的”身分證”<br>MAC地址從上面的<code>ip addr</code>指令我們可以看到是<code>02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</code></p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> IP </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview-network/"/>
      <url>/2021/09/20/overview-network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成”協議”，巴別塔的計劃就失敗了。<br>但是千年以後，有一種叫”程序猿”的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議(TCP/IP stack)進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的</p><h4 id="為何我們常見的TCP-IP要分層呢？"><a href="#為何我們常見的TCP-IP要分層呢？" class="headerlink" title="為何我們常見的TCP/IP要分層呢？"></a>為何我們常見的TCP/IP要分層呢？</h4><p>因為任何複雜的程式或應用都要分，這是大型程式設計的要求。例如，複雜的電商還會分資料庫層、Cache層、Compose 層和Controller 層等等，每一層專注做本層的事情。</p><p>TCP/IP是一個公認的網路通訊協議，是OSI七層的簡化，五層分別為物理層、鏈結層、網路層、傳輸層和應用層，下面用簡短的話分別解釋這五層是做什麼的</p><p><strong>物理層(Physical):</strong> 處理網路線、無線傳輸設備，例如光纖<br><strong>鏈接層(Link):</strong> 乙太網，由於資料經由網路線傳輸過程中難免會錯誤，這一層具有資料糾錯的功能，例如漢明碼<br><strong>網路層(Internet):</strong> 保證路由，如何把數據從MAC傳輸到另一個MAC<br><strong>傳輸層(Transport):</strong> TCP、UDP，其中TCP保證邏輯上end-to-end的可靠性<br><strong>應用層(Application):</strong> 用於與網路相關應用交互的地方，例如http, ssh等等</p><p>那麼層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線，Header放在每一層數據包的最前面，如下圖所示<br><img src="/images/tcpiplayer.png"></p><p>所以網路封包的傳輸過程是從應用層開始，加header，一直加到下面傳輸層，然後路由器會根據header路由封包到目的地，到了目的地電腦再根據header進行往上逐層解析，再回到應用層</p><p>網路應用開發人員主要了解第三到第五層就好，之後也會偏重解析這三層並基於這三層建構應用。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python的@Decoractor</title>
      <link href="/2021/09/18/decorector-python/"/>
      <url>/2021/09/18/decorector-python/</url>
      
        <content type="html"><![CDATA[<p>今天這篇文章，我們來學習一下Python的Decorator裝飾器</p><p>Decorator在Python是一個非常經典的feature，在工程中也應用廣泛，例如Log, Cache, Threading等等</p><span id="more"></span><h3 id="Function-Decorator"><a href="#Function-Decorator" class="headerlink" title="Function Decorator"></a>Function Decorator</h3><p>其實Decorator是對function的封裝，可以理解為對這個function的前後做一點”裝飾”，我們會從python<code>lambda</code>切入講解，引入Decorator的基本概念和用法，最後透過一個實際的例子加深理解</p><p>前面說過，Python的一切皆為Object，連function也不例外，我們看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">helloworld = func</span><br><span class="line">helloworld()</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>從上面的例子，我們把func作為一個variable賦予helloworld，然後call helloworld，相當於call了func<br>所以我們也可以把function作為一個參數傳到另外一個function裡面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    func()</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>有了這些基礎概念後，我們接下來可以深入挖掘Decorator<br>按照Decorator的思路，就是對某一個function做前後包裝，例如我們想要計算每個傳進來的function執行花了多少時間，可以這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">printer(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.220008850097656e-05 secs</span></span><br></pre></td></tr></table></figure><p>更通用一點，我們可以把printer封裝成更generic一點的function直接return</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">printer = decorator_benchmark(print_hello_world)</span><br><span class="line">printer()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 5.2928924560546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們把原本的<code>print_hello_world</code>封裝成<code>decorator_benchmark</code>的內置函數，這樣在外面call就會非常的簡潔，不過這樣還是有點浪費唇舌，如果我們總是需要對<code>print_hello_world</code>測量性能，call之前都需要對他封裝一次，那有沒有一個更簡潔的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_benchmark</span>(<span class="params">func</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">       start = time.time()</span><br><span class="line">       func()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;Time consumed: %s secs&#x27;</span> % (time.time()-start))</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Time consumed: 4.38690185546875e-05 secs</span></span><br></pre></td></tr></table></figure><p>我們在<code>print_hello_world</code>上面加了<code>@decorator_benchmark</code>，其中<code>@</code>，是Python裡的語法糖，我們可以對一些常見的功能例如benchmark、Log等等寫成一個Decorator function，然後再對其他函數進行”裝飾”，這樣就大大提高了程式的重複利用和可讀性</p><p>當然，Decorator具有強大的靈活性，我們也可以對其傳入參數，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>不過這樣寫有個副作用是，我們裝飾後的<code>print_hello_world</code>的metadata就被改變了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure><p>他告訴了我們function不再是原來的<code>print_hello_world</code>，而是被<code>wrapper</code>取代了<br>不過俗話說的好，見招拆招，為了解決這個問題，我們可以使用Python已有的Decorator <code>@functools.wrap</code>，他會保留原本函數的metadata(也就是將原本函數的metadata copy到Decorator裡面)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">num</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">      @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">   <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(print_hello_world)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Help on function print_hello_world in module __main__:</span></span><br><span class="line"><span class="comment"># print_hello_world()</span></span><br></pre></td></tr></table></figure><h4 id="Class-Decorator"><a href="#Class-Decorator" class="headerlink" title="Class Decorator"></a>Class Decorator</h4><p>最後來說說Class Decorator，前面提到的Decorator是以function為形式的，其實class也可以做為Decorator，這樣可以持久化存一些資料．Class Decorator藉由函數<code>__call__</code>，每當call一次被裝飾的function時，就會call一次<code>__call__</code>，我們以”計算函數被call的次數”作為例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">      self.num_call = <span class="number">0</span></span><br><span class="line">      self.func = func</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">      self.num_call += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Num of call is %s&quot;</span> % self.num_call)</span><br><span class="line">      <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span>():</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_hello_world()</span><br><span class="line">print_hello_world()</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Num of call is 1</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># Num of call is 2</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>所謂的Decorator，就是透過去”裝飾”函數，增加或改變已有函數的功能，使得原有函數不需要修改，有如下優點</p><ul><li>封裝原有程式碼</li><li>程式碼簡潔</li><li>易讀</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python Object的比較和複製</title>
      <link href="/2021/09/16/object-op-python/"/>
      <url>/2021/09/16/object-op-python/</url>
      
        <content type="html"><![CDATA[<p>Python的任何variable都是C++的Object<br>所以我們在對Python的variable做任何操作時，其實就是在對Object做，例如我們做variable比較</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><span id="more"></span><p>variable複製</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = <span class="built_in">list</span>(a)</span><br></pre></td></tr></table></figure><p>可是如果只是”賦予”新的variable，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = a</span><br><span class="line">&gt;&gt; b.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt; a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>b會影響a，因為他們共享同個記憶體上的address<br>不過透過上面的範例，你可能還是不太清楚</p><ul><li><code>a==b</code>是比較兩個object address相等呢？還是value相等呢?</li><li><code>b = list(a)</code>是shallow copy還是deep copy呢？</li></ul><h4 id="比較語法"><a href="#比較語法" class="headerlink" title="比較語法"></a>比較語法</h4><p>在Python中你應該遇過下面兩個語法，你能分辨出有什麼不同嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>==</code>表示兩個varaibles的”值”是否相等，<code>is</code>表示兩個varaibles是否為同一個Object，是否address也相同<br>在Python中，我們可以透過<code>id(variable)</code>去拿variable的唯一ID，所以判斷<code>a is b</code>如同<code>id(a) == id(b)</code><br>我們再看一個百思不得其解的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">10</span></span><br><span class="line">&gt;&gt; b = <span class="number">10</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>咦？a和b是兩個不同的變數呀，為何他們的id會相同呢？<br>我們說過，Python的任何variable都是C++的Object，int也不例外，然而為了提升性能，C++把常用的數字-5到256是先定義好，作為cache使用，當Python需要時，直接從這個pool拿去引用，於是乎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">257</span></span><br><span class="line">&gt;&gt; b = <span class="number">257</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>有興趣的讀者可以試試<br>再來，我們來探討<code>==</code>和<code>is</code>性能的部分<br>通常，<code>is</code>會比<code>==</code>快很多，因為<code>is</code>不會被overload，這樣Python就不需要去尋找<code>__eq__</code>，<code>a == b</code>實際上做的事情等同於<code>a.__eq__(b)</code></p><h4 id="copy語法"><a href="#copy語法" class="headerlink" title="copy語法"></a>copy語法</h4><p>所謂的copy，指的是重新分配一塊記憶體，創建一個新的Object，所以他們的id肯定是不同的，而copy又分shallow copy和deep copy<br>所謂的shallow copy，新的Object裡面的元素是原本Object裡面元素的引用，所以如果Object裡面的Object被改了，新舊Object都會被連動，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>可以看到variable b append 4之後，a裡面的list也被影響了<br>而deep copy，相對於shadow copy來說，會遞迴的方式往裡面一直copy，所以新的Object和舊的Object沒有任何關聯<br>Python中透過copy.deepcopy(object)實現deep copy，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>我們可以看到a不受任何影響即使b append了4<br>最後我們再來探討mutable(可變) Object和unmutable(不可變) object，看一下下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>我們可以看到，a+=1後竟然沒有影響b，不是說Python一切variable皆是object嗎？<br>這是因為在Python中int, float, string, tuple等等屬於unmutable object，不能改object裡面的值，我們可以看到a+=1之後，a的id變了，代表他被重新賦予新的object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809328</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140628677809168</span></span><br></pre></td></tr></table></figure><p>而dict, array, set等等，屬於mutable object，在assign或是當作參數傳進去function的時候，會影響該variable</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這篇文章講了Python的variable怎麼做比較和複製</p><ul><li>Python的一切皆為Object，所以比較和複製的思維可以參考C++</li><li>Object間的比較分成address和value的比較，分別為<code>is</code>和<code>==</code></li><li>Object間的複製分成shallow和deep copy，一個只複製了第一層的value，另一個會遞迴複製</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object-storage/"/>
      <url>/2021/09/13/object-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="Object-storage-物件儲存"><a href="#Object-storage-物件儲存" class="headerlink" title="Object storage(物件儲存)"></a>Object storage(物件儲存)</h3><p>Object Storage - 雲端系統上最流行的儲存方式</p><span id="more"></span><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合</p><p>Metadata的部分，他不像File system是固定的inode資料結構，Object storage可以隨意自己定義metadata的資料結構，可以非常詳細以幫助快速檢索目標object</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務</p><p>從high level講，也就是使用方式講，Object storage是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要“方便”分散且”容易”伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個“資料夾”加大了空間</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的”安全性“，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如Raid5這種空間使用率只要150%，但是保護力也有1</p><p><strong>優點</strong></p><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</li><li><strong>成本低</strong>：<br>公有雲端上的Object storage都特別便宜，例如Amazon S3</li><li><strong>API 簡單</strong>:<br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能修改</strong>:<br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</li><li><strong>無法和database整合</strong>:<br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</li><li><strong>無法與一般作業系統整合</strong>:<br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file-storage/"/>
      <url>/2021/09/12/file-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="File-storage-檔案系統"><a href="#File-storage-檔案系統" class="headerlink" title="File storage(檔案系統)"></a>File storage(檔案系統)</h3><p>有了File storage，我們用滑鼠鍵盤就能操控資料</p><span id="more"></span><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我們怎麼知道我的資料存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好</p><p>任何架構的難題只需要加一層就可以解決，如果不行，那就兩層，為了讓人能夠輕鬆的操作儲存資料，我們在Block storage上面加了一層File system</p><p>我們平常用的Windows就File system，這大家應該很熟悉，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，文件的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的就叫做inode</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p> inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><p>那作業系統是如何讀取檔案資料呢？</p><p>首先，不是透過檔案名字，文件名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，根據使用者點開的文件找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼</p><p>第二，根據inode號碼找到inode的data</p><p>最後，根據indoe的data，找到檔案裡的數據存在哪個block</p><p><strong>優點</strong><br>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他</li><li><strong>成本低</strong>：<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</li></ul><p><strong>缺點</strong></p><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</li><li><strong>難以遷移</strong>:<br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 檔案系統 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block-storage/"/>
      <url>/2021/09/05/block-storage/</url>
      
        <content type="html"><![CDATA[<h3 id="Block-storage-塊儲存"><a href="#Block-storage-塊儲存" class="headerlink" title="Block storage(塊儲存)"></a>Block storage(塊儲存)</h3><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p><span id="more"></span><p>我們都知道資料是以1和0儲存在某個”介質”上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，而Block storage簡單來說就是我們能看到的一塊塊的硬碟</p><p>接下來，我們有了作業系統，才能把資料存進去硬碟了，那麼回答一個問題，作業系統是如何與硬碟打交道呢？首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也方便了多台主機共享一個儲存設備</p><p>為什麼叫做block呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，大約是512，這樣的設定能提升資料讀寫的速度，一個block對應一個或多個硬體的扇區(sector)，所以block是邏輯地址，sector是實體地址</p><p>我們拿機械式硬碟HDD舉例，如下圖所示<br><img src="/images/sector.png"><br>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的”扇區”就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點<br><strong>優點</strong><br>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><strong>高性能</strong>:<br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作database server</li><li><strong>易於修改</strong>:<br>如果想改變文件裡的一個小部分資料，直接改那個block就可以，如果是文件系統或object system，需要整個file或object都改</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個LUN ID就可以接上系統了，較沒有性能瓶頸</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</li><li><strong>Metadata</strong>:<br>沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
