<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[網路]IP&amp;MAC地址 - 網路通訊世界的大門</title>
      <link href="/2021/09/23/ipbasic_network/"/>
      <url>/2021/09/23/ipbasic_network/</url>
      
        <content type="html"><![CDATA[<h3 id="每一個網卡都有一個ip和mac，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼">每一個網卡都有一個IP和MAC，是在網路世界的通訊地址，相當於現實中家家戶戶的門牌號碼</h3><p>警察撿到了你的身分證，看了上面的戶籍地址，想把身分證歸還給你，他是怎麼找到你的呢？<br>透過了地址(IP)，找到了你的家，按下你家的門鈴後，大喊了身分證號碼(MAC)，歸還給了對的人</p><span id="more"></span><h3 id="ip地址">IP地址</h3><p>那麼，在你的電腦裡，我們要怎麼查我們電腦裡的IP門牌號碼呢？</p><p>在Linux，有兩個指令可以查詢，分別為<code>ifconfig</code>和<code>ip addr</code><br><strong>ifconfig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6251  bytes 9073424 (8.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3111  bytes 170522 (166.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ip addr</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt; ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>ifconfig來自於Linux的net-tools而ip addr來自於iproute2．net-tools起源於BSD，自2001年起，Linux社群已經對其停止維護，而iproute2旨在取代net-tools，並提供了一些新功能。一些Linux發行版已經停止支援net-tools，只支援iproute2。 net-tools通過procfs(/proc)和ioctl system call去訪問和改變kernel網路設定，而iproute2則通過netlink socket interface與kernel通訊。 net-tools中工具的名字比較雜亂，而iproute2則相對整齊和直觀，基本是ip command加後面的sub-command。不過這麼多年過去了，net-tool依然還在被廣泛使用，最好還是兩套指令都掌握吧。</p></blockquote><p>IP地址是門牌號碼，所以不能大家都一樣，不然就會起衝突．舉個例子，<code>132.128.200.32</code>是一個IP地址，由三個&quot;.&quot;分成四個部分，每個部分有8個bit，四個部分加起來總共有32個bit，也就是最多只能產生{2**32}個門牌號碼．因為不夠用，所以有了IPv6，也就是上面的輸出結果<code>fe80::ca61:d665:1750:e806</code>，總共有128位，看起來應該是夠了．</p><p>由於現有的32bit ip地址不這麼夠用，其中ip又有分私人ip(自己內網的ip)和公共ip(任何地方都能連的ip，例如Google)，其中，下面的ip地址範圍就是私人地址</p><table><thead><tr><th>地址範圍</th><th>數量</th></tr></thead><tbody><tr><td>10.0.0.0–10.255.255.255</td><td>16,777,216</td></tr><tr><td>172.16.0.0–172.31.255.255</td><td>1,048,576</td></tr><tr><td>192.168.0.0–192.168.255.255</td><td>65,536</td></tr><tr><td>所以說，下次你跑<code>ip addr</code>看到你的ip是<code>192.168.2.132</code>不用懷疑，你在私人ip裡，外面的電腦無法和你的電腦連結</td><td></td></tr></tbody></table><h3 id="mac地址">MAC地址</h3><p>MAC地址是一個容易和IP地址誤解的地址，因為MAC地址號稱全世界唯一，那既然唯一了，為何我們還要IP地址呢？其實MAC地址與其說是個地址，不如說他是個網路ID<br>舉個例子，我們想找的一個人，他的身分證是A123456789，然後他的身分證上面寫的地址是，<code>台北市文山區興隆路五段9弄18號4樓</code>，後面的地址就是像是電腦的IP，而身分證就是這個人．<br>或許你也有聽過，MAC地址其實是可以改的，只要不要在同個內網下有多個MAC地址就好，就像是同個家庭，不要有重複的&quot;身分證&quot;<br>MAC地址從上面的<code>ip addr</code>指令我們可以看到是<code>02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</code></p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> IP </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview_network/"/>
      <url>/2021/09/20/overview_network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成&quot;協議&quot;，巴別塔的計劃就失敗了。<br>但是千年以後，有一種叫&quot;程序猿&quot;的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議(TCP/IP stack)進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的</p><h4 id="為何我們常見的tcp/ip要分層呢？">為何我們常見的TCP/IP要分層呢？</h4><p>因為任何複雜的程式或應用都要分，這是大型程式設計的要求。例如，複雜的電商還會分資料庫層、Cache層、Compose 層和Controller 層等等，每一層專注做本層的事情。</p><p>TCP/IP是一個公認的網路通訊協議，是OSI七層的簡化，五層分別為物理層、鏈結層、網路層、傳輸層和應用層，下面用簡短的話分別解釋這五層是做什麼的</p><p><strong>物理層(Physical):</strong> 處理網路線、無線傳輸設備，例如光纖<br><strong>鏈接層(Link):</strong> 乙太網，由於資料經由網路線傳輸過程中難免會錯誤，這一層具有資料糾錯的功能，例如漢明碼<br><strong>網路層(Internet):</strong> 保證路由，如何把數據從MAC傳輸到另一個MAC<br><strong>傳輸層(Transport):</strong> TCP、UDP，其中TCP保證邏輯上end-to-end的可靠性<br><strong>應用層(Application):</strong> 用於與網路相關應用交互的地方，例如http, ssh等等</p><p>那麼層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線，Header放在每一層數據包的最前面，如下圖所示<br><img src="/images/tcpiplayer.png" alt=""></p><p>所以網路封包的傳輸過程是從應用層開始，加header，一直加到下面傳輸層，然後路由器會根據header路由封包到目的地，到了目的地電腦再根據header進行往上逐層解析，再回到應用層</p><p>網路應用開發人員主要了解第三到第五層就好，之後也會偏重解析這三層並基於這三層建構應用。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python進階]Python Object的比較和複製</title>
      <link href="/2021/09/16/object-op-python/"/>
      <url>/2021/09/16/object-op-python/</url>
      
        <content type="html"><![CDATA[<p>Python的任何variable都是C++的Object<br>所以我們在對Python的variable做任何操作時，其實就是在對Object做，例如我們做variable比較</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><span id="more"></span><p>variable複製</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = <span class="built_in">list</span>(a)</span><br></pre></td></tr></table></figure><p>可是如果只是&quot;賦予&quot;新的variable，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt; b = a</span><br><span class="line">&gt;&gt; b.append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt; a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>b會影響a，因為他們共享同個記憶體上的address<br>不過透過上面的範例，你可能還是不太清楚</p><ul><li><code>a==b</code>是比較兩個object address相等呢？還是value相等呢?</li><li><code>b = list(a)</code>是shallow copy還是deep copy呢？</li></ul><h4 id="比較語法">比較語法</h4><p>在Python中你應該遇過下面兩個語法，你能分辨出有什麼不同嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><code>==</code>表示兩個varaibles的&quot;值&quot;是否相等，<code>is</code>表示兩個varaibles是否為同一個Object，是否address也相同<br>在Python中，我們可以透過<code>id(variable)</code>去拿variable的唯一ID，所以判斷<code>a is b</code>如同<code>id(a) == id(b)</code><br>我們再看一個百思不得其解的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">10</span></span><br><span class="line">&gt;&gt; b = <span class="number">10</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>咦？a和b是兩個不同的變數呀，為何他們的id會相同呢？<br>我們說過，Python的任何variable都是C++的Object，int也不例外，然而為了提升性能，C++把常用的數字-5到256是先定義好，作為cache使用，當Python需要時，直接從這個pool拿去引用，於是乎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = <span class="number">257</span></span><br><span class="line">&gt;&gt; b = <span class="number">257</span></span><br><span class="line">&gt;&gt; a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>有興趣的讀者可以試試<br>再來，我們來探討<code>==</code>和<code>is</code>性能的部分<br>通常，<code>is</code>會比<code>==</code>快很多，因為<code>is</code>不會被overload，這樣Python就不需要去尋找<code>__eq__</code>，<code>a == b</code>實際上做的事情等同於<code>a.__eq__(b)</code></p><h4 id="copy語法">copy語法</h4><p>所謂的copy，指的是重新分配一塊記憶體，創建一個新的Object，所以他們的id肯定是不同的，而copy又分shallow copy和deep copy<br>所謂的shallow copy，新的Object裡面的元素是原本Object裡面元素的引用，所以如果Object裡面的Object被改了，新舊Object都會被連動，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>可以看到variable b append 4之後，a裡面的list也被影響了<br>而deep copy，相對於shadow copy來說，會遞歸的方式往裡面一直copy，所以新的Object和舊的Object沒有任何關聯<br>Python中透過copy.deepcopy(object)實現deep copy，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>我們可以看到a不受任何影響即使b append了4</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object_storage/"/>
      <url>/2021/09/13/object_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="object-storage(物件儲存)">Object storage(物件儲存)</h3><p>Object Storage - 雲端系統上最流行的儲存方式</p><span id="more"></span><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合</p><p>Metadata的部分，他不像File system是固定的inode資料結構，Object storage可以隨意自己定義metadata的資料結構，可以非常詳細以幫助快速檢索目標object</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務</p><p>從high level講，也就是使用方式講，Object storage是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要“方便”分散且&quot;容易&quot;伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個“資料夾”加大了空間</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的”安全性“，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如Raid5這種空間使用率只要150%，但是保護力也有1</p><p><strong>優點</strong></p><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</li><li><strong>成本低</strong>：<br>公有雲端上的Object storage都特別便宜，例如Amazon S3</li><li><strong>API 簡單</strong>:<br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能修改</strong>:<br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</li><li><strong>無法和database整合</strong>:<br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</li><li><strong>無法與一般作業系統整合</strong>:<br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file_storage/"/>
      <url>/2021/09/12/file_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="file-storage(檔案系統)">File storage(檔案系統)</h3><p>有了File storage，我們用滑鼠鍵盤就能操控資料</p><span id="more"></span><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我們怎麼知道我的資料存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好</p><p>任何架構的難題只需要加一層就可以解決，如果不行，那就兩層，為了讓人能夠輕鬆的操作儲存資料，我們在Block storage上面加了一層File system</p><p>我們平常用的Windows就File system，這大家應該很熟悉，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，文件的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的就叫做inode</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><p>那作業系統是如何讀取檔案資料呢？</p><p>首先，不是透過檔案名字，文件名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，根據使用者點開的文件找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼</p><p>第二，根據inode號碼找到inode的data</p><p>最後，根據indoe的data，找到檔案裡的數據存在哪個block</p><p><strong>優點</strong><br>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他</li><li><strong>成本低</strong>：<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</li></ul><p><strong>缺點</strong></p><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</li><li><strong>難以遷移</strong>:<br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 檔案系統 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block_storage/"/>
      <url>/2021/09/05/block_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="block-storage(塊儲存)">Block storage(塊儲存)</h3><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p><span id="more"></span><p>我們都知道資料是以1和0儲存在某個&quot;介質&quot;上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，而Block storage簡單來說就是我們能看到的一塊塊的硬碟</p><p>接下來，我們有了作業系統，才能把資料存進去硬碟了，那麼回答一個問題，作業系統是如何與硬碟打交道呢？首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也方便了多台主機共享一個儲存設備</p><p>為什麼叫做block呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，大約是512，這樣的設定能提升資料讀寫的速度，一個block對應一個或多個硬體的扇區(sector)，所以block是邏輯地址，sector是實體地址</p><p>我們拿機械式硬碟HDD舉例，如下圖所示<br><img src="/images/sector.png" alt=""><br>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的&quot;扇區&quot;就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點<br><strong>優點</strong><br>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><strong>高性能</strong>:<br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作database server</li><li><strong>易於修改</strong>:<br>如果想改變文件裡的一個小部分資料，直接改那個block就可以，如果是文件系統或object system，需要整個file或object都改</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個LUN ID就可以接上系統了，較沒有性能瓶頸</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</li><li><strong>Metadata</strong>:<br>沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 儲存 </tag>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2013/11/06/hello-world/"/>
      <url>/2013/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a new post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to remote sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> aCategory </category>
          
          <category> anotherCategory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aTag </tag>
            
            <tag> anotherTag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
