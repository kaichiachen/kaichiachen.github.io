<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[網路]TCP/IP - 計算機網路是什麼?</title>
      <link href="/2021/09/20/overview_network/"/>
      <url>/2021/09/20/overview_network/</url>
      
        <content type="html"><![CDATA[<p>《聖經》裡面有一個巴別塔的故事，大致是說，上帝為了阻止人類聯合起來，就讓人類說不同的語言。人類之間沒法溝通，達不成&quot;協議&quot;，巴別塔的計劃就失敗了。<br>但是千年以後，有一種叫&quot;程序猿&quot;的物種，敲著一種這個群體通用的語言，連接著全世界所有的人，打造這網路世界的通天塔。如今的世界，正是因為網路，才連接在一起。</p><span id="more"></span><p>電腦之間的資料交換大部分都是透過網際網路，每台電腦上獨一無二的MAC地址就是電腦的唯一地址，傳輸過程中遵循公認的協議(TCP/IP stack)進行編解碼，並借由MAC和IP地址一層一層的送達指定的目的</p><h6 id="為何我們常見的tcp/ip要分層呢？">為何我們常見的TCP/IP要分層呢？</h6><p>因為任何複雜的程式或應用都要分，這是大型程式設計的要求。例如，複雜的電商還會分資料庫層、Cache層、Compose 層和Controller 層等等，每一層專注做本層的事情。</p><p>雖然寫網路服務使用TCP/IP五層協議進行交互，我會介紹TCP/IP的五層結構，如果有開發相關的應用，能更好的理解，如果沒有也沒關係，我會帶著利用Python開發一個類似wireshark或tcpdump的應用，解析TCP/IP stack的原理。</p><p>Github: <a href="https://github.com/kaichiachen/pytcpdump">https://github.com/kaichiachen/pytcpdump</a></p><p>TCP/IP是一個公認的網路通訊協議，是OSI七層的簡化，五層分別為物理層、鏈結層、網路層、傳輸層和應用層，下面用簡短的話分別解釋這五層是做什麼的</p><p><strong>物理層(Physical):</strong> 處理網路線、無線傳輸設備，例如光纖<br><strong>鏈接層(Link):</strong> 乙太網，由於資料經由網路線傳輸過程中難免會錯誤，這一層具有資料糾錯的功能，例如漢明碼<br><strong>網路層(Internet):</strong> 保證路由，如何把數據從MAC傳輸到另一個MAC<br><strong>傳輸層(Transport):</strong> TCP、UDP，其中TCP保證邏輯上end-to-end的可靠性<br><strong>應用層(Application):</strong> 用於與網路相關應用交互的地方，例如http, ssh等等</p><p>那麼層與層之間有沒有明確的界線呢？雖然傳進來的封包都是bytes array，但是可以利用TCP/IP每一層固定的Header長度定義明確的界線，Header放在每一層數據包的最前面，如下圖所示<br><img src="/images/tcpiplayer.png" alt=""></p><p>所以網路封包的傳輸過程是從應用層開始，加header，一直加到下面傳輸層，然後路由器會根據header路由封包到目的地，到了目的地電腦再根據header進行往上逐層解析，再回到應用層</p><p>網路應用開發人員主要了解第三到第五層就好，之後也會偏重解析這三層並基於這三層建構應用。</p>]]></content>
      
      
      <categories>
          
          <category> 網路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Object storage</title>
      <link href="/2021/09/13/object_storage/"/>
      <url>/2021/09/13/object_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="object-storage(物件儲存)">Object storage(物件儲存)</h3><p>Object Storage - 雲端系統上最流行的儲存方式</p><span id="more"></span><p>Object storage和File storage一樣，是基於Block storage的，首先，與File storage方式不同，File storage就像是一棵樹，從點進去一個資料夾開始，裡面有很多檔案(葉子)，也有資料夾(樹枝)，再點進去資料夾，又會有檔案、資料夾，是一個樹狀結構，Object storage是扁平化結構，可以理解為所有檔案都存在一個資料夾裡，包括Object的metadata，且資料夾裡不會有資料夾，Object就是一個檔案，也可以是多個檔案的非結構化組合</p><p>Metadata的部分，他不像File system是固定的inode資料結構，Object storage可以隨意自己定義metadata的資料結構，可以非常詳細以幫助快速檢索目標object</p><p>綜上所述，Object storage非常適合存靜態不常使用的大數據，例如大量的影片、音樂等等，為使用者提供大量、安全、低成本的資料儲存服務</p><p>從high level講，也就是使用方式講，Object storage是透過http API對資料進行增刪改查，與File systemAPI和Block storage的SCSI不同，Object storage更加方便各個語言的使用</p><p>正因為他的扁平化架構，他天生就適合作為分散式儲存的儲存方式，為何這麼說呢？首先，分散式儲存必須要“方便”分散且&quot;容易&quot;伸縮，由於是扁平化架構，我們容易把object切塊平均分散在不同機器，伸縮也非常方便，加了一台機器，等於對這個“資料夾”加大了空間</p><p>加了機器除了可以提升儲存空間之外，還能提升資料的”安全性“，例如一個object，我可以複製兩份，這樣我們可以說他的空間使用率是200%，保護力是1，因為他容許一台機器掛掉資料還在，雖然這種保護方法直觀簡單，但是現在各大雲端廠商為了節省成本，透過一些奇偶校驗法會使用例如Raid5這種空間使用率只要150%，但是保護力也有1</p><p><strong>優點</strong></p><ul><li><strong>方便擴增</strong>:<br>由於Object storage是扁平化架構，只要增加機器就是增加這個大平面的面積，不需要額外修改架構</li><li><strong>成本低</strong>：<br>公有雲端上的Object storage都特別便宜，例如Amazon S3</li><li><strong>API 簡單</strong>:<br>單純的使用HTTP進行增刪改查，進而支持長距離使用，例如你在台灣可以使用位在美國的Amazon S3儲存服務</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能修改</strong>:<br>由於最小單位就是一個Object，所以想要修改一個Object代表需要上傳一個新的Object替換他，而File system還能在末尾增加一行資料</li><li><strong>無法和database整合</strong>:<br>傳統的database是結構化數據，例如SQL, Mysql等等，而object storage存放的主要是非結構化數據，且object storage的讀寫慢</li><li><strong>無法與一般作業系統整合</strong>:<br>因為一般的作業系統都是File system，下載一個object就像是下載一個檔案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物件儲存 </tag>
            
            <tag> object storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - File storage</title>
      <link href="/2021/09/12/file_storage/"/>
      <url>/2021/09/12/file_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="file-storage(檔案系統)">File storage(檔案系統)</h3><p>有了File storage，我們用滑鼠鍵盤就能操控資料</p><span id="more"></span><p>如果要和硬碟直接打交道，Block storage是唯一的方式，只是對人非常不友好，我們怎麼知道我的資料存在哪裏？是連續的存呢？還是分散的存？如果每筆資料都連續的存，那肯定對硬碟的利用率不友好</p><p>任何架構的難題只需要加一層就可以解決，如果不行，那就兩層，為了讓人能夠輕鬆的操作儲存資料，我們在Block storage上面加了一層File system</p><p>我們平常用的Windows就File system，這大家應該很熟悉，由於File system就是Block storage上面加一層，所以檔案的內容都是存在一個個的block中</p><p>除了檔案的內容之外，文件的metadata比如創建時間、權限、大小等等也需要存在另一個地方，專門存這些文件metadata的就叫做inode</p><p>一個檔案的inode可以透過stat來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&gt; stat demo.txt</span><br><span class="line">  File: ‘demo.txt’</span><br><span class="line">  Size: 12        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd02h/64770dInode: 238749826   Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (51426876/ ckaijia)   Gid: (  201/     mts)</span><br><span class="line">Access: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Modify: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line">Change: 2021-08-28 07:27:02.001795167 -0700</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode也會消耗儲存空間，所以格式化硬碟的時候，作業系統會將硬碟分成兩個區域，一個存數據，一個存inode，並且指定一個inode的大小，所以就算檔案很小，一塊硬碟裡還是有檔案數量的限制</p><p>那作業系統是如何讀取檔案資料呢？</p><p>首先，不是透過檔案名字，文件名字只是讓使用者方便識別，作業系統透過inode ID，每個inode都有一個號碼，根據使用者點開的文件找到inode號碼，可以透過<code>ls -i demo.txt</code>看到對應的inode號碼</p><p>第二，根據inode號碼找到inode的data</p><p>最後，根據indoe的data，找到檔案裡的數據存在哪個block</p><p><strong>優點</strong><br>File system最大的優點就是他對人類友好，有目錄結構、好記得名字等等，方便UI呈現，除此之外還有如下優點</p><ul><li><strong>方便共享</strong>:<br>一個inode就能與其他同台電腦上的user直接分享檔案，而且有權限控制</li><li><strong>安全</strong>:<br>如上述所示，Linux有三種權限控制 - 自己、組和其他</li><li><strong>成本低</strong>：<br>不需要昂貴的光纖，只要買機器，接上外接硬碟，透過作業系統上的File system，就可以使用</li></ul><p><strong>缺點</strong></p><ul><li><strong>資料讀寫慢</strong>:<br>因為讀取跟寫入都有兩層，除了讀寫本身資料(Block storage)之外，還有inode裡的metadata需要處理</li><li><strong>難以遷移</strong>:<br>如過想把文件都搬遷到另一個作業系統有點困難，如果file storage的格式不同或inode的演算法不同就更糟了</li><li><strong>權限控制</strong>:<br>權限控制只有三層 - 自己、group、others，無法滿足更複雜的需求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 檔案儲存 </tag>
            
            <tag> file storage </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[儲存]資料儲存的基礎知識 - Block storage</title>
      <link href="/2021/09/05/block_storage/"/>
      <url>/2021/09/05/block_storage/</url>
      
        <content type="html"><![CDATA[<h3 id="block-storage(塊儲存)">Block storage(塊儲存)</h3><p>Block storage是最基本的儲存系統，所以讓我們從這裡開始</p><span id="more"></span><p>我們都知道資料是以1和0儲存在某個&quot;介質&quot;上面，例如機械式硬碟(HDD)利用磁性，而固態硬碟(SSD)利用電子，而Block storage簡單來說就是我們能看到的一塊塊的硬碟</p><p>接下來，我們有了作業系統，才能把資料存進去硬碟了，那麼回答一個問題，作業系統是如何與硬碟打交道呢？首先，作業系統利用LUN ID識別硬碟，LUN是一個或一組或半個硬碟的邏輯代號，為何有半個呢？例如我們的windows有一個硬碟，把他分成C槽和D槽，那麼他們就是各半個，LUN他不是獨佔式的，也方便了多台主機共享一個儲存設備</p><p>為什麼叫做block呢？從作業系統的角度，資料的讀取和寫入都是以block為最小單位，一個block是一段固定長度的bytes，大約是512，這樣的設定能提升資料讀寫的速度，一個block對應一個或多個硬體的扇區(sector)，所以block是邏輯地址，sector是實體地址</p><p>我們拿機械式硬碟HDD舉例，如下圖所示<br><img src="/images/sector.png" alt=""><br>HDD就是用類似光碟的圓盤一個個堆疊出來了，剛剛提到的&quot;扇區&quot;就是上圖的sector，代表同個半徑下一小塊長度</p><p>最後總結一下Block storage有什麼優缺點<br><strong>優點</strong><br>Block storage最大的優點就是他使得計算與儲存分離，我們能輕易地透過LUN ID外接一個硬碟或硬碟組</p><ul><li><strong>高性能</strong>:<br>IOPS(Inputs Outputs per Seconds)高，延遲低，適合用作database server</li><li><strong>易於修改</strong>:<br>如果想改變文件裡的一個小部分資料，直接改那個block就可以，如果是文件系統或object system，需要整個file或object都改</li><li><strong>擴充容易</strong>:<br>擴充非常簡單，一個LUN ID就可以接上系統了，較沒有性能瓶頸</li></ul><p><strong>缺點</strong></p><ul><li><strong>不能同時讀寫</strong>：<br>不能多台機器同時讀寫同一塊硬碟，雖然可以透過軟體解決此問題但是會造成性能下降</li><li><strong>Metadata</strong>:<br>沒有什麼Metadata，File system有檔案路徑、名字、大小等等快速定位資料，Block storage只有地址起始位置(LBA)、長度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 儲存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 塊儲存 </tag>
            
            <tag> block storage </tag>
            
            <tag> SSD </tag>
            
            <tag> HDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2013/11/06/hello-world/"/>
      <url>/2013/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a new post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to remote sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> aCategory </category>
          
          <category> anotherCategory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aTag </tag>
            
            <tag> anotherTag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
